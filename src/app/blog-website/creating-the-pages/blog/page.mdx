import BackToTop from "@/components/BackToTop";

# The Blog Page

## Table of Contents

## Introduction

The blog page is a central part of any blog website, where users can read and explore various blog posts. It typically includes a list of blog cards, each representing a different post. This page can be designed to showcase the latest posts, popular posts, or posts from specific categories. It is essential to create an engaging and user-friendly layout that encourages visitors to read more.

## Fetching Blog Posts from `.mdx` Files

To fetch blog posts from `.mdx` files, we can use the `getStaticProps` function in Next.js. This function allows us to read the contents of the `.mdx` files and pass them as props to the blog page component.

```typescript
import fs from "fs";
import path from "path";
import matter from "gray-matter";
import { GetStaticProps } from "next";
import { BlogPost } from "@/types/blog";
export const getStaticProps: GetStaticProps = async () => {
  const files = fs.readdirSync(
    path.join("src", "app", "blog-website", "blog-posts")
  );

  const posts = files.map((fileName) => {
    const filePath = path.join(
      "src",
      "app",
      "blog-website",
      "blog-posts",
      fileName
    );
    const fileContent = fs.readFileSync(filePath, "utf-8");
    const { data } = matter(fileContent);

    return {
      ...data,
      slug: fileName.replace(".mdx", ""),
    } as BlogPost;
  });

  return {
    props: {
      posts,
    },
  };
};
```

## Displaying Blog Cards

By using the fetched blog posts, we can create a list of blog cards. Each card will display the title, description, and a link to read more about the post.

Here, we need to iterate over the `posts` array and render a card for each post. We can use a simple card component that takes the post data as props.

**NOTE**

> Make sure to visit [Creating the Blog Card Component](/blog-website/creating-the-components/blog-cards) to learn how to create the blog card component if you haven't done so already.

## Blog Page Component

Finally, we can create the main blog page component that uses the `getStaticProps` function to fetch the posts and render the blog cards.

```typescript
import { GetStaticProps } from "next";
import { BlogPost } from "@/types/blog";
import BlogCard from "@/components/BlogCard";
import BackToTop from "@/components/BackToTop";
const BlogPage = ({ posts }: { posts: BlogPost[] }) => {
  return (
    <div className="blog-page">
      <h1>Blog</h1>
      <div className="blog-cards">
        {posts.map((post) => (
          <BlogCard key={post.slug} post={post} />
        ))}
      </div>
      <BackToTop />
    </div>
  );
};
export default BlogPage;
```

<BackToTop />

## Optional Enhancements

### Pagination

To enhance the blog page, you can implement pagination to display a limited number of posts per page. This can be done by using query parameters to determine which posts to display based on the current page.

#### Example #1: Minimal Pagination

```tsx
import React, { useState } from "react";
import { BlogPost } from "@/types/blog";
import BlogCard from "@/components/BlogCard";

interface PaginatedBlogProps {
  posts: BlogPost[];
  postsPerPage?: number;
}

const PaginatedBlog: React.FC<PaginatedBlogProps> = ({ 
  posts, 
  postsPerPage = 6 
}) => {
  const [currentPage, setCurrentPage] = useState(1);
  
  const totalPages = Math.ceil(posts.length / postsPerPage);
  const startIndex = (currentPage - 1) * postsPerPage;
  const currentPosts = posts.slice(startIndex, startIndex + postsPerPage);
  
  const goToPage = (page: number) => {
    setCurrentPage(Math.max(1, Math.min(page, totalPages)));
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };
  
  return (
    <div className="space-y-8">
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {currentPosts.map((post) => (
          <BlogCard key={post.slug} post={post} />
        ))}
      </div>
      
      {totalPages > 1 && (
        <div className="flex justify-center items-center space-x-4">
          <button
            onClick={() => goToPage(currentPage - 1)}
            disabled={currentPage === 1}
            className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-300 transition"
          >
            Previous
          </button>
          
          <span className="text-gray-600">
            Page {currentPage} of {totalPages}
          </span>
          
          <button
            onClick={() => goToPage(currentPage + 1)}
            disabled={currentPage === totalPages}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-blue-700 transition"
          >
            Next
          </button>
        </div>
      )}
    </div>
  );
};

export default PaginatedBlog;
```

##### How It Works

The minimal pagination component divides the blog posts into pages and provides simple Previous/Next navigation. It calculates the total number of pages based on the posts array length and the desired posts per page. The component maintains the current page state and slices the posts array to show only the relevant posts for the current page.

##### Customization Options

- **postsPerPage**: Adjust the number of posts displayed per page (default: 6)
- **Styling**: Customize button colors, spacing, and hover effects
- **Scroll behavior**: Modify the scroll-to-top behavior when changing pages
- **Loading states**: Add loading spinners during page transitions

<BackToTop />

#### Example #2: Displays Page Numbers

```tsx
import React, { useState } from "react";
import { BlogPost } from "@/types/blog";
import BlogCard from "@/components/BlogCard";

interface AdvancedPaginationProps {
  posts: BlogPost[];
  postsPerPage?: number;
}

const AdvancedPagination: React.FC<AdvancedPaginationProps> = ({ 
  posts, 
  postsPerPage = 9 
}) => {
  const [currentPage, setCurrentPage] = useState(1);
  
  const totalPages = Math.ceil(posts.length / postsPerPage);
  const startIndex = (currentPage - 1) * postsPerPage;
  const currentPosts = posts.slice(startIndex, startIndex + postsPerPage);
  
  const getVisiblePages = () => {
    const delta = 2;
    const range = [];
    const rangeWithDots = [];
    
    for (let i = Math.max(2, currentPage - delta); 
         i <= Math.min(totalPages - 1, currentPage + delta); 
         i++) {
      range.push(i);
    }
    
    if (currentPage - delta > 2) {
      rangeWithDots.push(1, '...');
    } else {
      rangeWithDots.push(1);
    }
    
    rangeWithDots.push(...range);
    
    if (currentPage + delta < totalPages - 1) {
      rangeWithDots.push('...', totalPages);
    } else {
      rangeWithDots.push(totalPages);
    }
    
    return rangeWithDots;
  };
  
  const goToPage = (page: number) => {
    setCurrentPage(page);
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };
  
  return (
    <div className="space-y-8">
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {currentPosts.map((post) => (
          <BlogCard key={post.slug} post={post} />
        ))}
      </div>
      
      {totalPages > 1 && (
        <div className="flex justify-center items-center space-x-2">
          <button
            onClick={() => goToPage(currentPage - 1)}
            disabled={currentPage === 1}
            className="px-3 py-2 text-gray-500 hover:text-gray-700 disabled:opacity-50"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
          </button>
          
          {getVisiblePages().map((page, index) => (
            <React.Fragment key={index}>
              {page === '...' ? (
                <span className="px-3 py-2 text-gray-500">...</span>
              ) : (
                <button
                  onClick={() => goToPage(page as number)}
                  className={`px-3 py-2 rounded-lg transition ${
                    currentPage === page
                      ? 'bg-blue-600 text-white'
                      : 'text-gray-700 hover:bg-gray-200'
                  }`}
                >
                  {page}
                </button>
              )}
            </React.Fragment>
          ))}
          
          <button
            onClick={() => goToPage(currentPage + 1)}
            disabled={currentPage === totalPages}
            className="px-3 py-2 text-gray-500 hover:text-gray-700 disabled:opacity-50"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </button>
        </div>
      )}
      
      <div className="text-center text-gray-600 text-sm">
        Showing {startIndex + 1}-{Math.min(startIndex + postsPerPage, posts.length)} of {posts.length} posts
      </div>
    </div>
  );
};

export default AdvancedPagination;
```

##### How It Works

This advanced pagination component displays individual page numbers with smart truncation using ellipsis. It shows the first page, last page, current page, and surrounding pages within a delta range. The `getVisiblePages` function calculates which page numbers to display and where to place ellipsis to keep the pagination bar compact while maintaining usability.

##### Customization Options

- **Delta range**: Adjust how many pages to show around the current page
- **Icons**: Replace arrow icons with custom designs or text
- **Results counter**: Toggle the display of "Showing X-Y of Z posts"
- **Mobile responsiveness**: Adapt the pagination for smaller screens
- **URL synchronization**: Sync pagination state with browser URL

<BackToTop />

### Search Functionality

Adding a search bar allows users to quickly find specific blog posts. You can implement this by filtering the `posts` array based on the search query entered by the user.

#### Example #1: Using a `shadcn/ui` Command component with Keyboard shortcuts

```tsx
import React, { useState, useEffect } from "react";
import { BlogPost } from "@/types/blog";
import BlogCard from "@/components/BlogCard";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Dialog,
  DialogContent,
  DialogTrigger,
} from "@/components/ui/dialog";

interface CommandSearchProps {
  posts: BlogPost[];
}

const CommandSearch: React.FC<CommandSearchProps> = ({ posts }) => {
  const [open, setOpen] = useState(false);
  const [filteredPosts, setFilteredPosts] = useState(posts);
  const [searchQuery, setSearchQuery] = useState("");

  useEffect(() => {
    const down = (e: KeyboardEvent) => {
      if (e.key === "k" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        setOpen((open) => !open);
      }
    };
    
    document.addEventListener("keydown", down);
    return () => document.removeEventListener("keydown", down);
  }, []);

  const handleSearch = (query: string) => {
    setSearchQuery(query);
    const filtered = posts.filter(
      (post) =>
        post.title.toLowerCase().includes(query.toLowerCase()) ||
        post.description?.toLowerCase().includes(query.toLowerCase()) ||
        post.tags?.some(tag => tag.toLowerCase().includes(query.toLowerCase()))
    );
    setFilteredPosts(filtered);
  };

  const handleSelectPost = (post: BlogPost) => {
    setOpen(false);
    // Navigate to post or perform action
    window.location.href = `/blog/${post.slug}`;
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold">Blog Posts</h1>
        <Dialog open={open} onOpenChange={setOpen}>
          <DialogTrigger asChild>
            <button className="flex items-center space-x-2 px-4 py-2 bg-gray-100 rounded-lg hover:bg-gray-200 transition">
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
              <span>Search posts...</span>
              <kbd className="pointer-events-none inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground opacity-100">
                <span className="text-xs">⌘</span>K
              </kbd>
            </button>
          </DialogTrigger>
          <DialogContent className="p-0">
            <Command className="rounded-lg border shadow-md">
              <CommandInput 
                placeholder="Search blog posts..." 
                onValueChange={handleSearch}
              />
              <CommandList>
                <CommandEmpty>No posts found.</CommandEmpty>
                <CommandGroup heading="Blog Posts">
                  {posts
                    .filter(post => 
                      post.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                      post.description?.toLowerCase().includes(searchQuery.toLowerCase())
                    )
                    .slice(0, 10)
                    .map((post) => (
                      <CommandItem
                        key={post.slug}
                        onSelect={() => handleSelectPost(post)}
                        className="cursor-pointer"
                      >
                        <div className="flex flex-col">
                          <span className="font-medium">{post.title}</span>
                          <span className="text-sm text-gray-500 truncate">
                            {post.description}
                          </span>
                        </div>
                      </CommandItem>
                    ))}
                </CommandGroup>
              </CommandList>
            </Command>
          </DialogContent>
        </Dialog>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {filteredPosts.map((post) => (
          <BlogCard key={post.slug} post={post} />
        ))}
      </div>
      
      {filteredPosts.length === 0 && searchQuery && (
        <div className="text-center py-12">
          <p className="text-gray-500">No posts found for "{searchQuery}"</p>
          <button 
            onClick={() => handleSearch("")}
            className="mt-2 text-blue-600 hover:text-blue-800"
          >
            Clear search
          </button>
        </div>
      )}
    </div>
  );
};

export default CommandSearch;
```

##### How It Works

This component uses shadcn/ui's Command component to create a powerful search interface with keyboard shortcuts. Pressing Cmd+K (or Ctrl+K) opens a search dialog where users can quickly find posts by title, description, or tags. The search filters posts in real-time and displays results in a clean, accessible format.

##### Customization Options

- **Keyboard shortcuts**: Modify the key combination or add additional shortcuts
- **Search fields**: Include/exclude different post properties in search
- **Result limit**: Adjust the maximum number of search results shown
- **Highlighting**: Add text highlighting for search matches
- **Categories**: Group search results by post categories

#### Example #2: Search with Debounce

```tsx
import React, { useState, useEffect, useMemo } from "react";
import { BlogPost } from "@/types/blog";
import BlogCard from "@/components/BlogCard";

interface DebouncedSearchProps {
  posts: BlogPost[];
}

const useDebounce = (value: string, delay: number): string => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

const DebouncedSearch: React.FC<DebouncedSearchProps> = ({ posts }) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [isSearching, setIsSearching] = useState(false);
  const debouncedSearchTerm = useDebounce(searchTerm, 300);

  const filteredPosts = useMemo(() => {
    if (!debouncedSearchTerm.trim()) return posts;
    
    setIsSearching(true);
    
    const filtered = posts.filter((post) => {
      const searchLower = debouncedSearchTerm.toLowerCase();
      return (
        post.title.toLowerCase().includes(searchLower) ||
        post.description?.toLowerCase().includes(searchLower) ||
        post.author?.toLowerCase().includes(searchLower) ||
        post.tags?.some(tag => tag.toLowerCase().includes(searchLower)) ||
        post.category?.toLowerCase().includes(searchLower)
      );
    });
    
    setTimeout(() => setIsSearching(false), 100);
    return filtered;
  }, [debouncedSearchTerm, posts]);

  const highlightText = (text: string, highlight: string) => {
    if (!highlight.trim()) return text;
    
    const regex = new RegExp(`(${highlight})`, 'gi');
    const parts = text.split(regex);
    
    return parts.map((part, index) =>
      regex.test(part) ? (
        <mark key={index} className="bg-yellow-200 px-1 rounded">
          {part}
        </mark>
      ) : (
        part
      )
    );
  };

  const clearSearch = () => {
    setSearchTerm("");
  };

  return (
    <div className="space-y-6">
      <div className="relative max-w-md mx-auto">
        <div className="relative">
          <input
            type="text"
            placeholder="Search blog posts..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full pl-10 pr-10 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
          {searchTerm && (
            <button
              onClick={clearSearch}
              className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
        </div>
        
        {isSearching && (
          <div className="absolute top-full left-1/2 transform -translate-x-1/2 mt-2">
            <div className="flex items-center space-x-2 text-sm text-gray-500">
              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-500"></div>
              <span>Searching...</span>
            </div>
          </div>
        )}
      </div>

      <div className="text-center">
        <p className="text-gray-600">
          {searchTerm ? (
            <>
              Found {filteredPosts.length} post{filteredPosts.length !== 1 ? 's' : ''} 
              {' '}for "{highlightText(searchTerm, searchTerm)}"
            </>
          ) : (
            `Showing all ${posts.length} posts`
          )}
        </p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {filteredPosts.map((post) => (
          <BlogCard 
            key={post.slug} 
            post={{
              ...post,
              title: highlightText(post.title, debouncedSearchTerm),
              description: post.description ? highlightText(post.description, debouncedSearchTerm) : undefined
            }} 
          />
        ))}
      </div>

      {filteredPosts.length === 0 && searchTerm && (
        <div className="text-center py-12">
          <div className="max-w-md mx-auto">
            <svg className="w-16 h-16 text-gray-300 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <h3 className="text-lg font-medium text-gray-900 mb-2">No posts found</h3>
            <p className="text-gray-500 mb-4">
              Try adjusting your search terms or browse all posts below.
            </p>
            <button 
              onClick={clearSearch}
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition"
            >
              Show all posts
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default DebouncedSearch;
```

##### How It Works

This search component implements debouncing to prevent excessive API calls or filtering operations while the user is typing. It waits 300ms after the user stops typing before performing the search. The component also includes text highlighting to show search matches, loading states, and a comprehensive empty state with suggestions.

##### Customization Options

- **Debounce delay**: Adjust the wait time before searching (default: 300ms)
- **Search fields**: Customize which post properties to include in search
- **Highlighting**: Modify the highlighting style and behavior
- **Loading indicators**: Customize the search loading state
- **Empty states**: Personalize the no-results message and actions

<BackToTop />

#### Example #3: Simple Search Bar

```tsx
import React, { useState } from "react";
import { BlogPost } from "@/types/blog";
import BlogCard from "@/components/BlogCard";

interface SimpleSearchProps {
  posts: BlogPost[];
}

const SimpleSearch: React.FC<SimpleSearchProps> = ({ posts }) => {
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState<"date" | "title" | "relevance">("date");

  const filteredAndSortedPosts = React.useMemo(() => {
    let filtered = posts;

    // Filter posts based on search query
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = posts.filter((post) =>
        post.title.toLowerCase().includes(query) ||
        post.description?.toLowerCase().includes(query) ||
        post.author?.toLowerCase().includes(query) ||
        post.tags?.some(tag => tag.toLowerCase().includes(query))
      );
    }

    // Sort posts
    const sorted = [...filtered].sort((a, b) => {
      switch (sortBy) {
        case "title":
          return a.title.localeCompare(b.title);
        case "date":
          return new Date(b.date || 0).getTime() - new Date(a.date || 0).getTime();
        case "relevance":
          if (!searchQuery.trim()) return 0;
          const aRelevance = calculateRelevance(a, searchQuery);
          const bRelevance = calculateRelevance(b, searchQuery);
          return bRelevance - aRelevance;
        default:
          return 0;
      }
    });

    return sorted;
  }, [posts, searchQuery, sortBy]);

  const calculateRelevance = (post: BlogPost, query: string): number => {
    const queryLower = query.toLowerCase();
    let score = 0;
    
    // Title matches get higher score
    if (post.title.toLowerCase().includes(queryLower)) {
      score += 10;
      if (post.title.toLowerCase().startsWith(queryLower)) {
        score += 5;
      }
    }
    
    // Description matches
    if (post.description?.toLowerCase().includes(queryLower)) {
      score += 5;
    }
    
    // Tag matches
    post.tags?.forEach(tag => {
      if (tag.toLowerCase().includes(queryLower)) {
        score += 3;
      }
    });
    
    // Author matches
    if (post.author?.toLowerCase().includes(queryLower)) {
      score += 2;
    }
    
    return score;
  };

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };

  const handleSortChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSortBy(e.target.value as "date" | "title" | "relevance");
  };

  const clearSearch = () => {
    setSearchQuery("");
    setSortBy("date");
  };

  return (
    <div className="space-y-6">
      {/* Search and Filter Bar */}
      <div className="flex flex-col sm:flex-row gap-4 items-center justify-between">
        <div className="relative flex-1 max-w-md">
          <input
            type="text"
            placeholder="Search posts by title, description, author, or tags..."
            value={searchQuery}
            onChange={handleSearchChange}
            className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
        </div>

        <div className="flex items-center space-x-4">
          <div className="flex items-center space-x-2">
            <label htmlFor="sort" className="text-sm font-medium text-gray-700">
              Sort by:
            </label>
            <select
              id="sort"
              value={sortBy}
              onChange={handleSortChange}
              className="border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            >
              <option value="date">Date (Newest)</option>
              <option value="title">Title (A-Z)</option>
              {searchQuery && <option value="relevance">Relevance</option>}
            </select>
          </div>

          {searchQuery && (
            <button
              onClick={clearSearch}
              className="text-sm text-gray-500 hover:text-gray-700 underline"
            >
              Clear
            </button>
          )}
        </div>
      </div>

      {/* Results Summary */}
      <div className="flex items-center justify-between border-b border-gray-200 pb-4">
        <p className="text-gray-600">
          {searchQuery ? (
            <>
              {filteredAndSortedPosts.length} result{filteredAndSortedPosts.length !== 1 ? 's' : ''} for "{searchQuery}"
            </>
          ) : (
            `${posts.length} total posts`
          )}
        </p>
        
        {filteredAndSortedPosts.length > 0 && (
          <p className="text-sm text-gray-500">
            Sorted by {sortBy === "date" ? "newest first" : sortBy === "title" ? "alphabetical" : "relevance"}
          </p>
        )}
      </div>

      {/* Posts Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {filteredAndSortedPosts.map((post) => (
          <BlogCard key={post.slug} post={post} />
        ))}
      </div>

      {/* Empty State */}
      {filteredAndSortedPosts.length === 0 && searchQuery && (
        <div className="text-center py-12">
          <div className="max-w-md mx-auto">
            <svg className="w-12 h-12 text-gray-300 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1} d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6-4h6m2 5.291A7.962 7.962 0 0112 15c-2.34 0-4.5-1.01-6-2.709M7 21l1.5-1.5M21 7l-1.5 1.5" />
            </svg>
            <h3 className="text-lg font-medium text-gray-900 mb-2">No posts found</h3>
            <p className="text-gray-500 mb-4">
              Try different keywords or browse all posts.
            </p>
            <div className="flex flex-col sm:flex-row gap-3 justify-center">
              <button 
                onClick={clearSearch}
                className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition"
              >
                Show all posts
              </button>
              <button 
                onClick={() => setSearchQuery("")}
                className="border border-gray-300 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-50 transition"
              >
                Clear search
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SimpleSearch;
```

##### How It Works

This simple search component provides real-time filtering with sorting capabilities. It searches across multiple post fields and includes a relevance scoring system that prioritizes title matches. The component maintains clean state management and provides clear feedback about search results and sorting options.

##### Customization Options

- **Search fields**: Add or remove fields from the search functionality
- **Sorting options**: Include additional sorting criteria like popularity or category
- **Relevance scoring**: Adjust the scoring algorithm for better search results
- **UI styling**: Customize the search bar, filters, and result display
- **Performance**: Add virtualization for large datasets

<BackToTop />


### Categories and Tags

You can categorize your blog posts and allow users to filter posts by categories or tags. This can be done by adding a category field to each post and creating a filter component that updates the displayed posts based on the selected category or tag.

#### Example #1: Using Badges

```tsx
import React, { useState } from "react";
import { BlogPost } from "@/types/blog";
import BlogCard from "@/components/BlogCard";

interface CategoryFilterProps {
  posts: BlogPost[];
}

const CategoryFilter: React.FC<CategoryFilterProps> = ({ posts }) => {
  const [selectedCategory, setSelectedCategory] = useState<string>("all");
  const [selectedTags, setSelectedTags] = useState<string[]>([]);

  // Extract unique categories and tags from posts
  const categories = React.useMemo(() => {
    const cats = posts.reduce((acc, post) => {
      if (post.category && !acc.includes(post.category)) {
        acc.push(post.category);
      }
      return acc;
    }, [] as string[]);
    return ["all", ...cats.sort()];
  }, [posts]);

  const allTags = React.useMemo(() => {
    const tags = posts.reduce((acc, post) => {
      if (post.tags) {
        post.tags.forEach(tag => {
          if (!acc.includes(tag)) {
            acc.push(tag);
          }
        });
      }
      return acc;
    }, [] as string[]);
    return tags.sort();
  }, [posts]);

  // Filter posts based on selected category and tags
  const filteredPosts = React.useMemo(() => {
    return posts.filter(post => {
      const categoryMatch = selectedCategory === "all" || post.category === selectedCategory;
      const tagMatch = selectedTags.length === 0 || 
        (post.tags && selectedTags.every(tag => post.tags.includes(tag)));
      
      return categoryMatch && tagMatch;
    });
  }, [posts, selectedCategory, selectedTags]);

  const handleCategoryChange = (category: string) => {
    setSelectedCategory(category);
  };

  const handleTagToggle = (tag: string) => {
    setSelectedTags(prev => 
      prev.includes(tag)
        ? prev.filter(t => t !== tag)
        : [...prev, tag]
    );
  };

  const clearAllFilters = () => {
    setSelectedCategory("all");
    setSelectedTags([]);
  };

  const getCategoryPostCount = (category: string) => {
    if (category === "all") return posts.length;
    return posts.filter(post => post.category === category).length;
  };

  const getTagPostCount = (tag: string) => {
    return posts.filter(post => post.tags?.includes(tag)).length;
  };

  return (
    <div className="space-y-6">
      {/* Filter Section */}
      <div className="bg-gray-50 rounded-lg p-6">
        <div className="space-y-6">
          {/* Category Filter */}
          <div>
            <h3 className="text-lg font-semibold text-gray-900 mb-3">Categories</h3>
            <div className="flex flex-wrap gap-2">
              {categories.map(category => (
                <button
                  key={category}
                  onClick={() => handleCategoryChange(category)}
                  className={`inline-flex items-center px-3 py-1.5 rounded-full text-sm font-medium transition-colors ${
                    selectedCategory === category
                      ? "bg-blue-600 text-white"
                      : "bg-white text-gray-700 border border-gray-300 hover:bg-gray-100"
                  }`}
                >
                  {category === "all" ? "All" : category}
                  <span className="ml-2 bg-opacity-20 bg-white rounded-full px-2 py-0.5 text-xs">
                    {getCategoryPostCount(category)}
                  </span>
                </button>
              ))}
            </div>
          </div>

          {/* Tags Filter */}
          <div>
            <h3 className="text-lg font-semibold text-gray-900 mb-3">Tags</h3>
            <div className="flex flex-wrap gap-2 max-h-32 overflow-y-auto">
              {allTags.map(tag => (
                <button
                  key={tag}
                  onClick={() => handleTagToggle(tag)}
                  className={`inline-flex items-center px-3 py-1.5 rounded-full text-sm transition-colors ${
                    selectedTags.includes(tag)
                      ? "bg-green-600 text-white"
                      : "bg-white text-gray-700 border border-gray-300 hover:bg-gray-100"
                  }`}
                >
                  <span className="mr-2">#</span>
                  {tag}
                  <span className="ml-2 bg-opacity-20 bg-white rounded-full px-2 py-0.5 text-xs">
                    {getTagPostCount(tag)}
                  </span>
                </button>
              ))}
            </div>
          </div>

          {/* Active Filters and Clear */}
          {(selectedCategory !== "all" || selectedTags.length > 0) && (
            <div className="flex items-center justify-between border-t border-gray-200 pt-4">
              <div className="flex items-center space-x-2">
                <span className="text-sm font-medium text-gray-700">Active filters:</span>
                {selectedCategory !== "all" && (
                  <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                    Category: {selectedCategory}
                    <button
                      onClick={() => setSelectedCategory("all")}
                      className="ml-1.5 text-blue-600 hover:text-blue-800"
                    >
                      ×
                    </button>
                  </span>
                )}
                {selectedTags.map(tag => (
                  <span key={tag} className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                    #{tag}
                    <button
                      onClick={() => handleTagToggle(tag)}
                      className="ml-1.5 text-green-600 hover:text-green-800"
                    >
                      ×
                    </button>
                  </span>
                ))}
              </div>
              <button
                onClick={clearAllFilters}
                className="text-sm text-gray-500 hover:text-gray-700 underline"
              >
                Clear all
              </button>
            </div>
          )}
        </div>
      </div>

      {/* Results Summary */}
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold text-gray-900">
          {selectedCategory === "all" ? "All Posts" : selectedCategory}
        </h2>
        <p className="text-gray-600">
          {filteredPosts.length} post{filteredPosts.length !== 1 ? 's' : ''}
        </p>
      </div>

      {/* Posts Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {filteredPosts.map(post => (
          <div key={post.slug} className="space-y-2">
            <BlogCard post={post} />
            {/* Show post tags */}
            <div className="flex flex-wrap gap-1 px-2">
              {post.tags?.slice(0, 3).map(tag => (
                <span 
                  key={tag}
                  className="inline-block px-2 py-1 bg-gray-100 text-gray-600 text-xs rounded-full"
                >
                  #{tag}
                </span>
              ))}
              {post.tags && post.tags.length > 3 && (
                <span className="inline-block px-2 py-1 bg-gray-100 text-gray-600 text-xs rounded-full">
                  +{post.tags.length - 3} more
                </span>
              )}
            </div>
          </div>
        ))}
      </div>

      {/* Empty State */}
      {filteredPosts.length === 0 && (
        <div className="text-center py-12">
          <div className="max-w-md mx-auto">
            <svg className="w-12 h-12 text-gray-300 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
            </svg>
            <h3 className="text-lg font-medium text-gray-900 mb-2">No posts found</h3>
            <p className="text-gray-500 mb-4">
              No posts match your current filter selection.
            </p>
            <button 
              onClick={clearAllFilters}
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition"
            >
              Clear filters
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default CategoryFilter;
```

##### How It Works

This component creates an interactive filtering system using badge-style buttons for categories and tags. It dynamically extracts unique categories and tags from the posts array and displays them with post counts. Users can select multiple tags and one category, with real-time filtering and clear visual feedback about active filters.

##### Customization Options

- **Badge styling**: Customize colors, shapes, and hover effects for category and tag badges
- **Filter layout**: Organize filters in dropdown menus, sidebars, or collapsible sections
- **Post counts**: Show/hide the number of posts for each filter option
- **Multi-select**: Allow multiple category selection alongside tag filtering
- **Filter persistence**: Save filter state in URL parameters or local storage

<BackToTop />

### Featured Posts

You can highlight certain posts as featured posts. This can be done by adding a `featured` field to the post metadata and rendering these posts in a separate section at the top of the blog page.

#### Example #1: Featured Post Displayed at the Top

```tsx

```

##### How It Works

##### Customization Options

<BackToTop />

#### Example #2: Featured Posts Section

```tsx

```

##### How It Works

##### Customization Options

<BackToTop />

### Social Sharing

You can add social sharing buttons to each blog card, allowing users to easily share posts on social media platforms. This can be done by integrating with social media APIs or using third-party libraries that provide social sharing functionality.

#### Example #1: Using a Floating Action Button (FAB) for Social Sharing

```tsx

```

##### How It Works

##### Customization Options

<BackToTop />

#### Example #2: Using a Simple Share Button

```tsx

```

##### How It Works

##### Customization Options

<BackToTop />

#### Example #3: Using a Dropdown for Social Sharing

```tsx

```

##### How It Works

##### Customization Options

<BackToTop />
