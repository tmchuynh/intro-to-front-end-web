import BackToTop from "@/components/BackToTop";

# Contact Page

## Table of Contents

## About the Contact Page

The contact form is a crucial component of any website, allowing users to get in touch with the site owners or support team. In this section, we will create a simple contact form using the `shadcn/ui` library.

### Prerequisites

For this example, we will create a simple contact form with fields for the user's name, email, and message. We will also handle form submission and validation using `react-hook-form` and `zod`.

We will also need to install the necessary dependencies if they are not already installed:

```bash
npm install react-hook-form zod @hookform/resolvers
```

## Contact Form Components

- `Form`: The main component that wraps the form.
- `FormField`: The component that represents a single field in the form.
- `FormItem`: The component that contains the label and input for a form field.
- `FormLabel`: The label for a form field.
- `FormControl`: The component that wraps the input element.
- `FormMessage`: The component that displays validation messages for a form field.

## Understanding Zod: TypeScript-First Schema Validation

Zod is a powerful TypeScript-first schema validation library that provides runtime type safety, data validation, and type inference. It's particularly valuable in form handling because it ensures data integrity both at compile time and runtime.

### Why Choose Zod?

#### ‚úÖ Advantages of Zod

1. **TypeScript Integration**: Automatically infers TypeScript types from schemas
2. **Runtime Safety**: Validates data at runtime, catching errors that TypeScript can't
3. **Developer Experience**: Excellent error messages and IDE autocomplete
4. **Zero Dependencies**: Lightweight with no external dependencies
5. **Composable**: Build complex schemas from simple primitives
6. **Framework Agnostic**: Works with any JavaScript/TypeScript project

##### üîÑ **How Zod Works**

```typescript
import { z } from "zod";

// 1. Define a schema
const userSchema = z.object({
  name: z.string(),
  age: z.number(),
});

// 2. TypeScript type is automatically inferred
type User = z.infer<typeof userSchema>; // { name: string; age: number }

// 3. Validate data at runtime
const result = userSchema.parse({ name: "John", age: 30 }); // ‚úÖ Valid
const invalid = userSchema.parse({ name: "John", age: "30" }); // ‚ùå Throws ZodError
```

### Basic Zod Schema Creation

Let's start with a simple contact form schema and gradually build complexity:

#### **Level 1: Basic Schema**

```typescript
import { z } from "zod";

export const basicContactSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email address"),
  message: z.string().min(10, "Message must be at least 10 characters long"),
});

// Automatically inferred TypeScript type
type BasicContact = z.infer<typeof basicContactSchema>;
/*
{
  name: string;
  email: string;
  message: string;
}
*/
```

##### **Level 2: Enhanced Schema with Advanced Validation**

```typescript
export const enhancedContactSchema = z.object({
  // String validations
  name: z
    .string()
    .min(2, "Name must be at least 2 characters")
    .max(50, "Name must be less than 50 characters")
    .regex(/^[a-zA-Z\s]+$/, "Name can only contain letters and spaces"),

  // Email with custom validation
  email: z
    .string()
    .email("Please enter a valid email address")
    .toLowerCase() // Transform to lowercase
    .refine(
      (email) => !email.includes("+"),
      "Email addresses with '+' are not allowed"
    ),

  // Optional fields with default values
  phone: z
    .string()
    .optional()
    .or(z.literal("")) // Allow empty string
    .transform((val) => (val === "" ? undefined : val)),

  // Enum for predefined values
  subject: z.enum(["general", "support", "billing", "partnership", "other"], {
    errorMap: () => ({ message: "Please select a valid subject" }),
  }),

  // Number validation
  urgency: z
    .number()
    .min(1, "Urgency must be at least 1")
    .max(5, "Urgency cannot exceed 5")
    .int("Urgency must be a whole number"),

  // Boolean with default
  newsletter: z.boolean().default(false),

  // Array validation
  interests: z
    .array(z.string())
    .min(1, "Please select at least one interest")
    .max(5, "Please select no more than 5 interests"),

  // Complex string validation
  message: z
    .string()
    .min(10, "Message must be at least 10 characters")
    .max(1000, "Message must be less than 1000 characters")
    .refine(
      (msg) => msg.trim().split(/\s+/).length >= 3,
      "Message must contain at least 3 words"
    ),
});

type EnhancedContact = z.infer<typeof enhancedContactSchema>;
```

##### **Level 3: Professional Schema with Complex Validations**

```typescript
export const professionalContactSchema = z
  .object({
    // Personal Information
    firstName: z
      .string()
      .min(1, "First name is required")
      .max(30, "First name too long")
      .transform((val) => val.trim())
      .refine((val) => val.length > 0, "First name cannot be empty"),

    lastName: z
      .string()
      .min(1, "Last name is required")
      .max(30, "Last name too long")
      .transform((val) => val.trim()),

    // Contact Information with complex validation
    email: z
      .string()
      .email("Invalid email format")
      .toLowerCase()
      .refine(async (email) => {
        // Simulate checking if email is already registered
        const existingUser = await checkEmailExists(email);
        return !existingUser;
      }, "This email is already registered"),

    phone: z
      .string()
      .regex(/^[\+]?[1-9][\d]{0,15}$/, "Please enter a valid phone number")
      .transform((phone) => phone.replace(/\D/g, "")) // Remove non-digits
      .optional(),

    // Business Information
    company: z.string().max(100, "Company name too long").optional(),

    position: z.string().max(50, "Position title too long").optional(),

    // Message with rich validation
    subject: z
      .string()
      .min(5, "Subject must be at least 5 characters")
      .max(100, "Subject must be less than 100 characters"),

    message: z
      .string()
      .min(20, "Please provide a detailed message (at least 20 characters)")
      .max(2000, "Message is too long (maximum 2000 characters)")
      .refine((msg) => {
        const wordCount = msg.trim().split(/\s+/).length;
        return wordCount >= 5;
      }, "Message must contain at least 5 words")
      .refine((msg) => {
        // Check for spam patterns
        const spamWords = ["viagra", "casino", "lottery", "winner"];
        const lowerMsg = msg.toLowerCase();
        return !spamWords.some((word) => lowerMsg.includes(word));
      }, "Message contains prohibited content"),

    // File attachments
    attachments: z
      .array(
        z.object({
          name: z.string(),
          size: z
            .number()
            .max(5 * 1024 * 1024, "File size must be less than 5MB"),
          type: z
            .string()
            .refine(
              (type) =>
                [
                  "image/jpeg",
                  "image/png",
                  "application/pdf",
                  "text/plain",
                ].includes(type),
              "Only JPEG, PNG, PDF, and TXT files are allowed"
            ),
        })
      )
      .max(3, "Maximum 3 files allowed")
      .optional(),

    // Privacy and consent
    consent: z.object({
      privacyPolicy: z
        .boolean()
        .refine((val) => val === true, "You must accept the privacy policy"),
      newsletter: z.boolean().default(false),
      dataProcessing: z
        .boolean()
        .refine((val) => val === true, "You must consent to data processing"),
    }),

    // Metadata
    source: z
      .enum(["website", "referral", "social_media", "advertisement"])
      .optional(),

    // Anti-spam measures
    honeypot: z.string().max(0, "Bot detected").optional(), // Should always be empty

    // Timestamp
    submittedAt: z.date().default(() => new Date()),
  })
  // Schema-level validation
  .refine(
    (data) => {
      // Cross-field validation: if company is provided, position should be too
      if (data.company && !data.position) {
        return false;
      }
      return true;
    },
    {
      message: "Position is required when company is provided",
      path: ["position"], // Specify which field should show the error
    }
  )
  .refine(
    (data) => {
      // Business hours submission check
      const hour = data.submittedAt.getHours();
      if (
        data.subject.toLowerCase().includes("urgent") &&
        (hour < 9 || hour > 17)
      ) {
        return false;
      }
      return true;
    },
    {
      message:
        "Urgent requests can only be submitted during business hours (9 AM - 5 PM)",
      path: ["subject"],
    }
  );

type ProfessionalContact = z.infer<typeof professionalContactSchema>;
```

### Advanced Zod Techniques

#### **Conditional Validation**

```typescript
const conditionalSchema = z
  .object({
    userType: z.enum(["individual", "business"]),
    name: z.string().min(1),
    email: z.string().email(),

    // Conditional fields based on userType
    businessInfo: z
      .object({
        companyName: z.string().min(1),
        taxId: z.string().min(1),
        employees: z.number().min(1),
      })
      .optional(),

    personalInfo: z
      .object({
        dateOfBirth: z.date(),
        nationality: z.string(),
      })
      .optional(),
  })
  .refine(
    (data) => {
      if (data.userType === "business") {
        return data.businessInfo !== undefined;
      }
      if (data.userType === "individual") {
        return data.personalInfo !== undefined;
      }
      return true;
    },
    {
      message: "Required information is missing for the selected user type",
      path: ["userType"],
    }
  );
```

##### **Custom Validation Functions**

```typescript
// Reusable custom validators
const createPasswordValidator = (minLength: number = 8) => {
  return z
    .string()
    .min(minLength, `Password must be at least ${minLength} characters`)
    .refine(
      (password) => /[A-Z]/.test(password),
      "Password must contain at least one uppercase letter"
    )
    .refine(
      (password) => /[a-z]/.test(password),
      "Password must contain at least one lowercase letter"
    )
    .refine(
      (password) => /\d/.test(password),
      "Password must contain at least one number"
    )
    .refine(
      (password) => /[!@#$%^&*(),.?":{}|<>]/.test(password),
      "Password must contain at least one special character"
    );
};

const createDateRangeValidator = (startDate: Date, endDate: Date) => {
  return z
    .date()
    .min(startDate, `Date must be after ${startDate.toLocaleDateString()}`)
    .max(endDate, `Date must be before ${endDate.toLocaleDateString()}`);
};

// Usage
const userRegistrationSchema = z
  .object({
    email: z.string().email(),
    password: createPasswordValidator(12), // Minimum 12 characters
    confirmPassword: z.string(),
    birthDate: createDateRangeValidator(
      new Date("1900-01-01"),
      new Date(Date.now() - 18 * 365 * 24 * 60 * 60 * 1000) // Must be 18+ years old
    ),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });
```

##### **Schema Composition and Reusability**

```typescript
// Base schemas for reusability
const basePersonSchema = z.object({
  firstName: z.string().min(1, "First name is required"),
  lastName: z.string().min(1, "Last name is required"),
  email: z.string().email("Invalid email address"),
});

const addressSchema = z.object({
  street: z.string().min(1, "Street address is required"),
  city: z.string().min(1, "City is required"),
  state: z
    .string()
    .min(2, "State is required")
    .max(2, "State code must be 2 characters"),
  zipCode: z.string().regex(/^\d{5}(-\d{4})?$/, "Invalid ZIP code format"),
  country: z.string().default("US"),
});

const contactPreferencesSchema = z.object({
  preferredContact: z.enum(["email", "phone", "mail"]),
  newsletter: z.boolean().default(false),
  promotions: z.boolean().default(false),
  frequency: z.enum(["daily", "weekly", "monthly"]).default("weekly"),
});

// Compose complex schemas from base schemas
const customerSchema = basePersonSchema.extend({
  phone: z.string().optional(),
  dateOfBirth: z.date().optional(),
  address: addressSchema,
  preferences: contactPreferencesSchema,

  // Customer-specific fields
  customerId: z.string().uuid(),
  membershipLevel: z
    .enum(["bronze", "silver", "gold", "platinum"])
    .default("bronze"),
  totalPurchases: z.number().min(0).default(0),
});

const employeeSchema = basePersonSchema.extend({
  employeeId: z.string(),
  department: z.string(),
  position: z.string(),
  salary: z.number().positive(),
  startDate: z.date(),
  address: addressSchema.optional(), // Optional for employees
});

// Merge multiple schemas
const fullContactSchema = basePersonSchema
  .merge(addressSchema.partial()) // Make address fields optional
  .merge(contactPreferencesSchema.partial())
  .extend({
    message: z.string().min(10, "Message must be at least 10 characters"),
    urgency: z.enum(["low", "medium", "high"]).default("medium"),
  });
```

### Error Handling and User Experience

#### **Custom Error Messages**

```typescript
const userFriendlySchema = z.object({
  username: z
    .string()
    .min(3, "Username is too short - needs at least 3 characters")
    .max(20, "Username is too long - maximum 20 characters allowed")
    .regex(
      /^[a-zA-Z0-9_]+$/,
      "Username can only contain letters, numbers, and underscores"
    ),

  age: z
    .number({
      required_error: "Please tell us your age",
      invalid_type_error: "Age must be a number",
    })
    .min(13, "You must be at least 13 years old to register")
    .max(120, "Please enter a valid age"),

  email: z
    .string({
      required_error: "Email address is required",
    })
    .email("Please enter a valid email address")
    .refine(
      (email) => !email.endsWith(".temp"),
      "Temporary email addresses are not allowed"
    ),
});
```

##### **Parsing VS Validation**

```typescript
// Different ways to validate data with Zod

// 1. parse() - Throws on validation failure
try {
  const validData = schema.parse(formData);
  console.log("Data is valid:", validData);
} catch (error) {
  if (error instanceof z.ZodError) {
    console.log("Validation errors:", error.errors);
  }
}

// 2. safeParse() - Returns result object (recommended for forms)
const result = schema.safeParse(formData);
if (result.success) {
  console.log("Valid data:", result.data);
} else {
  console.log("Validation errors:", result.error.errors);

  // Format errors for display
  const fieldErrors = result.error.errors.reduce((acc, error) => {
    const field = error.path.join(".");
    acc[field] = error.message;
    return acc;
  }, {});
}

// 3. parseAsync() - For async validation
const asyncResult = await schema.parseAsync(formData);

// 4. safeParseAsync() - Safe async validation
const safeAsyncResult = await schema.safeParseAsync(formData);
```

### Integration with React Hook Form

#### **Complete Integration Example**

```typescript
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";

// @collapse
const advancedFormSchema = z.object({
  profile: z.object({
    firstName: z.string().min(1, "First name is required"),
    lastName: z.string().min(1, "Last name is required"),
    avatar: z.string().url("Please provide a valid image URL").optional(),
  }),

  contact: z.object({
    email: z.string().email("Invalid email address"),
    phone: z.string().regex(/^\+?[\d\s-()]+$/, "Invalid phone number").optional(),
    preferredContactTime: z.enum(['morning', 'afternoon', 'evening']),
  }),

  preferences: z.object({
    theme: z.enum(['light', 'dark', 'system']).default('system'),
    notifications: z.object({
      email: z.boolean().default(true),
      push: z.boolean().default(false),
      sms: z.boolean().default(false),
    }),
    privacy: z.object({
      profileVisible: z.boolean().default(true),
      dataSharing: z.boolean().default(false),
    }),
  }),

  // Nested array validation
  interests: z.array(
    z.object({
      category: z.string(),
      level: z.enum(['beginner', 'intermediate', 'advanced']),
      yearsExperience: z.number().min(0).max(50),
    })
  ).min(1, "Please select at least one interest"),
});

type AdvancedFormData = z.infer<typeof advancedFormSchema>;

// @collapse
export function AdvancedForm() {
  const form = useForm<AdvancedFormData>({
    resolver: zodResolver(advancedFormSchema),
    defaultValues: {
      profile: {
        firstName: "",
        lastName: "",
      },
      contact: {
        email: "",
        preferredContactTime: "morning",
      },
      preferences: {
        theme: "system",
        notifications: {
          email: true,
          push: false,
          sms: false,
        },
        privacy: {
          profileVisible: true,
          dataSharing: false,
        },
      },
      interests: [],
    },
  });

  const onSubmit = (data: AdvancedFormData) => {
    console.log("Form submitted with valid data:", data);
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Form fields here */}
    </form>
  );
}
```

### Performance Optimization

#### **Schema Caching and Reuse**

```typescript
// Cache schemas to avoid recreation
const schemaCache = new Map();

const getContactSchema = (memoKey: string) => {
  if (!schemaCache.has(memoKey)) {
    const schema = z.object({
      name: z.string().min(1),
      email: z.string().email(),
      message: z.string().min(10),
    });
    schemaCache.set(memoKey, schema);
  }
  return schemaCache.get(memoKey);
};

// Use useMemo in React components
const ContactForm = () => {
  const schema = useMemo(() => getContactSchema("basic-contact"), []);

  const form = useForm({
    resolver: zodResolver(schema),
  });

  // ... rest of component
};
```

##### **Partial Validation for Step Forms**

```typescript
const fullSchema = z.object({
  step1: z.object({
    name: z.string().min(1),
    email: z.string().email(),
  }),
  step2: z.object({
    phone: z.string().optional(),
    company: z.string().optional(),
  }),
  step3: z.object({
    message: z.string().min(10),
    urgency: z.enum(["low", "medium", "high"]),
  }),
});

// Validate individual steps
const validateStep = (step: number, data: any) => {
  switch (step) {
    case 1:
      return fullSchema.shape.step1.safeParse(data);
    case 2:
      return fullSchema.shape.step2.safeParse(data);
    case 3:
      return fullSchema.shape.step3.safeParse(data);
    default:
      return { success: false, error: new Error("Invalid step") };
  }
};
```

<BackToTop />

## Creating a Form Schema with Zod

Now let's implement a practical contact form schema using the concepts we've learned:

```typescript
import { z } from "zod";

export const contactFormSchema = z.object({
  name: z
    .string()
    .min(1, "Name is required")
    .max(50, "Name must be less than 50 characters")
    .transform((val) => val.trim()),

  email: z
    .string()
    .min(1, "Email is required")
    .email("Invalid email address")
    .toLowerCase(),

  message: z
    .string()
    .min(10, "Message must be at least 10 characters long")
    .max(1000, "Message must be less than 1000 characters")
    .transform((val) => val.trim()),
});

// Export the inferred type for TypeScript
export type ContactFormData = z.infer<typeof contactFormSchema>;
```

### How This Works

This schema demonstrates key Zod concepts:

1. **Type Safety**: Automatic TypeScript type inference
2. **Validation Chain**: Multiple validation rules per field
3. **Transform**: Data cleaning (trim whitespace, lowercase email)
4. **Custom Messages**: User-friendly error messages
5. **Runtime Validation**: Ensures data integrity at submission

## The Contact Form Component

First, we will create a new file for our contact form component. This component will use the `shadcn/ui` components to build the form UI.

```tsx
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { contactFormSchema } from "@/lib/validation/contactFormSchema";
import { useState } from "react";
import { toast } from "@/components/ui/use-toast";

export default function ContactForm() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const form = useForm({
    resolver: zodResolver(contactFormSchema),
    defaultValues: {
      name: "",
      email: "",
      message: "",
    },
  });

  const onSubmit = async (data) => {
    setIsSubmitting(true);
    try {
      // Simulate form submission
      await new Promise((resolve) => setTimeout(resolve, 2000));
      toast({ title: "Form submitted successfully!" });
      form.reset();
    } catch (error) {
      toast({ title: "Failed to submit form", variant: "destructive" });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <input {...field} className="input" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <input {...field} type="email" className="input" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="message"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Message</FormLabel>
              <FormControl>
                <textarea {...field} className="textarea" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit" disabled={isSubmitting}>
          {isSubmitting ? "Submitting..." : "Submit"}
        </Button>
      </form>
    </Form>
  );
}
```

<BackToTop />

## Customizing the Contact Form (and Examples)

You can customize the contact form by adding additional fields, changing the layout, or modifying the styles. Here are some examples of how you can extend the contact form:

- Adding a Loading Spinner During Submission
- Implementing Accessibility Features (e.g., ARIA attributes)
- Adding a Subject Field and/or a Phone Number Field and/or a File Upload Field
- Adding a Rich Text Editor for the Message Field
- Customizing the Submit Button
- Implementing Client-Side Validation with `react-hook-form`
- Using a Third-Party Library (e.g., Formik) or Custom Hook for Form Handling and State Management (e.g., Redux, Zustand)
- Integrating with a Third-Party Form Service (e.g., Formspree, Google Forms)
- Adding a Captcha for Spam Protection
- Implementing Error Handling for Form Submission
- Adding a redirect to a Thank You Page After Successful Submission
- Adding a Confirmation Email to the User
- Adding a Reset Button

Let's go over a few of these examples:

### Adding a Loading Spinner during Submission

You can add a loading spinner to indicate that the form is being submitted. This can be done by using a state variable to track the submission status and conditionally rendering a spinner component.

```tsx
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Loader2 } from "lucide-react";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useState } from "react";
import { toast } from "@/components/ui/use-toast";

const contactFormSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email address"),
  message: z.string().min(10, "Message must be at least 10 characters long"),
});

export default function ContactFormWithSpinner() {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm({
    resolver: zodResolver(contactFormSchema),
    defaultValues: {
      name: "",
      email: "",
      message: "",
    },
  });

  // @collapse
  const onSubmit = async (data) => {
    setIsSubmitting(true);
    try {
      // Simulate API call
      await new Promise((resolve) => setTimeout(resolve, 3000));

      // Simulate success/error randomly for demo
      if (Math.random() > 0.3) {
        toast({
          title: "Success!",
          description: "Your message has been sent successfully.",
        });
        form.reset();
      } else {
        throw new Error("Submission failed");
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to send message. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="max-w-md mx-auto p-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-bold mb-6">Contact Us</h2>

      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Full Name</FormLabel>
                <FormControl>
                  <Input
                    {...field}
                    placeholder="Enter your full name"
                    disabled={isSubmitting}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="email"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Email Address</FormLabel>
                <FormControl>
                  <Input
                    {...field}
                    type="email"
                    placeholder="Enter your email"
                    disabled={isSubmitting}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="message"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Message</FormLabel>
                <FormControl>
                  <Textarea
                    {...field}
                    placeholder="Enter your message"
                    rows={4}
                    disabled={isSubmitting}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? (
              <>
                <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent mr-2" />
                Sending Message...
              </>
            ) : (
              "Send Message"
            )}
          </Button>
        </form>
      </Form>

      {isSubmitting && (
        <div className="mt-4 text-center">
          <div className="inline-flex items-center px-4 py-2 bg-blue-50 rounded-lg">
            <Loader2 className="mr-2 h-4 w-4 animate-spin text-blue-600" />
            <span className="text-sm text-blue-600">
              Processing your request...
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
```

#### How It Works

The loading spinner implementation uses several key concepts:

1. **State Management**: The `isSubmitting` state variable tracks whether the form is currently being processed.

2. **Conditional Rendering**: The button content changes based on the `isSubmitting` state:
   - When `false`: Shows "Send Message"
   - When `true`: Shows a spinning loader icon with "Sending Message..."

3. **Form Disabling**: All form inputs are disabled during submission using the `disabled={isSubmitting}` prop, preventing user interaction while processing.

4. **Visual Feedback**: Multiple loading indicators provide clear feedback:
   - Button spinner with text change
   - Additional loading message below the form
   - Disabled form inputs with visual styling

5. **Error Handling**: The form handles both success and error states, updating the UI accordingly and resetting the loading state in the `finally` block.

##### Customization Options

You can customize the loading experience in several ways:

###### Spinner Variations

```tsx
// Different spinner icons
import { Loader, RotateCw, Circle } from "lucide-react";

// Custom spinner with different animations
<RotateCw className="mr-2 h-4 w-4 animate-spin" />
<Circle className="mr-2 h-4 w-4 animate-pulse" />
```

###### Loading Text Customization

```tsx
const loadingMessages = [
  "Sending your message...",
  "Processing request...",
  "Almost done...",
];

// Cycle through messages during long operations
const [messageIndex, setMessageIndex] = useState(0);
```

###### Progress Indicators

```tsx
import { Progress } from "@/components/ui/progress";

// Add progress bar for longer operations
const [progress, setProgress] = useState(0);

// Simulate progress during submission
useEffect(() => {
  if (isSubmitting) {
    const timer = setInterval(() => {
      setProgress((prev) => Math.min(prev + 10, 90));
    }, 300);
    return () => clearInterval(timer);
  }
}, [isSubmitting]);
```

###### Custom Loading Overlay

```tsx
{
  isSubmitting && (
    <div className="absolute inset-0 bg-white/80 flex items-center justify-center rounded-lg">
      <div className="flex flex-col items-center">
        <Loader2 className="h-8 w-8 animate-spin text-blue-600" />
        <p className="mt-2 text-sm text-blue-600">Sending your message...</p>
      </div>
    </div>
  );
}
```

<BackToTop />

### Adding a Subject Field, Phone Number Field, and Customizing the Submit Button

You can add additional fields to the contact form, such as a subject field and a phone number field. You can also customize the submit button to change its appearance or behavior.

```tsx
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Send, Phone, Mail, User, MessageSquare } from "lucide-react";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useState } from "react";
import { toast } from "@/components/ui/use-toast";

const enhancedContactFormSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email address"),
  phone: z.string().min(10, "Please enter a valid phone number").optional(),
  subject: z.string().min(1, "Please select a subject"),
  priority: z.enum(["low", "medium", "high"]),
  message: z.string().min(10, "Message must be at least 10 characters long"),
});

export default function EnhancedContactForm() {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm({
    resolver: zodResolver(enhancedContactFormSchema),
    defaultValues: {
      name: "",
      email: "",
      phone: "",
      subject: "",
      priority: "medium",
      message: "",
    },
  });

  // @collapse
  const onSubmit = async (data) => {
    setIsSubmitting(true);
    try {
      // Simulate API call
      await new Promise((resolve) => setTimeout(resolve, 2000));

      toast({
        title: "Message Sent Successfully!",
        description: `We'll respond to your ${data.priority} priority message within 24 hours.`,
      });
      form.reset();
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to send message. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const subjectOptions = [
    "General Inquiry",
    "Technical Support",
    "Billing Question",
    "Partnership Opportunity",
    "Bug Report",
    "Feature Request",
    "Other",
  ];

  return (
    <div className="max-w-2xl mx-auto p-6 bg-white rounded-lg shadow-lg">
      <div className="text-center mb-8">
        <h2 className="text-3xl font-bold text-gray-800">Get In Touch</h2>
        <p className="text-gray-600 mt-2">
          We'd love to hear from you. Send us a message!
        </p>
      </div>

      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Full Name</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      placeholder="Enter your full name"
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email Address</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      type="email"
                      placeholder="Enter your email"
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormField
              control={form.control}
              name="phone"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Phone Number (Optional)</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      type="tel"
                      placeholder="+1 (555) 123-4567"
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="priority"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Priority Level</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger className="transition-all duration-200 focus:ring-2 focus:ring-blue-500">
                        <SelectValue placeholder="Select priority" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="low">üü¢ Low Priority</SelectItem>
                      <SelectItem value="medium">üü° Medium Priority</SelectItem>
                      <SelectItem value="high">üî¥ High Priority</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
          </div>

          <FormField
            control={form.control}
            name="subject"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Subject</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger className="transition-all duration-200 focus:ring-2 focus:ring-blue-500">
                      <SelectValue placeholder="What is this regarding?" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {subjectOptions.map((subject) => (
                      <SelectItem key={subject} value={subject}>
                        {subject}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="message"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Your Message</FormLabel>
                <FormControl>
                  <Textarea
                    {...field}
                    placeholder="Enter your message"
                    rows={4}
                    disabled={isSubmitting}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <div className="flex flex-col sm:flex-row gap-3 pt-4">
            <Button
              type="submit"
              disabled={isSubmitting}
              className="flex-1 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-semibold py-3 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-lg"
            >
              {isSubmitting ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent mr-2" />
                  Sending Message...
                </>
              ) : (
                <>
                  <Send className="mr-2 h-4 w-4" />
                  Send Message
                </>
              )}
            </Button>

            <Button
              type="button"
              variant="outline"
              onClick={() => form.reset()}
              disabled={isSubmitting}
              className="px-6 py-3 border-2 border-gray-300 hover:border-gray-400 transition-all duration-200"
            >
              Clear Form
            </Button>
          </div>
        </form>
      </Form>
    </div>
  );
}
```

#### How It Works

This enhanced contact form demonstrates several advanced concepts:

1. **Extended Schema Validation**: The `enhancedContactFormSchema` includes additional fields with specific validation rules:
   - Phone number with minimum length requirement
   - Subject selection (required)
   - Priority enumeration with predefined values
   - Optional fields using `.optional()`

2. **Grid Layout**: Uses CSS Grid for responsive form layout:
   - Single column on mobile devices
   - Two columns on medium and larger screens
   - Automatic responsive behavior with `grid-cols-1 md:grid-cols-2`

3. **Select Components**: Implements dropdown selections for:
   - Subject categories with predefined options
   - Priority levels with visual indicators (emoji icons)
   - Dynamic option rendering from arrays

4. **Icon Integration**: Each form field includes relevant Lucide React icons for better UX:
   - Visual cues help users understand field purposes
   - Consistent icon sizing and positioning

5. **Enhanced Button Styling**: Custom gradient button with hover effects:
   - Gradient background colors
   - Scale transform on hover
   - Shadow effects for depth
   - Loading state with custom spinner

6. **Form Reset Functionality**: Separate clear button that resets all form fields to default values.

##### Customization Options

You can customize this enhanced form in multiple ways:

###### Dynamic Subject Options

```tsx
// Load subjects from API or CMS
const [subjects, setSubjects] = useState([]);

useEffect(() => {
  fetchSubjects().then(setSubjects);
}, []);

// Conditional subjects based on user type
const getSubjectOptions = (userType) => {
  const baseSubjects = ["General Inquiry", "Technical Support"];
  const premiumSubjects = ["Priority Support", "Account Manager"];

  return userType === "premium"
    ? [...baseSubjects, ...premiumSubjects]
    : baseSubjects;
};
```

###### Phone Number Validation

```tsx
// Advanced phone validation with formatting
import { parsePhoneNumberFromString } from "libphonenumber-js";

const phoneValidation = z.string().refine((phone) => {
  if (!phone) return true; // Optional field
  const phoneNumber = parsePhoneNumberFromString(phone, "US");
  return phoneNumber?.isValid();
}, "Please enter a valid phone number");
```

###### Conditional Field Display

```tsx
// Show/hide fields based on other selections
const watchSubject = form.watch("subject");
const showUrgentFields = watchSubject === "Technical Support";

{
  showUrgentFields && (
    <FormField
      name="urgency"
      render={({ field }) => (
        <FormItem>
          <FormLabel>How urgent is this issue?</FormLabel>
          {/* Additional field content */}
        </FormItem>
      )}
    />
  );
}
```

###### Custom Button Variants

```tsx
// Multiple button styles based on priority
const getButtonStyle = (priority) => {
  const styles = {
    low: "bg-green-600 hover:bg-green-700",
    medium: "bg-yellow-600 hover:bg-yellow-700",
    high: "bg-red-600 hover:bg-red-700",
  };
  return styles[priority] || styles.medium;
};

<Button
  className={`${getButtonStyle(watchPriority)} transition-all duration-300`}
>
  Send {priority} Priority Message
</Button>;
```

###### Auto-save Draft

```tsx
// Save form data to localStorage
useEffect(() => {
  const formData = form.getValues();
  localStorage.setItem("contactFormDraft", JSON.stringify(formData));
}, [form.watch()]);

// Load draft on component mount
useEffect(() => {
  const draft = localStorage.getItem("contactFormDraft");
  if (draft) {
    form.reset(JSON.parse(draft));
  }
}, []);
```

<BackToTop />

### Adding a Rich Text Editor for the Message Field

Enhance the message field with rich text editing capabilities, allowing users to format their messages with bold, italics, lists, and other formatting options.

#### Example with Tiptap (Recommended)

Tiptap is a modern, headless rich text editor that's highly customizable and works well with React.

```tsx
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Send,
  CheckCircle,
  Bold,
  Italic,
  List,
  ListOrdered,
  Quote,
  Undo,
  Redo,
  Type,
  Link,
} from "lucide-react";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useState } from "react";
import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import Link from "@tiptap/extension-link";
import Placeholder from "@tiptap/extension-placeholder";

const richTextFormSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email address"),
  subject: z.string().min(1, "Subject is required"),
  message: z
    .string()
    .min(10, "Message must be at least 10 characters")
    .max(2000, "Message must be less than 2000 characters"),
});

// Custom menu bar component
const MenuBar = ({ editor }) => {
  if (!editor) return null;

  // @collapse
  const menuItems = [
    {
      icon: Bold,
      action: () => editor.chain().focus().toggleBold().run(),
      isActive: editor.isActive("bold"),
      tooltip: "Bold (Ctrl+B)",
    },
    {
      icon: Italic,
      action: () => editor.chain().focus().toggleItalic().run(),
      isActive: editor.isActive("italic"),
      tooltip: "Italic (Ctrl+I)",
    },
    {
      icon: List,
      action: () => editor.chain().focus().toggleBulletList().run(),
      isActive: editor.isActive("bulletList"),
      tooltip: "Bullet List",
    },
    {
      icon: ListOrdered,
      action: () => editor.chain().focus().toggleOrderedList().run(),
      isActive: editor.isActive("orderedList"),
      tooltip: "Numbered List",
    },
    {
      icon: Quote,
      action: () => editor.chain().focus().toggleBlockquote().run(),
      isActive: editor.isActive("blockquote"),
      tooltip: "Quote",
    },
    {
      icon: Link,
      action: () => {
        const url = window.prompt("Enter URL:");
        if (url) {
          editor.chain().focus().setLink({ href: url }).run();
        }
      },
      isActive: editor.isActive("link"),
      tooltip: "Add Link",
    },
  ];

  return (
    <div className="border-b border-gray-200 p-2 flex items-center gap-1 bg-gray-50 rounded-t-lg">
      {menuItems.map((item, index) => (
        <Button
          key={index}
          type="button"
          variant="ghost"
          size="sm"
          onClick={item.action}
          className={`h-8 w-8 p-0 ${
            item.isActive
              ? "bg-blue-100 text-blue-600"
              : "text-gray-600 hover:text-gray-900"
          }`}
          title={item.tooltip}
        >
          <item.icon className="h-4 w-4" />
        </Button>
      ))}

      <div className="w-px h-6 bg-gray-300 mx-2" />

      <Button
        type="button"
        variant="ghost"
        size="sm"
        onClick={() => editor.chain().focus().undo().run()}
        disabled={!editor.can().undo()}
        className="h-8 w-8 p-0"
        title="Undo (Ctrl+Z)"
      >
        <Undo className="h-4 w-4" />
      </Button>

      <Button
        type="button"
        variant="ghost"
        size="sm"
        onClick={() => editor.chain().focus().redo().run()}
        disabled={!editor.can().redo()}
        className="h-8 w-8 p-0"
        title="Redo (Ctrl+Y)"
      >
        <Redo className="h-4 w-4" />
      </Button>

      <div className="ml-auto flex items-center gap-2 text-xs text-gray-500">
        <Type className="h-3 w-3" />
        <span>{editor.storage.characterCount?.characters() || 0}/2000</span>
      </div>
    </div>
  );
};

export default function RichTextContactForm() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitStatus, setSubmitStatus] = useState(null);

  const form = useForm({
    resolver: zodResolver(richTextFormSchema),
    defaultValues: {
      name: "",
      email: "",
      subject: "",
      message: "",
    },
  });

  // Initialize Tiptap editor
  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [1, 2, 3],
        },
      }),
      Link.configure({
        openOnClick: false,
        HTMLAttributes: {
          class: "text-blue-600 underline hover:text-blue-800",
        },
      }),
      Placeholder.configure({
        placeholder:
          "Write your message here... You can use formatting tools above.",
      }),
    ],
    content: "",
    editorProps: {
      attributes: {
        class: "prose prose-sm max-w-none focus:outline-none min-h-[120px] p-4",
      },
    },
    onUpdate: ({ editor }) => {
      const html = editor.getHTML();
      const text = editor.getText();
      form.setValue("message", text, { shouldValidate: true });
    },
  });

  const onSubmit = async (data) => {
    setIsSubmitting(true);
    setSubmitStatus(null);

    try {
      // Get both HTML and plain text versions
      const htmlContent = editor?.getHTML();
      const plainTextContent = editor?.getText();

      // Simulate API call
      const response = await fetch("/api/contact", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          ...data,
          messageHtml: htmlContent,
          messagePlain: plainTextContent,
          hasFormatting: htmlContent !== `<p>${plainTextContent}</p>`,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      setSubmitStatus({
        type: "success",
        message: "Your formatted message has been sent successfully!",
      });

      form.reset();
      editor?.commands.clearContent();
    } catch (error) {
      console.error("Form submission error:", error);

      setSubmitStatus({
        type: "error",
        message: "Failed to send your message. Please try again.",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Keyboard shortcuts
  const handleKeyDown = (e) => {
    if (e.ctrlKey || e.metaKey) {
      switch (e.key) {
        case "b":
          e.preventDefault();
          editor?.chain().focus().toggleBold().run();
          break;
        case "i":
          e.preventDefault();
          editor?.chain().focus().toggleItalic().run();
          break;
        case "Enter":
          e.preventDefault();
          if (form.formState.isValid) {
            onSubmit(form.getValues());
          }
          break;
      }
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-6 bg-white rounded-lg shadow-lg">
      <div className="mb-8">
        <h2 className="text-3xl font-bold text-gray-800 mb-2">
          Rich Text Contact Form
        </h2>
        <p className="text-gray-600">
          Format your message with bold, italics, lists, and more using our rich
          text editor.
        </p>
      </div>

      <Form {...form}>
        <form
          onSubmit={form.handleSubmit(onSubmit)}
          className="space-y-6"
          onKeyDown={handleKeyDown}
        >
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Full Name</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      placeholder="Enter your full name"
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email Address</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      type="email"
                      placeholder="Enter your email"
                      disabled={isSubmitting}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </div>

          <FormField
            control={form.control}
            name="subject"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Subject</FormLabel>
                <FormControl>
                  <Input
                    {...field}
                    placeholder="Brief subject line"
                    disabled={isSubmitting}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="message"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Your Message</FormLabel>
                <FormControl>
                  <div className="border border-gray-200 rounded-lg overflow-hidden focus-within:ring-2 focus-within:ring-blue-500 focus-within:border-blue-500">
                    <MenuBar editor={editor} />
                    <EditorContent
                      editor={editor}
                      className="min-h-[120px] max-h-[300px] overflow-y-auto"
                    />
                  </div>
                </FormControl>
                <FormMessage />

                {/* Formatting Tips */}
                <div className="text-xs text-gray-500 mt-2 space-y-1">
                  <p>
                    <strong>Tips:</strong> Use the toolbar above or keyboard
                    shortcuts:
                  </p>
                  <ul className="list-disc list-inside space-y-0.5 ml-2">
                    <li>
                      <kbd className="px-1 py-0.5 bg-gray-100 rounded text-xs">
                        Ctrl+B
                      </kbd>{" "}
                      for bold
                    </li>
                    <li>
                      <kbd className="px-1 py-0.5 bg-gray-100 rounded text-xs">
                        Ctrl+I
                      </kbd>{" "}
                      for italic
                    </li>
                    <li>
                      <kbd className="px-1 py-0.5 bg-gray-100 rounded text-xs">
                        Ctrl+Enter
                      </kbd>{" "}
                      to submit
                    </li>
                  </ul>
                </div>
              </FormItem>
            )}
          />

          {/* Preview Mode Toggle */}
          <div className="flex items-center gap-4">
            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={() => {
                const html = editor?.getHTML();
                if (html) {
                  navigator.clipboard.writeText(html);
                  alert("HTML content copied to clipboard!");
                }
              }}
              disabled={!editor?.getText()?.trim()}
            >
              Copy HTML
            </Button>

            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={() => {
                const text = editor?.getText();
                if (text) {
                  navigator.clipboard.writeText(text);
                  alert("Plain text copied to clipboard!");
                }
              }}
              disabled={!editor?.getText()?.trim()}
            >
              Copy Plain Text
            </Button>
          </div>

          {/* Status Messages */}
          {submitStatus && (
            <Alert
              variant={
                submitStatus.type === "error" ? "destructive" : "default"
              }
            >
              {submitStatus.type === "success" ? (
                <CheckCircle className="h-4 w-4" />
              ) : (
                <XCircle className="h-4 w-4" />
              )}
              <AlertDescription>{submitStatus.message}</AlertDescription>
            </Alert>
          )}

          <Button
            type="submit"
            disabled={isSubmitting || !form.watch("message")?.trim()}
            className="w-full bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700"
          >
            {isSubmitting ? (
              <>
                <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent mr-2" />
                Sending Formatted Message...
              </>
            ) : (
              <>
                <Send className="mr-2 h-4 w-4" />
                Send Formatted Message
              </>
            )}
          </Button>

          {/* Editor Info */}
          <div className="text-center pt-4 border-t border-gray-200">
            <p className="text-xs text-gray-500">
              Rich text editor powered by Tiptap. HTML and plain text versions
              are sent.
            </p>
          </div>
        </form>
      </Form>
    </div>
  );
}
```

##### Example with Quill.js (Alternative)

For a more traditional rich text editor experience, you can use Quill.js:

```tsx
import ReactQuill from "react-quill";
import "react-quill/dist/quill.snow.css";

const QuillContactForm = () => {
  const [messageContent, setMessageContent] = useState("");

  const quillModules = {
    toolbar: [
      [{ header: [1, 2, 3, false] }],
      ["bold", "italic", "underline", "strike"],
      [{ list: "ordered" }, { list: "bullet" }],
      ["blockquote", "code-block"],
      ["link", "image"],
      ["clean"],
    ],
  };

  const quillFormats = [
    "header",
    "bold",
    "italic",
    "underline",
    "strike",
    "list",
    "bullet",
    "blockquote",
    "code-block",
    "link",
    "image",
  ];

  return (
    <FormField
      control={form.control}
      name="message"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Message</FormLabel>
          <FormControl>
            <ReactQuill
              value={messageContent}
              onChange={(content) => {
                setMessageContent(content);
                // Strip HTML tags for validation
                const plainText = content.replace(/<[^>]*>/g, "");
                field.onChange(plainText);
              }}
              modules={quillModules}
              formats={quillFormats}
              theme="snow"
              placeholder="Write your formatted message here..."
              style={{ height: "200px" }}
            />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
  );
};
```

###### How It Works

Both implementations provide rich text editing capabilities with different approaches:

- Tiptap: Modern, headless, highly customizable, better TypeScript support
- Quill.js: Traditional, feature-rich out of the box, mature ecosystem

Choose based on your specific needs for customization, bundle size, and desired features.

<BackToTop />

### Multi-Step Contact Form with Advanced Validation

This example demonstrates a  multi-step contact form using advanced Zod schemas:

```tsx
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Checkbox } from "@/components/ui/checkbox";
import { Progress } from "@/components/ui/progress";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
  ChevronLeft,
  ChevronRight,
  CheckCircle,
  User,
  Mail,
  MessageSquare,
  Settings,
} from "lucide-react";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useState } from "react";

// Step 1: Personal Information Schema
// @collapse
const personalInfoSchema = z.object({
  firstName: z
    .string()
    .min(2, "First name must be at least 2 characters")
    .max(30, "First name must be less than 30 characters")
    .regex(/^[a-zA-Z\s']+$/, "Only letters, spaces, and apostrophes allowed"),

  lastName: z
    .string()
    .min(2, "Last name must be at least 2 characters")
    .max(30, "Last name must be less than 30 characters")
    .regex(/^[a-zA-Z\s']+$/, "Only letters, spaces, and apostrophes allowed"),

  email: z
    .string()
    .email("Please enter a valid email address")
    .toLowerCase()
    .refine(
      (email) => !email.includes("+"),
      "Email addresses with '+' symbols are not supported"
    ),

  phone: z
    .string()
    .regex(/^[\+]?[1-9][\d]{0,15}$/, "Please enter a valid phone number")
    .optional()
    .or(z.literal("")),

  company: z
    .string()
    .max(100, "Company name must be less than 100 characters")
    .optional()
    .or(z.literal("")),

  position: z
    .string()
    .max(50, "Position must be less than 50 characters")
    .optional()
    .or(z.literal("")),
});

// Step 2: Contact Details Schema
// @collapse
const contactDetailsSchema = z.object({
  inquiryType: z.enum(
    [
      "general",
      "technical-support",
      "sales",
      "partnership",
      "media",
      "careers",
      "feedback",
    ],
    {
      errorMap: () => ({ message: "Please select an inquiry type" }),
    }
  ),

  urgency: z.enum(["low", "medium", "high", "critical"], {
    errorMap: () => ({ message: "Please select urgency level" }),
  }),

  preferredContact: z.enum(["email", "phone", "either"], {
    errorMap: () => ({ message: "Please select preferred contact method" }),
  }),

  bestTimeToContact: z
    .array(z.enum(["morning", "afternoon", "evening", "weekends"]))
    .min(1, "Please select at least one time preference")
    .max(4, "Please select no more than 4 time preferences"),

  budget: z
    .enum([
      "under-1k",
      "1k-5k",
      "5k-10k",
      "10k-25k",
      "25k-plus",
      "not-applicable",
    ])
    .optional(),
});

// Step 3: Message Schema
// @collapse
const messageSchema = z.object({
  subject: z
    .string()
    .min(5, "Subject must be at least 5 characters")
    .max(100, "Subject must be less than 100 characters"),

  message: z
    .string()
    .min(20, "Please provide a detailed message (at least 20 characters)")
    .max(2000, "Message must be less than 2000 characters")
    .refine(
      (msg) => msg.trim().split(/\s+/).length >= 5,
      "Message must contain at least 5 words"
    ),

  attachments: z
    .array(
      z.object({
        name: z.string(),
        size: z
          .number()
          .max(10 * 1024 * 1024, "Files must be smaller than 10MB"),
        type: z
          .string()
          .refine(
            (type) =>
              [
                "image/jpeg",
                "image/png",
                "image/gif",
                "application/pdf",
                "text/plain",
                "application/msword",
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
              ].includes(type),
            "Only images, PDFs, and Word documents are allowed"
          ),
      })
    )
    .max(5, "Maximum 5 files allowed")
    .optional(),

  followUpExpected: z.boolean().default(true),

  newsletter: z.boolean().default(false),

  privacyConsent: z
    .boolean()
    .refine(
      (val) => val === true,
      "You must agree to our privacy policy to continue"
    ),
});

// Combined schema for final validation
const completeFormSchema = personalInfoSchema
  .merge(contactDetailsSchema)
  .merge(messageSchema)
  .refine(
    (data) => {
      // If urgency is critical, phone number is required
      if (data.urgency === "critical" && !data.phone) {
        return false;
      }
      return true;
    },
    {
      message: "Phone number is required for critical inquiries",
      path: ["phone"],
    }
  )
  .refine(
    (data) => {
      // If preferred contact is phone, phone number is required
      if (data.preferredContact === "phone" && !data.phone) {
        return false;
      }
      return true;
    },
    {
      message:
        "Phone number is required when phone is preferred contact method",
      path: ["phone"],
    }
  );

type CompleteFormData = z.infer<typeof completeFormSchema>;

export default function MultiStepContactForm() {
  const [currentStep, setCurrentStep] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isComplete, setIsComplete] = useState(false);

  const totalSteps = 3;
  const progress = (currentStep / totalSteps) * 100;

  // @collapse
  const form = useForm<CompleteFormData>({
    resolver: zodResolver(completeFormSchema),
    mode: "onChange",
    defaultValues: {
      firstName: "",
      lastName: "",
      email: "",
      phone: "",
      company: "",
      position: "",
      inquiryType: "general",
      urgency: "medium",
      preferredContact: "email",
      bestTimeToContact: [],
      subject: "",
      message: "",
      followUpExpected: true,
      newsletter: false,
      privacyConsent: false,
    },
  });

  // @collapse
  const validateCurrentStep = async () => {
    const values = form.getValues();

    try {
      switch (currentStep) {
        case 1:
          personalInfoSchema.parse({
            firstName: values.firstName,
            lastName: values.lastName,
            email: values.email,
            phone: values.phone,
            company: values.company,
            position: values.position,
          });
          break;
        case 2:
          contactDetailsSchema.parse({
            inquiryType: values.inquiryType,
            urgency: values.urgency,
            preferredContact: values.preferredContact,
            bestTimeToContact: values.bestTimeToContact,
            budget: values.budget,
          });
          break;
        case 3:
          messageSchema.parse({
            subject: values.subject,
            message: values.message,
            attachments: values.attachments,
            followUpExpected: values.followUpExpected,
            newsletter: values.newsletter,
            privacyConsent: values.privacyConsent,
          });
          break;
      }
      return true;
    } catch (error) {
      if (error instanceof z.ZodError) {
        // Set form errors
        error.errors.forEach((err) => {
          form.setError(err.path.join(".") as any, {
            message: err.message,
          });
        });
      }
      return false;
    }
  };

  const nextStep = async () => {
    const isValid = await validateCurrentStep();
    if (isValid && currentStep < totalSteps) {
      setCurrentStep(currentStep + 1);
    }
  };

  const prevStep = () => {
    if (currentStep > 1) {
      setCurrentStep(currentStep - 1);
    }
  };

  const onSubmit = async (data: CompleteFormData) => {
    setIsSubmitting(true);

    try {
      // Final validation
      const validatedData = completeFormSchema.parse(data);

      // Simulate API call
      await new Promise((resolve) => setTimeout(resolve, 3000));

      console.log("Form submitted successfully:", validatedData);
      setIsComplete(true);
    } catch (error) {
      console.error("Submission error:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const inquiryTypeOptions = [
    { value: "general", label: "General Inquiry", icon: "üí¨" },
    { value: "technical-support", label: "Technical Support", icon: "üîß" },
    { value: "sales", label: "Sales Question", icon: "üí∞" },
    { value: "partnership", label: "Partnership", icon: "ü§ù" },
    { value: "media", label: "Media & Press", icon: "üì∞" },
    { value: "careers", label: "Career Opportunities", icon: "üíº" },
    { value: "feedback", label: "Feedback", icon: "üí≠" },
  ];

  const urgencyOptions = [
    {
      value: "low",
      label: "Low Priority",
      color: "bg-green-100 text-green-800",
    },
    {
      value: "medium",
      label: "Medium Priority",
      color: "bg-yellow-100 text-yellow-800",
    },
    {
      value: "high",
      label: "High Priority",
      color: "bg-orange-100 text-orange-800",
    },
    { value: "critical", label: "Critical", color: "bg-red-100 text-red-800" },
  ];

  if (isComplete) {
    return (
      <Card className="max-w-2xl mx-auto">
        <CardContent className="p-8 text-center">
          <CheckCircle className="h-16 w-16 text-green-500 mx-auto mb-4" />
          <h2 className="text-2xl font-bold text-gray-800 mb-2">Thank You!</h2>
          <p className="text-gray-600 mb-6">
            Your message has been sent successfully. We'll get back to you
            within 24 hours.
          </p>
          <Button onClick={() => window.location.reload()} variant="outline">
            Send Another Message
          </Button>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="max-w-3xl mx-auto p-6 space-y-6">
      {/* Progress Header */}
      <Card>
        <CardHeader className="pb-4">
          <div className="flex items-center justify-between mb-4">
            <CardTitle className="text-2xl">Contact Us</CardTitle>
            <Badge variant="outline">
              Step {currentStep} of {totalSteps}
            </Badge>
          </div>
          <Progress value={progress} className="h-2" />

          <div className="flex justify-between mt-4 text-sm">
            <div
              className={`flex items-center gap-2 ${currentStep >= 1 ? "text-blue-600" : "text-gray-400"}`}
            >
              <User className="h-4 w-4" />
              Personal Info
            </div>
            <div
              className={`flex items-center gap-2 ${currentStep >= 2 ? "text-blue-600" : "text-gray-400"}`}
            >
              <Mail className="h-4 w-4" />
              Contact Details
            </div>
            <div
              className={`flex items-center gap-2 ${currentStep >= 3 ? "text-blue-600" : "text-gray-400"}`}
            >
              <MessageSquare className="h-4 w-4" />
              Your Message
            </div>
          </div>
        </CardHeader>
      </Card>

      {/* Form Content */}
      <Card>
        <CardContent className="p-6">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Step 1: Personal Information */}
              {currentStep === 1 && (
                <div className="space-y-6">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="firstName"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>First Name *</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="John" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="lastName"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Last Name *</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="Doe" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>

                  <FormField
                    control={form.control}
                    name="email"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Email Address *</FormLabel>
                        <FormControl>
                          <Input
                            {...field}
                            type="email"
                            placeholder="john@example.com"
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="phone"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Phone Number</FormLabel>
                        <FormControl>
                          <Input
                            {...field}
                            type="tel"
                            placeholder="+1 (555) 123-4567"
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="company"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Company</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="Acme Corp" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="position"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Position</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="Software Engineer" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                </div>
              )}

              {/* Step 2: Contact Details */}
              {currentStep === 2 && (
                <div className="space-y-6">
                  <FormField
                    control={form.control}
                    name="inquiryType"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>What is your inquiry about? *</FormLabel>
                        <FormControl>
                          <RadioGroup
                            onValueChange={field.onChange}
                            defaultValue={field.value}
                            className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2"
                          >
                            {inquiryTypeOptions.map((option) => (
                              <div
                                key={option.value}
                                className="flex items-center space-x-2 border rounded-lg p-4 hover:bg-gray-50"
                              >
                                <RadioGroupItem
                                  value={option.value}
                                  id={option.value}
                                />
                                <label
                                  htmlFor={option.value}
                                  className="flex items-center gap-2 cursor-pointer flex-1"
                                >
                                  <span className="text-lg">{option.icon}</span>
                                  <span>{option.label}</span>
                                </label>
                              </div>
                            ))}
                          </RadioGroup>
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="urgency"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Urgency Level *</FormLabel>
                        <FormControl>
                          <RadioGroup
                            onValueChange={field.onChange}
                            defaultValue={field.value}
                            className="flex gap-4 mt-2"
                          >
                            {urgencyOptions.map((option) => (
                              <div
                                key={option.value}
                                className="flex items-center space-x-2"
                              >
                                <RadioGroupItem
                                  value={option.value}
                                  id={`urgency-${option.value}`}
                                />
                                <label
                                  htmlFor={`urgency-${option.value}`}
                                  className="cursor-pointer"
                                >
                                  <Badge className={option.color}>
                                    {option.label}
                                  </Badge>
                                </label>
                              </div>
                            ))}
                          </RadioGroup>
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="preferredContact"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Preferred Contact Method *</FormLabel>
                        <FormControl>
                          <RadioGroup
                            onValueChange={field.onChange}
                            defaultValue={field.value}
                            className="flex gap-6 mt-2"
                          >
                            <div className="flex items-center space-x-2">
                              <RadioGroupItem
                                value="email"
                                id="contact-email"
                              />
                              <label
                                htmlFor="contact-email"
                                className="cursor-pointer"
                              >
                                Email
                              </label>
                            </div>
                            <div className="flex items-center space-x-2">
                              <RadioGroupItem
                                value="phone"
                                id="contact-phone"
                              />
                              <label
                                htmlFor="contact-phone"
                                className="cursor-pointer"
                              >
                                Phone
                              </label>
                            </div>
                            <div className="flex items-center space-x-2">
                              <RadioGroupItem
                                value="either"
                                id="contact-either"
                              />
                              <label
                                htmlFor="contact-either"
                                className="cursor-pointer"
                              >
                                Either
                              </label>
                            </div>
                          </RadioGroup>
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="bestTimeToContact"
                    render={() => (
                      <FormItem>
                        <FormLabel>
                          Best Time to Contact (select all that apply) *
                        </FormLabel>
                        <div className="grid grid-cols-2 gap-4 mt-2">
                          {["morning", "afternoon", "evening", "weekends"].map(
                            (time) => (
                              <FormField
                                key={time}
                                control={form.control}
                                name="bestTimeToContact"
                                render={({ field }) => {
                                  return (
                                    <FormItem className="flex flex-row items-start space-x-3 space-y-0">
                                      <FormControl>
                                        <Checkbox
                                          checked={field.value?.includes(time)}
                                          onCheckedChange={(checked) => {
                                            const updatedValue = checked
                                              ? [...(field.value || []), time]
                                              : (field.value || []).filter(
                                                  (value) => value !== time
                                                );
                                            field.onChange(updatedValue);
                                          }}
                                        />
                                      </FormControl>
                                      <FormLabel className="capitalize cursor-pointer">
                                        {time}
                                      </FormLabel>
                                    </FormItem>
                                  );
                                }}
                              />
                            )
                          )}
                        </div>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>
              )}

              {/* Step 3: Message */}
              {currentStep === 3 && (
                <div className="space-y-6">
                  <FormField
                    control={form.control}
                    name="subject"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Subject *</FormLabel>
                        <FormControl>
                          <Input {...field} placeholder="Brief subject line" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="message"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Your Message *</FormLabel>
                        <FormControl>
                          <Textarea
                            {...field}
                            placeholder="Please provide details about your inquiry..."
                            rows={6}
                          />
                        </FormControl>
                        <FormMessage />
                        <div className="text-sm text-gray-500">
                          {field.value?.length || 0}/2000 characters
                        </div>
                      </FormItem>
                    )}
                  />

                  <div className="space-y-4">
                    <FormField
                      control={form.control}
                      name="followUpExpected"
                      render={({ field }) => (
                        <FormItem className="flex flex-row items-start space-x-3 space-y-0">
                          <FormControl>
                            <Checkbox
                              checked={field.value}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                          <div className="space-y-1 leading-none">
                            <FormLabel className="cursor-pointer">
                              I expect a follow-up response
                            </FormLabel>
                          </div>
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="newsletter"
                      render={({ field }) => (
                        <FormItem className="flex flex-row items-start space-x-3 space-y-0">
                          <FormControl>
                            <Checkbox
                              checked={field.value}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                          <div className="space-y-1 leading-none">
                            <FormLabel className="cursor-pointer">
                              Subscribe to our newsletter for updates
                            </FormLabel>
                          </div>
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="privacyConsent"
                      render={({ field }) => (
                        <FormItem className="flex flex-row items-start space-x-3 space-y-0">
                          <FormControl>
                            <Checkbox
                              checked={field.value}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                          <div className="space-y-1 leading-none">
                            <FormLabel className="cursor-pointer">
                              I agree to the{" "}
                              <a
                                href="/privacy"
                                className="text-blue-600 underline"
                              >
                                privacy policy
                              </a>{" "}
                              *
                            </FormLabel>
                          </div>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                </div>
              )}

              {/* Navigation Buttons */}
              <div className="flex justify-between pt-6 border-t">
                <Button
                  type="button"
                  variant="outline"
                  onClick={prevStep}
                  disabled={currentStep === 1}
                  className="flex items-center gap-2"
                >
                  <ChevronLeft className="h-4 w-4" />
                  Previous
                </Button>

                {currentStep < totalSteps ? (
                  <Button
                    type="button"
                    onClick={nextStep}
                    className="flex items-center gap-2"
                  >
                    Next
                    <ChevronRight className="h-4 w-4" />
                  </Button>
                ) : (
                  <Button
                    type="submit"
                    disabled={isSubmitting}
                    className="bg-green-600 hover:bg-green-700 flex items-center gap-2"
                  >
                    {isSubmitting ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent" />
                        Sending...
                      </>
                    ) : (
                      <>
                        <CheckCircle className="h-4 w-4" />
                        Send Message
                      </>
                    )}
                  </Button>
                )}
              </div>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
}
```

#### How This Advanced Example Works

This multi-step contact form demonstrates several advanced Zod and form handling concepts:

1. **Schema Composition**: Three separate schemas (`personalInfoSchema`, `contactDetailsSchema`, `messageSchema`) are combined into a complete schema with cross-field validation.

2. **Step-by-Step Validation**: Each step is validated independently before allowing progression, providing immediate feedback.

3. **Complex Field Types**: Demonstrates various input types including radio groups, checkboxes, arrays, and conditional validation.

4. **Cross-Field Dependencies**: Phone number becomes required when urgency is "critical" or when phone is the preferred contact method.

5. **User Experience**: Progressive disclosure, visual progress indicators, and contextual validation messages.

6. **Data Transformation**: Email addresses are automatically converted to lowercase, and empty strings are converted to undefined for optional fields.

##### Customization Options

- Dynamic Steps: Add or remove steps based on user selections
- Conditional Fields: Show/hide fields based on previous answers
- Save Progress: Store form data in localStorage for session persistence
- File Upload: Add file attachment capabilities with proper validation
- Real-time Validation: Validate fields as users type rather than on step completion

<BackToTop />

### International Contact Form with Localization

This example shows how to handle international users with proper validation for different regions:

```tsx
import { z } from "zod";
import { parsePhoneNumberFromString } from "libphonenumber-js";

// Country-specific validation schemas
const createInternationalSchema = (country: string = "US") => {
  const baseSchema = z.object({
    firstName: z.string().min(1, "First name is required"),
    lastName: z.string().min(1, "Last name is required"),
    email: z.string().email("Invalid email address"),
    country: z.string().min(1, "Please select your country"),

    // Phone validation based on country
    phone: z
      .string()
      .optional()
      .refine((phone) => {
        if (!phone) return true; // Optional field
        const phoneNumber = parsePhoneNumberFromString(phone, country as any);
        return phoneNumber?.isValid();
      }, `Please enter a valid ${country} phone number`),

    // Postal code validation varies by country
    postalCode: z
      .string()
      .optional()
      .refine((code) => {
        if (!code) return true;

        const patterns = {
          US: /^\d{5}(-\d{4})?$/,
          CA: /^[A-Za-z]\d[A-Za-z] \d[A-Za-z]\d$/,
          UK: /^[A-Z]{1,2}\d[A-Z\d]? \d[A-Z]{2}$/,
          DE: /^\d{5}$/,
          FR: /^\d{5}$/,
          JP: /^\d{3}-\d{4}$/,
        };

        const pattern = patterns[country as keyof typeof patterns];
        return pattern ? pattern.test(code) : true;
      }, "Please enter a valid postal code for your country"),

    message: z.string().min(10, "Message must be at least 10 characters"),

    // GDPR compliance for EU countries
    gdprConsent:
      country === "EU"
        ? z.boolean().refine((val) => val === true, "GDPR consent is required")
        : z.boolean().optional(),
  });

  return baseSchema;
};

// @collapse
export default function InternationalContactForm() {
  const [selectedCountry, setSelectedCountry] = useState("US");
  const schema = useMemo(
    () => createInternationalSchema(selectedCountry),
    [selectedCountry]
  );

  const form = useForm({
    resolver: zodResolver(schema),
    defaultValues: {
      country: "US",
      gdprConsent: false,
    },
  });

  // Rest of component implementation...
}
```

### File Upload Contact Form with Advanced Validation

```tsx
import { z } from "zod";

const fileUploadSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email address"),
  subject: z.string().min(1, "Subject is required"),
  message: z.string().min(10, "Message must be at least 10 characters"),

  // File upload with  validation
  attachments: z
    .array(
      z.object({
        name: z.string(),
        size: z
          .number()
          .max(10 * 1024 * 1024, "File must be smaller than 10MB")
          .min(1, "File cannot be empty"),
        type: z.string().refine(
          (type) =>
            [
              // Images
              "image/jpeg",
              "image/jpg",
              "image/png",
              "image/gif",
              "image/webp",
              // Documents
              "application/pdf",
              "text/plain",
              "application/msword",
              "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
              "application/vnd.ms-excel",
              "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
              // Compressed files
              "application/zip",
              "application/x-rar-compressed",
            ].includes(type),
          "File type not supported. Please upload images, documents, or compressed files."
        ),
        lastModified: z.number().optional(),
        // File content validation (for security)
        content: z
          .string()
          .optional()
          .refine((content) => {
            if (!content) return true;
            // Basic security check - no script tags
            return !/<script[\s\S]*?>[\s\S]*?<\/script>/gi.test(content);
          }, "File contains potentially dangerous content"),
      })
    )
    .max(5, "Maximum 5 files allowed")
    .optional()
    .refine((files) => {
      if (!files) return true;
      const totalSize = files.reduce((sum, file) => sum + file.size, 0);
      return totalSize <= 25 * 1024 * 1024; // 25MB total
    }, "Total file size cannot exceed 25MB"),

  // File categories for better organization
  attachmentCategories: z
    .array(
      z.enum(["documentation", "screenshots", "designs", "contracts", "other"])
    )
    .optional(),
});

export default function FileUploadContactForm() {
  const [files, setFiles] = useState<File[]>([]);
  const [uploadProgress, setUploadProgress] = useState<Record<string, number>>(
    {}
  );

  const form = useForm({
    resolver: zodResolver(fileUploadSchema),
  });

  // @collapse
  const handleFileUpload = useCallback(async (acceptedFiles: File[]) => {
    const validatedFiles = [];

    for (const file of acceptedFiles) {
      try {
        // Validate individual file
        const fileData = {
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified,
        };

        // Additional security checks
        if (file.type.startsWith("text/")) {
          const content = await file.text();
          fileData.content = content;
        }

        // Validate with Zod
        const validation =
          fileUploadSchema.shape.attachments.element.safeParse(fileData);

        if (validation.success) {
          validatedFiles.push(file);
        } else {
          // Show specific error for this file
          toast.error(`${file.name}: ${validation.error.errors[0].message}`);
        }
      } catch (error) {
        toast.error(`Error processing ${file.name}: ${error.message}`);
      }
    }

    setFiles((prev) => [...prev, ...validatedFiles]);
  }, []);

  // Rest of component implementation with drag-and-drop, progress bars, etc...
}
```

These examples demonstrate the full power and flexibility of Zod for handling complex form validation scenarios. Each example builds upon the previous concepts while introducing new validation patterns and real-world use cases.

<BackToTop />
