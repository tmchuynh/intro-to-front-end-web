import BackToTop from "@/components/BackToTop";

# Handling the Navigation

## Table of Contents

## Overview

MDX (Markdown with JSX) allows you to create rich, interactive content in your documentation. One of the key features is the ability to handle navigation effectively, making it easier for users to explore your content.

For the purpose of this project, we will be creating a sidebar for the main navigation and a top navigation bar for quick access to different sections of the documentation. This will enhance the user experience by providing clear paths to navigate through the content.

## Creating a Sidebar Navigation

To create a sidebar navigation, we will use a combination of React components and CSS for styling.

### The Sidebar Component

This component will handle the display of the sidebar, including the navigation links and sections. It will also manage the open/close state of the sidebar.

```tsx
import { useNavigation } from "@/hooks/useNavigation";
import type { NavigationItem } from "@/utils/navigation";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { useCallback, useEffect, useState } from "react";
import NavigationSection from "./NavigationSection";

interface SidebarProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function Sidebar({ isOpen, onClose }: SidebarProps) {
  const { navigation, loading } = useNavigation();
  const pathname = usePathname();
  const [openSection, setOpenSection] = useState<string | null>(null);

  // Recursive function to check if any item or its children contain the path
  const checkItemContainsPath = useCallback(
    (items: NavigationItem[], path: string): boolean => {
      for (const item of items) {
        // Check direct match
        if (item.href === path) {
          return true;
        }
        // Check if path starts with this item's path (for sub-routes)
        if (path.startsWith(item.href + "/") && item.href !== "#") {
          return true;
        }
        // Recursively check children
        if (item.children && checkItemContainsPath(item.children, path)) {
          return true;
        }
      }
      return false;
    },
    []
  );

  // Function to find which section contains the current path
  const findSectionForPath = useCallback(
    (path: string) => {
      for (const section of navigation) {
        if (checkItemContainsPath(section.items, path)) {
          return section.title;
        }
      }
      return null;
    },
    [navigation, checkItemContainsPath]
  );

  // Set the section containing the current page as open by default
  useEffect(() => {
    if (navigation.length > 0 && openSection === null) {
      const currentSection = findSectionForPath(pathname);
      if (currentSection) {
        setOpenSection(currentSection);
      } else {
        // Fallback to first section if no match found
        setOpenSection(navigation[0].title);
      }
    }
  }, [navigation, openSection, findSectionForPath, pathname]);

  const handleSectionToggle = (sectionTitle: string) => {
    setOpenSection(openSection === sectionTitle ? null : sectionTitle);
  };

  return (
    <>
      {/* Mobile overlay */}
      {isOpen && (
        <div
          className="fixed inset-0 z-40 lg:hidden bg-background bg-opacity-50 transition-opacity"
          onClick={onClose}
        />
      )}

      {/* Sidebar */}
      <aside
        id="sidebar"
        className={`
        bg-sidebar-bg border-sidebar-border text-sidebar-text fixed top-0 left-0 z-50 w-72 h-full border-r
        transform transition-transform duration-300 ease-in-out
        ${isOpen ? "translate-x-0" : "-translate-x-full"}
        lg:translate-x-0 lg:static lg:z-auto
      `}
      >
        <div className="flex flex-col h-full">
          {/* Your Name */}
          <div className="flex items-center justify-between p-4 border-sidebar-border border-b h-16">
            <Link href="/" className="flex items-center space-x-2">
              <span className="font-bold text-sidebar-text text-xl">
                Your Name
              </span>
            </Link>
            <button
              onClick={onClose}
              className="lg:hidden p-1 rounded-md sidebar-text-secondary"
            >
              <svg
                className="h-5 w-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </button>
          </div>

          {/* Navigation */}
          <nav className="flex-1 p-4 overflow-y-auto">
            <div className="space-y-6">
              {loading ? (
                <div className="animate-pulse">
                  <div className="bg-sidebar-hover-bg mb-3 rounded h-4"></div>
                  <div className="space-y-2 bg-sidebar-hover-bg">
                    <div className="bg-sidebar-hover-bg rounded h-3"></div>
                    <div className="bg-sidebar-hover-bg rounded h-3"></div>
                    <div className="bg-sidebar-hover-bg rounded h-3"></div>
                  </div>
                </div>
              ) : (
                navigation.map((section) => (
                  <NavigationSection
                    key={section.title}
                    title={section.title}
                    items={section.items}
                    isOpen={openSection === section.title}
                    onToggle={() => handleSectionToggle(section.title)}
                  />
                ))
              )}
            </div>
          </nav>
        </div>
      </aside>
    </>
  );
}
```

##### Explaination of the Code

The `Sidebar` component is responsible for rendering the sidebar navigation. It uses the `useNavigation` hook to fetch the navigation data and manages the open/close state of the sidebar. The sidebar contains a header with your name and a close button, followed by the navigation sections.

The sidebar is styled to be fixed on the left side of the screen, with a smooth transition effect when opening and closing. The navigation sections are displayed using the `NavigationSection` component, which handles the display of each section's title and items.

<BackToTop />

### NavigationSection Component

This component will handle the display of each section in the sidebar, including the title and the list of navigation items.

```tsx
// NavigationSection Component
import type { NavigationItem } from "@/utils/navigation";
import Link from "next/link";
import { useEffect, useState } from "react";

interface NavigationSectionProps {
  title: string;
  items: NavigationItem[];
  isOpen: boolean;
  onToggle: () => void;
}

export default function NavigationSection({
  title,
  items,
  isOpen,
  onToggle,
}: NavigationSectionProps) {
  const [expandedItem, setExpandedItem] = useState<string | null>(null);

  // Reset expanded item when section is closed
  useEffect(() => {
    if (!isOpen) {
      setExpandedItem(null);
    }
  }, [isOpen]);

  const handleItemToggle = (itemTitle: string) => {
    setExpandedItem(expandedItem === itemTitle ? null : itemTitle);
  };

  return (
    <div>
      <button
        onClick={onToggle}
        className={`flex justify-between items-center mb-3 w-full font-semibold text-left text-xs uppercase tracking-wider transition-colors ${
          isOpen
            ? "text-sidebar-active-text"
            : "text-sidebar-text hover:text-sidebar-text-secondary "
        }`}
      >
        {title}
        <svg
          className={`w-4 h-4 transition-transform duration-200 ${
            isOpen ? "rotate-180" : ""
          }`}
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M19 9l-7 7-7-7"
          />
        </svg>
      </button>
      <div
        className={`overflow-hidden transition-all duration-300 ease-in-out scrollbar-hide ${
          isOpen ? "max-h-screen opacity-100" : "max-h-0 opacity-0"
        }`}
      >
        <ul className={`space-y-1 ${isOpen ? "pb-2" : ""}`}>
          {items.map((item, index) => {
            const hasChildren = item.children && item.children.length > 0;
            return (
              <NavigationItem
                key={`${item.href}-${item.title}-${index}`}
                item={item}
                {...(hasChildren && {
                  isExpanded: expandedItem === item.title,
                  onToggle: () => handleItemToggle(item.title),
                })}
              />
            );
          })}
        </ul>
      </div>
    </div>
  );
}
```

```tsx
// NavigationSection Component
function NavigationItem({
  item,
  isExpanded,
  onToggle,
  depth = 0,
}: {
  item: NavigationItem;
  isExpanded?: boolean;
  onToggle?: () => void;
  depth?: number;
}) {
  const hasChildren = item.children && item.children.length > 0;
  const [expandedChild, setExpandedChild] = useState<string | null>(null);

  // Reset expanded child when this item is collapsed
  useEffect(() => {
    if (!isExpanded) {
      setExpandedChild(null);
    }
  }, [isExpanded]);

  const handleChildToggle = (childTitle: string) => {
    setExpandedChild(expandedChild === childTitle ? null : childTitle);
  };

  if (hasChildren) {
    return (
      <li className="">
        <button
          onClick={onToggle}
          className={`flex justify-between items-center px-3 py-2 ml-1 max-w-full w-13/14  font-medium text-left text-sm transition-colors rounded-md ${
            isExpanded ? "bg-primary/50 " : "hover:bg-sidebar-border "
          } `}
        >
          {item.title}
          <svg
            className={`w-3 h-3 transition-transform duration-200 ${
              isExpanded ? "rotate-180" : ""
            }`}
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M19 9l-7 7-7-7"
            />
          </svg>
        </button>
        <div
          className={`overflow-hidden transition-all duration-300 ease-in-out max-w-full w-11/12 scrollbar-hide ${
            isExpanded ? "max-h-screen opacity-100 ml-5" : "max-h-0 opacity-0 "
          }`}
        >
          <ul
            className={`space-y-1 mt-1  border-gray-200 dark:border-gray-700 ${
              isExpanded ? "pb-2" : ""
            } ${depth === 0 ? "border-l" : ""} ${depth > 0 ? "max-w-full w-[98%]" : ""}`}
          >
            {item.children!.map((child, childIndex) => {
              const childHasChildren =
                child.children && child.children.length > 0;
              return (
                <NavigationItem
                  key={`${child.href}-${child.title}-${childIndex}`}
                  item={child}
                  depth={depth + 1}
                  {...(childHasChildren && {
                    isExpanded: expandedChild === child.title,
                    onToggle: () => handleChildToggle(child.title),
                  })}
                />
              );
            })}
          </ul>
        </div>
      </li>
    );
  }

  return (
    <li>
      <Link
        href={item.href}
        className="block ml-1 px-3 py-2 hover:bg-sidebar-border rounded-md max-w-full w-13/14 text-sm transition-colors"
      >
        {item.title}
      </Link>
    </li>
  );
}
```

##### Explaination of the Code

The `Sidebar` component manages the sidebar's open/close state and renders the navigation sections. The `NavigationSection` component displays each section's title and items, allowing for expansion and collapse of subsections. The `NavigationItem` component handles individual navigation items, including those with children.

The sidebar is styled to be responsive, with a fixed position on larger screens and a toggleable overlay on smaller screens. The navigation items are displayed in a structured manner, allowing users to easily navigate through the documentation.

<BackToTop />

## Adding a Top Navigation Bar

To enhance navigation further, we will add a top navigation bar that provides quick access to different sections of the documentation. This bar will be fixed at the top of the page and will include links to key sections.

```tsx
// Top Navigation Bar
"use client";

import { useNavigation } from "@/hooks/useNavigation";
import {
  flattenNavigationForSearch,
  searchNavigation,
  type SearchResult,
} from "@/utils/search";
import { useTheme } from "next-themes";
import { useEffect, useMemo, useState } from "react";
import SearchResults from "./SearchResults";

interface TopNavbarProps {
  onToggleSidebar: () => void;
}

export default function TopNavbar({ onToggleSidebar }: TopNavbarProps) {
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState<SearchResult[]>([]);
  const [showResults, setShowResults] = useState(false);
  const [mounted, setMounted] = useState(false);
  const { theme, setTheme } = useTheme();
  const { navigation } = useNavigation();

  // Ensure component is mounted before showing theme-dependent content
  useEffect(() => {
    setMounted(true);
  }, []);

  // Flatten navigation for search
  const flattenedNavigation = useMemo(() => {
    return flattenNavigationForSearch(navigation);
  }, [navigation]);

  // Perform search when query changes
  useEffect(() => {
    if (searchQuery.trim()) {
      const results = searchNavigation(flattenedNavigation, searchQuery);
      setSearchResults(results);
      setShowResults(true);
    } else {
      setSearchResults([]);
      setShowResults(false);
    }
  }, [searchQuery, flattenedNavigation]);

  const toggleTheme = () => {
    setTheme(theme === "dark" ? "light" : "dark");
  };

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };

  const handleSearchResultClick = () => {
    setSearchQuery("");
    setShowResults(false);
  };

  const handleSearchBlur = () => {
    // Delay hiding results to allow for clicks
    setTimeout(() => setShowResults(false), 200);
  };

  const handleSearchFocus = () => {
    if (searchQuery.trim() && searchResults.length > 0) {
      setShowResults(true);
    }
  };

  return (
    <header className="sticky top-0 z-30 backdrop-blur-sm bg-opacity-95 dark:bg-opacity-95 border-b border-border h-16 w-full -900">
      <div className="flex items-center justify-between px-4 lg:px-6 py-3">
        {/* Left side - Mobile menu button */}
        <div className="flex items-center">
          <button
            onClick={onToggleSidebar}
            className="lg:hidden hover:bg-gray-100 dark:hover:bg-gray-800 -ml-2 p-2 rounded-md text-gray-500 hover:text-gray-700 dark:hover:text-gray-200 dark:text-gray-400"
            aria-label="Toggle sidebar"
          >
            <svg
              className="h-5 w-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M4 6h16M4 12h16M4 18h16"
              />
            </svg>
          </button>

          {/* Mobile logo - only visible when sidebar is closed */}
          <div className="lg:hidden ml-2">
            <div className="flex items-center space-x-2">
              <span className="font-bold text-lg">Your Name</span>
            </div>
          </div>
        </div>

        {/* Center - Search bar */}
        <div className="flex-1 mx-auto max-w-2xl">
          <div className="relative">
            <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
              <svg
                className="h-4 w-4 text-gray-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                />
              </svg>
            </div>
            <input
              type="text"
              placeholder="Search topics, categories, and pages..."
              value={searchQuery}
              onChange={handleSearchChange}
              onFocus={handleSearchFocus}
              onBlur={handleSearchBlur}
              className="block bg-gray-50 dark:bg-gray-800 pl-10 pr-12 py-2 border border-gray-200 dark:border-gray-700 focus:border-transparent focus:ring-2 focus:ring-emerald-500 rounded-md min-w-[20em] w-full text-gray-900 text-sm dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none"
            />

            {/* Search Results Dropdown */}
            {showResults && (
              <SearchResults
                results={searchResults}
                searchQuery={searchQuery}
                onResultClick={handleSearchResultClick}
              />
            )}
          </div>
        </div>

        {/* Right side - Theme toggle */}
        <div className="flex items-center space-x-4">
          {/* Theme toggle */}
          <button
            onClick={toggleTheme}
            className="hover:bg-gray-100 dark:hover:bg-gray-800 p-2 rounded-md text-gray-500 hover:text-gray-700 dark:hover:text-gray-200 dark:text-gray-400 transition-colors"
            aria-label="Toggle theme"
          >
            {!mounted ? (
              // Placeholder icon while theme is loading
              <div className="h-5 w-5" />
            ) : theme === "dark" ? (
              <svg
                className="h-5 w-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
                />
              </svg>
            ) : (
              <svg
                className="h-5 w-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
                />
              </svg>
            )}
          </button>
        </div>
      </div>
    </header>
  );
}
```

##### Explaination of the Code

The `TopNavbar` component provides a fixed navigation bar at the top of the page. It includes a search input for quick access to topics, a theme toggle button, and a mobile menu button to toggle the sidebar. The `toggleTheme` function switches between light and dark themes using the `next-themes` library.
The search functionality allows users to search through the documentation, displaying results in a dropdown. The theme toggle button switches between light and dark modes, enhancing the user experience based on personal preferences.

How the search functionality works:

- The search results are stored in the `searchResults` state.
- The `useEffect` hook listens for changes in the `searchQuery` and updates the `searchResults` accordingly.
- The `flattenNavigationForSearch` utility function flattens the navigation structure for easier searching.
  - The `handleSearchChange` function updates the search query as the user types.
  - The `handleSearchResultClick` function clears the search query and hides the results when a result is clicked.
  - The `handleSearchBlur` function hides the search results dropdown when the input loses focus, with a slight delay to allow for clicks on results.
  - The `handleSearchFocus` function shows the search results dropdown when the input is focused, provided there are results to display.
- The `searchNavigation` utility function performs the actual search, returning results that match the query.
- The `SearchResults` component displays the results in a dropdown format, allowing users to click on a result to navigate directly to the corresponding page.
  <BackToTop />

## Creating Navigation Links Dynamically

To create navigation links dynamically, we will use the `useNavigation` hook to fetch the navigation data and render the links based on that data. This allows us to easily update the navigation structure without hardcoding links.

This hook will fetch the navigation data from an API route based on the current path and return it in a format that can be used to render the navigation links.

This file will be stored in the `src/hooks` directory and named `useNavigation.ts`. It will handle fetching the navigation data and managing the loading state.

```tsx
// src/hooks/useNavigation.ts
"use client";

import type { NavigationSection } from "@/utils/navigation";
import { useEffect, useState } from "react";
import { usePathname } from "next/navigation";

export function useNavigation() {
  const [navigation, setNavigation] = useState<NavigationSection[]>([]);
  const [loading, setLoading] = useState(true);
  const pathname = usePathname();

  useEffect(() => {
    async function loadNavigation() {
      try {
        // In client-side, we'll fetch from an API route with current path
        const response = await fetch(
          `/api/navigation?path=${encodeURIComponent(pathname)}`
        );
        if (response.ok) {
          const data = await response.json();
          setNavigation(data);
        } else {
          // Fallback to empty navigation if API fails
          setNavigation([]);
        }
      } catch {
        // Fallback to empty navigation if fetch fails
        setNavigation([]);
      } finally {
        setLoading(false);
      }
    }

    loadNavigation();
  }, [pathname]);

  return { navigation, loading };
}
```

##### Explaination of the Code

The `useNavigation` hook fetches the navigation data from an API route based on the current path. It uses the `usePathname` hook from Next.js to get the current path and updates the navigation state accordingly. The hook returns the navigation data and a loading state, which can be used in components to render the navigation links dynamically.

<BackToTop />

### The API Route

Create a folder named `api` in your `src/app` directory. Inside the `api` folder, create a new folder named `navigation`. Inside the `navigation` folder, create a file named `route.ts`. This file will handle the API request to fetch the navigation data based on the current path.

```ts
// src/app/api/navigation/route.ts
import {
  buildNavigationFromFileSystem,
  setExpandedState,
} from "@/utils/navigation";
import { NextResponse } from "next/server";
import { fallbackNav } from "@/utils/fallback";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const currentPath = searchParams.get("path");

    const navigation = await buildNavigationFromFileSystem();

    // Set expanded state based on current path if provided
    if (currentPath) {
      const expandedNavigation = setExpandedState(navigation, currentPath);
      return NextResponse.json(expandedNavigation);
    }

    return NextResponse.json(navigation);
  } catch {
    // Return fallback navigation with expanded state if path provided
    const currentPath = new URL(request.url).searchParams.get("path");
    if (currentPath) {
      const { setExpandedState } = await import("@/utils/navigation");
      const expandedFallback = setExpandedState(fallbackNav, currentPath);
      return NextResponse.json(expandedFallback);
    }
    return NextResponse.json(fallbackNav);
  }
}
```

##### Explaination of the Code

The API route fetches the navigation data from the file system using the `buildNavigationFromFileSystem` utility function. It checks if a `path` query parameter is provided and sets the expanded state of the navigation based on that path using the `setExpandedState` function. If an error occurs, it returns a fallback navigation structure.

This allows the sidebar to dynamically adjust its expanded sections based on the current page, providing a better user experience by highlighting the relevant section in the navigation.

<BackToTop />

### The Fallback Navigation

To ensure that the navigation works even if the file system structure is not available, we will create a fallback navigation structure. This will be used when the API fails to fetch the navigation data.

This file should be created in the `src/utils` directory and named `fallback.ts`. It will contain a simple navigation structure that can be used as a fallback.

```ts
// src/utils/fallback.ts
export const fallbackNav = [
  {
    title: "Home",
    href: "/",
  },
  {
    title: "About",
    href: "/about",
  },
  {
    title: "Portfolio",
    href: "/portfolio",
    items: [
      {
        title: "Projects",
        href: "/portfolio/projects",
      },
    ],
  },
  {
    title: "Contact",
    href: "/contact",
  },
];
```

This fallback navigation structure contains basic links to the home, about, portfolio, and contact pages. It can be expanded with more sections and items as needed.

<BackToTop />

### Utility Functions

To support the navigation functionality, we will create utility functions that handle the navigation structure and state management. These functions will be used to build the navigation from the file system and set the expanded state based on the current path.

```ts
// src/utils/navigation.ts
import fs from "fs";
import path from "path";
import { fallbackNav } from "./fallback";

export interface NavigationItem {
  title: string;
  href: string;
  children?: NavigationItem[];
  icon?: string;
  order?: number;
  isExpanded?: boolean;
}

export interface NavigationSection {
  title: string;
  items?: NavigationItem[];
}
```

##### Explaination of the Code

- The `NavigationItem` and `NavigationSection` interfaces define the structure of the navigation items and sections. Each item can have a title, href, optional children, an icon, an order for sorting, and an expanded state.
  - The `NavigationSection` interface represents a section of the navigation, which can contain multiple items.
  - The `fallbackNav` is imported from the fallback file, which provides a default navigation structure in case the file system navigation fails.

<br />
<br />
<br />

```ts
// src/utils/navigation.ts
// Function to convert file/folder names to display titles
export function formatTitle(name: string): string {
  return name
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}
```

##### Explaination of the Code

- The `formatTitle` function takes a file or folder name and converts it into a more readable title by capitalizing the first letter of each word and replacing hyphens with spaces. This is useful for displaying navigation titles in a user-friendly format.
- The function splits the name by hyphens, capitalizes the first letter of each word, and then joins them back together with spaces.
- This ensures that titles are displayed in a consistent and readable manner in the navigation sidebar.
  <BackToTop />

<br />
<br />
<br />

```ts
// src/utils/navigation.ts
// Function to read metadata from MDX files
export async function readMDXMetadata(
  filePath: string
): Promise<{ title?: string; order?: number }> {
  try {
    if (typeof window !== "undefined") {
      // Client-side: return empty metadata
      return {};
    }

    const content = fs.readFileSync(filePath, "utf-8");
    const metadata: { title?: string; order?: number } = {};

    // Extract frontmatter (if any)
    const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);

    if (match) {
      const frontmatter = match[1];
      const titleMatch = frontmatter.match(/title:\s*["'](.+)["']/);
      const orderMatch = frontmatter.match(/order:\s*(\d+)/);

      if (titleMatch) metadata.title = titleMatch[1];
      if (orderMatch) metadata.order = parseInt(orderMatch[1]);
    }

    // If no title in frontmatter, look for first h1
    if (!metadata.title) {
      const h1Match = content.match(/^#\s+(.+)$/m);
      if (h1Match) {
        metadata.title = h1Match[1];
      }
    }

    return metadata;
  } catch {
    return {};
  }
}
```

##### Explaination of the Code

- The `readMDXMetadata` function reads metadata from MDX files, specifically looking for the title and order defined in the frontmatter. It uses regular expressions to extract this information.
- If the file contains frontmatter, it extracts the `title` and `order` fields. If the title is not found in the frontmatter, it looks for the first `h1` heading in the content as a fallback.
- The function returns an object containing the title and order, which can be used to populate the navigation items.

<br />
<br />
<br />

```ts
// src/utils/navigation.ts
async function scanDirectory(
  dirPath: string,
  basePath: string
): Promise<NavigationItem[]> {
  const items: NavigationItem[] = [];

  try {
    const entries = fs.readdirSync(dirPath, { withFileTypes: true });

    for (const entry of entries) {
      if (
        entry.name.startsWith(".") ||
        entry.name === "globals.css" ||
        entry.name === "favicon.ico" ||
        entry.name === "layout.tsx"
      ) {
        continue;
      }

      const fullPath = path.join(dirPath, entry.name);
      const routePath = basePath + "/" + entry.name;

      if (entry.isDirectory()) {
        // Check if directory has a page file
        const pageFiles = ["page.tsx", "page.mdx", "page.js"];
        const hasPage = pageFiles.some((file) =>
          fs.existsSync(path.join(fullPath, file))
        );

        if (hasPage) {
          // Directory with a page file
          const pageFile = pageFiles.find((file) =>
            fs.existsSync(path.join(fullPath, file))
          );
          const pagePath = path.join(fullPath, pageFile!);
          const metadata = await readMDXMetadata(pagePath);

          const item: NavigationItem = {
            title: metadata.title || formatTitle(entry.name),
            href: routePath === "/page" ? "/" : routePath,
            order: metadata.order,
          };

          // Check for children
          const children = await scanDirectory(fullPath, routePath);
          if (children.length > 0) {
            item.children = sortNavigationItems(children);
          }

          items.push(item);
        } else {
          // Directory without page file, scan for children
          const children = await scanDirectory(fullPath, routePath);
          if (children.length > 0) {
            items.push({
              title: formatTitle(entry.name),
              href: "#",
              children: sortNavigationItems(children),
            });
          }
        }
      } else if (entry.name === "page.mdx" || entry.name === "page.tsx") {
        // Skip individual page files as they're handled by directory scanning
        continue;
      }
    }

    // Sort items using the helper function
    const sortedItems = sortNavigationItems(items);

    return sortedItems;
  } catch (error) {
    console.error("Error scanning directory:", dirPath, error);
    return [];
  }
}
```

##### Explaination of the Code

- The `scanDirectory` function recursively scans a directory for MDX files and directories containing page files. It constructs a navigation item for each directory that contains a page file and collects child items for directories that have subdirectories or additional pages.
- It skips hidden files and specific files like `globals.css`, `favicon.ico`, and `layout.tsx` to avoid cluttering the navigation.
- If a directory contains a page file, it reads the metadata from that file and creates a navigation item with the title and href. If the directory has children, it recursively scans those children and adds them to the navigation item.
- The function returns a sorted array of navigation items, which can be used to build the navigation structure.
- The `sortNavigationItems` function is used to sort the items based on their order or title.
- The `formatTitle` function is used to format the titles of the navigation items.
- The `readMDXMetadata` function is used to read the metadata from the MDX files, extracting the title and order for each item.
  <BackToTop />

<br />
<br />
<br />

```ts
// src/utils/navigation.ts
// Function to set expanded state based on current URL
export function setExpandedState(
  sections: NavigationSection[],
  currentPath: string
): NavigationSection[] {
  const normalizedPath = currentPath.startsWith("/")
    ? currentPath
    : `/${currentPath}`;

  return sections.map((section) => ({
    ...section,
    items: section.items.map((item) =>
      setItemExpandedState(item, normalizedPath)
    ),
  }));
}
```

##### Explaination of the Code

- The `setExpandedState` function takes the navigation sections and the current path as arguments. It normalizes the current path to ensure it starts with a `/`.
- It then maps over each section and sets the expanded state for each item using the `setItemExpandedState` function, which checks if the current path is in the subtree of the item.
- This allows the sidebar to automatically expand the relevant sections based on the current page, providing a better user experience by highlighting the active section in the navigation.

<br />
<br />
<br />

```ts
// src/utils/navigation.ts
function setItemExpandedState(
  item: NavigationItem,
  currentPath: string
): NavigationItem {
  const shouldExpand = isPathInSubtree(currentPath, item);

  return {
    ...item,
    isExpanded: shouldExpand,
    children: item.children?.map((child) =>
      setItemExpandedState(child, currentPath)
    ),
  };
}
```

##### Explaination of the Code

- The `setItemExpandedState` function checks if the current path is in the subtree of the given item using the `isPathInSubtree` function. If it is, it sets the `isExpanded` property to `true` for that item.
- It recursively applies this logic to any children of the item, ensuring that all relevant items are expanded based on the current path.
  <BackToTop />

<br />
<br />
<br />

```ts
// src/utils/navigation.ts
function isPathInSubtree(currentPath: string, item: NavigationItem): boolean {
  // Check if current path matches this item exactly
  if (currentPath === item.href) {
    return true;
  }

  // Check if current path is a child of this item
  if (currentPath.startsWith(item.href + "/")) {
    return true;
  }

  // Check if any children match
  if (item.children) {
    return item.children.some((child) => isPathInSubtree(currentPath, child));
  }

  return false;
}
```

##### Explaination of the Code

- The `isPathInSubtree` function checks if the current path matches the item's href or if it is a child of the item. It does this by checking if the current path starts with the item's href followed by a `/`.
- If the item has children, it recursively checks each child to see if the current path is in their subtree as well. This allows the function to determine if the current path is relevant to the item or any of its children, enabling the sidebar to expand the correct sections based on the current page.

<br />
<br />
<br />

```ts
// src/utils/navigation.ts
// Function to get client-side navigation with expanded state
export function getClientSideNavigation(
  currentPath?: string
): NavigationSection[] {
  if (currentPath) {
    return setExpandedState(fallbackNav, currentPath);
  }
  return fallbackNav;
}
```

##### Explaination of the Code

- The `getClientSideNavigation` function returns the fallback navigation with the expanded state set based on the current path if provided. If no path is given, it simply returns the fallback navigation without any expanded state.
- This function is useful for client-side rendering where the navigation needs to be adjusted based on the current page without fetching from the server.

<BackToTop />
