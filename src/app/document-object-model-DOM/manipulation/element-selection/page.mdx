import BackToTop from "@/components/BackToTop";

# Element Selection in the DOM

## Table of Contents

## Understanding Element Selection in the DOM

Element selection in the Document Object Model (DOM) is a fundamental aspect of web development that allows developers to interact with and manipulate HTML elements dynamically. This process involves identifying specific elements within the DOM tree structure, enabling developers to apply styles, modify content, and respond to user interactions effectively.

## Basic Selection Methods

```javascript
// Select an element by ID
const elementById = document.getElementById("myElement");

// Select elements by class name (returns HTMLCollection)
const elementsByClass = document.getElementsByClassName("myClass");

// Select elements by tag name (returns HTMLCollection)
const elementsByTag = document.getElementsByTagName("div");

// Select elements by name attribute
const elementsByName = document.getElementsByName("userName");
```

### Modern CSS Selector Methods

```javascript
// Select first element matching CSS selector
const firstElement = document.querySelector(".myClass");
const firstElementById = document.querySelector("#myElement");
const firstElementByTag = document.querySelector("div");
const complexSelector = document.querySelector(
  ".container > .item:first-child"
);

// Select all elements matching CSS selector (returns NodeList)
const allElements = document.querySelectorAll(".myClass");
const allDivs = document.querySelectorAll("div");
const nestedElements = document.querySelectorAll(".parent .child");
```

### Differences Between HTMLCollection and NodeList

```javascript
// HTMLCollection (live collection - updates automatically)
const liveCollection = document.getElementsByClassName("myClass");
console.log(liveCollection.length); // Current count

// NodeList (static collection from querySelectorAll)
const staticList = document.querySelectorAll(".myClass");
console.log(staticList.length); // Count at time of selection

// Converting to Array for better manipulation
const elementsArray = Array.from(liveCollection);
const elementsArray2 = [...staticList];
```

### Advanced Selection Techniques

```javascript
// Pseudo-class selectors
const checkedInputs = document.querySelectorAll("input:checked");
const firstChild = document.querySelector("li:first-child");
const lastChild = document.querySelector("li:last-child");
const nthChild = document.querySelector("li:nth-child(3)");

// Attribute selectors
const requiredInputs = document.querySelectorAll("input[required]");
const externalLinks = document.querySelectorAll("a[href^='http']");
const pdfLinks = document.querySelectorAll("a[href$='.pdf']");

// Combining selectors
const activeButtons = document.querySelectorAll("button.active:not(:disabled)");
```

<BackToTop />

## Advanced DOM Selection Techniques

Beyond basic selection methods, mastering advanced selection techniques enables more precise and efficient DOM manipulation.

### Complex CSS Selectors

```javascript
// Combinators
const directChildren = document.querySelectorAll("ul > li"); // Direct children only
const descendants = document.querySelectorAll("ul li"); // All descendants
const siblings = document.querySelectorAll("h2 + p"); // Adjacent siblings
const generalSiblings = document.querySelectorAll("h2 ~ p"); // General siblings

// Pseudo-classes
const oddRows = document.querySelectorAll("tr:nth-child(odd)");
const evenRows = document.querySelectorAll("tr:nth-child(even)");
const firstOfType = document.querySelectorAll("p:first-of-type");
const lastOfType = document.querySelectorAll("p:last-of-type");

// Structural pseudo-classes
const emptyElements = document.querySelectorAll(":empty");
const notEmpty = document.querySelectorAll(":not(:empty)");
const hasChildren = document.querySelectorAll("div:not(:empty)");
```

### Attribute-Based Selection

```javascript
// Exact attribute match
const exactMatch = document.querySelectorAll("[data-status='active']");

// Attribute contains
const contains = document.querySelectorAll("[class*='btn']");

// Attribute starts with
const startsWith = document.querySelectorAll("[id^='user-']");

// Attribute ends with
const endsWith = document.querySelectorAll("[src$='.jpg']");

// Multiple attribute conditions
const complexQuery = document.querySelectorAll("input[type='text'][required]");

// Case-insensitive matching
const caseInsensitive = document.querySelectorAll("[data-role='Admin' i]");
```

### Performance-Optimized Selection

```javascript
// Cache frequently used elements
const cache = {
  container: document.getElementById("main-container"),
  sidebar: document.getElementById("sidebar"),
  navigation: document.querySelector("nav"),
};

// Use specific selectors over generic ones
// Faster: document.getElementById("myId")
// Slower: document.querySelector("#myId")

// Limit scope when possible
const container = document.getElementById("container");
const items = container.querySelectorAll(".item"); // Limited scope
// Instead of: document.querySelectorAll("#container .item");

// Use getElementsByClassName for dynamic collections
const dynamicItems = document.getElementsByClassName("dynamic-item");
// This updates automatically when elements are added/removed
```

<BackToTop />

## DOM Traversal Methods

Navigating the DOM tree efficiently is essential for complex manipulations and finding related elements.

### Parent and Ancestor Traversal

```javascript
const element = document.getElementById("myElement");

// Direct parent
const parent = element.parentNode;
const parentElement = element.parentElement; // Preferred (excludes text nodes)

// Find ancestor by selector
const ancestor = element.closest(".container"); // Travels up until match found
const form = element.closest("form"); // Find containing form

// All ancestors
function getAncestors(element) {
  const ancestors = [];
  let current = element.parentElement;

  while (current) {
    ancestors.push(current);
    current = current.parentElement;
  }

  return ancestors;
}
```

### Child and Descendant Traversal

```javascript
// Direct children
const children = element.children; // HTMLCollection of element children
const childNodes = element.childNodes; // NodeList including text nodes

// First and last children
const firstChild = element.firstElementChild;
const lastChild = element.lastElementChild;

// Specific child by index
const secondChild = element.children[1];

// Children by selector
const specificChildren = element.querySelectorAll("> .child-class");

// Check if element has children
if (element.hasChildNodes()) {
  console.log("Element has children");
}

// Count children
const childCount = element.children.length;
```

### Sibling Traversal

```javascript
// Next and previous siblings (element nodes only)
const nextSibling = element.nextElementSibling;
const previousSibling = element.previousElementSibling;

// Next and previous siblings (including text nodes)
const nextNode = element.nextSibling;
const previousNode = element.previousSibling;

// Get all siblings
function getSiblings(element) {
  const siblings = [];
  const parent = element.parentElement;

  if (!parent) return siblings;

  Array.from(parent.children).forEach((child) => {
    if (child !== element) {
      siblings.push(child);
    }
  });

  return siblings;
}

// Get siblings before/after current element
function getSiblingsAfter(element) {
  const siblings = [];
  let current = element.nextElementSibling;

  while (current) {
    siblings.push(current);
    current = current.nextElementSibling;
  }

  return siblings;
}
```

### Advanced Traversal Patterns

```javascript
// Find all elements matching criteria within subtree
function findDescendants(root, predicate) {
  const results = [];

  function traverse(node) {
    if (predicate(node)) {
      results.push(node);
    }

    Array.from(node.children).forEach(traverse);
  }

  Array.from(root.children).forEach(traverse);
  return results;
}

// Usage
const visibleDivs = findDescendants(
  document.body,
  (el) => el.tagName === "DIV" && el.style.display !== "none"
);

// Walk DOM tree with callback
function walkDOM(node, callback) {
  callback(node);

  for (let child of node.children) {
    walkDOM(child, callback);
  }
}

// Usage
walkDOM(document.body, (element) => {
  if (element.classList.contains("highlight")) {
    element.style.backgroundColor = "yellow";
  }
});
```

<BackToTop />
