import BackToTop from "@/components/BackToTop";

# DOM Events

## Table of Contents

## Introduction to DOM Events

The Document Object Model (DOM) Events API provides a structured way to handle user interactions and system-generated events within web applications. This API allows developers to create dynamic, interactive experiences by responding to actions such as clicks, key presses, and other user inputs. Understanding how to effectively utilize DOM events is essential for building responsive and engaging web applications.

## Strategic Importance of DOM Events in Web Development

DOM events are a fundamental aspect of modern web development, enabling developers to create interactive and responsive user interfaces. Mastering DOM events is crucial for several reasons:

- **User Interaction**: DOM events allow developers to respond to user actions, such as clicks, key presses, and mouse movements, creating a dynamic user experience.
- **Event-Driven Architecture**: The event-driven nature of DOM events enables developers to build applications that react to user inputs and system changes, enhancing responsiveness and interactivity.
- **Separation of Concerns**: By using event listeners, developers can separate the logic of handling user interactions from the rest of the application code, promoting cleaner and more maintainable code structures.
- **Cross-Browser Compatibility**: The DOM Events API provides a standardized way to handle events across different browsers, ensuring consistent behavior and reducing compatibility issues.

## Core DOM Events and Their Usage

Understanding the core DOM events and their usage is essential for building interactive web applications. Here are some of the most commonly used DOM events:
| Event Type | Description |
| ---------------- | --------------------------------------------------------------------------- |
| `click` | Triggered when an element is clicked by the user. |
| `dblclick` | Triggered when an element is double-clicked by the user. |
| `mouseover` | Triggered when the mouse pointer enters an element. |
| `mouseout` | Triggered when the mouse pointer leaves an element. |
| `keydown` | Triggered when a key is pressed down. |
| `keyup` | Triggered when a key is released. |
| `submit` | Triggered when a form is submitted. |
| `change` | Triggered when the value of an input element changes. |
| `focus` | Triggered when an element receives focus. |
| `blur` | Triggered when an element loses focus. |
| `load` | Triggered when a resource, such as an image or script, has finished loading. |
| `resize` | Triggered when the browser window is resized. |
| `scroll` | Triggered when an element is scrolled. |
| `contextmenu` | Triggered when the right mouse button is clicked, opening the context menu. |
| `drag` | Triggered when an element is being dragged. |
| `drop` | Triggered when a dragged element is dropped onto a valid drop target. |
| `touchstart` | Triggered when a touch point is placed on the touch surface. |
| `touchmove` | Triggered when a touch point is moved along the touch surface. |
| `touchend` | Triggered when a touch point is removed from the touch surface. |
| `animationstart` | Triggered when a CSS animation starts. |
| `animationend` | Triggered when a CSS animation ends. |
| `transitionend` | Triggered when a CSS transition ends. |

## Example: Adding Event Listeners

The `.addEventListener()` method in JavaScript is your go-to tool for attaching an event handler to a specified element. This versatile method lets you listen for a wide range of events—think clicks, key presses, form submissions, and more—and execute a function in response.

```javascript
element.addEventListener(eventType, eventHandler, options);
```

- **element**: The DOM element you want to attach the event to
- **eventType**: The type of event you want to listen for (e.g., click, keydown, submit, etc.)
- **eventHandler**: The function that gets executed when the event occurs
- **options**: (Optional) An object specifying characteristics like capture, once, or passive

```javascript
// Mouse events
element.addEventListener("click", handleClick);
element.addEventListener("dblclick", handleDoubleClick);
element.addEventListener("mousedown", handleMouseDown);
element.addEventListener("mouseup", handleMouseUp);
element.addEventListener("mouseover", handleMouseOver);
element.addEventListener("mouseout", handleMouseOut);
element.addEventListener("mousemove", handleMouseMove);

// Keyboard events
document.addEventListener("keydown", handleKeyDown);
document.addEventListener("keyup", handleKeyUp);
document.addEventListener("keypress", handleKeyPress);

// Form events
form.addEventListener("submit", handleSubmit);
input.addEventListener("change", handleChange);
input.addEventListener("input", handleInput); // Fires on every character
input.addEventListener("focus", handleFocus);
input.addEventListener("blur", handleBlur);

// Window events
window.addEventListener("load", handlePageLoad);
window.addEventListener("resize", handleWindowResize);
window.addEventListener("scroll", handleScroll);
window.addEventListener("beforeunload", handleBeforeUnload);
```

### Event Types and Objects

```javascript
// Mouse events
element.addEventListener("click", handleClick);
element.addEventListener("dblclick", handleDoubleClick);
element.addEventListener("mousedown", handleMouseDown);
element.addEventListener("mouseup", handleMouseUp);
element.addEventListener("mouseover", handleMouseOver);
element.addEventListener("mouseout", handleMouseOut);
element.addEventListener("mousemove", handleMouseMove);

// Keyboard events
element.addEventListener("keydown", handleKeyDown);
element.addEventListener("keyup", handleKeyUp);
element.addEventListener("keypress", handleKeyPress);

// Form events
form.addEventListener("submit", handleSubmit);
input.addEventListener("change", handleChange);
input.addEventListener("input", handleInput);
input.addEventListener("focus", handleFocus);
input.addEventListener("blur", handleBlur);

// Event object properties
function handleEvent(event) {
  console.log("Event type:", event.type);
  console.log("Target element:", event.target);
  console.log("Current target:", event.currentTarget);
  console.log("Mouse position:", event.clientX, event.clientY);
  console.log("Key pressed:", event.key);
  console.log("Modifier keys:", {
    ctrl: event.ctrlKey,
    alt: event.altKey,
    shift: event.shiftKey,
  });
}
```

##### Click Event Example

```html
<body>
  <button id="showImageButton">Show Image</button>
  <img
    id="myImage"
    src="https://via.placeholder.com/150"
    alt="Placeholder"
    style="display:none;"
  />
  <script>
    document
      .getElementById("showImageButton")
      .addEventListener("click", function () {
        const img = document.getElementById("myImage");
        // Toggle image visibility
        img.style.display = img.style.display === "none" ? "block" : "none";
      });
  </script>
</body>
```

This example toggles the visibility of an image when a button is clicked.

##### CAUTION

> Frequent DOM manipulations can hurt performance, causing reflows and repaints that slow down your app. To boost efficiency, batch updates, use document fragments, or make changes in memory before updating the DOM. Reducing direct DOM interactions leads to smoother, more responsive applications.

### Event Object Properties

The event object provides essential information about the event that occurred. Here are some key properties:

- `type`: The type of event (e.g., "click", "keydown").
- `target`: The element that triggered the event.
- `currentTarget`: The element to which the event listener is attached.
- `timeStamp`: The time at which the event was created.
- `bubbles`: Indicates whether the event bubbles up through the DOM.
- `cancelable`: Indicates whether the event can be canceled.
- `defaultPrevented`: Indicates whether the default action of the event has been prevented.
- `composed`: Indicates whether the event can cross the shadow DOM boundary.
- `clientX` and `clientY`: The mouse position relative to the viewport (for mouse events).
- `key`: The value of the key pressed (for keyboard events).

These properties allow you to access detailed information about the event, enabling you to implement complex interactions and behaviors in your web applications.

<BackToTop />

## Event Fundamentals

Events are actions or occurrences that happen in the browser, which can be triggered by user interactions or system processes. The DOM Events API provides a way to listen for these events and respond accordingly. Here are some key concepts:

### Basic Event Handling

```javascript
// Method 1: HTML attribute (not recommended)
// <button onclick="handleClick()">Click me</button>

// Method 2: DOM property
const button = document.getElementById("myButton");
button.onclick = function (event) {
  console.log("Button clicked!");
};

// Method 3: addEventListener (recommended)
button.addEventListener("click", function (event) {
  console.log("Button clicked with addEventListener!");
});

// Arrow function syntax
button.addEventListener("click", (event) => {
  console.log("Button clicked with arrow function!");
});

// Named function for reusability
function handleButtonClick(event) {
  console.log("Button clicked with named function!");
}
button.addEventListener("click", handleButtonClick);
```

### Event Listeners

Event listeners are functions that are executed in response to specific events. They can be added to any DOM element using the `addEventListener` method. This method takes two arguments: the event type (e.g., "click", "keydown") and the callback function that will be executed when the event occurs.

```javascript
// Basic event listener
const button = document.querySelector("#myButton");

button.addEventListener("click", function (event) {
  console.log("Button clicked!");
  console.log("Event type:", event.type);
  console.log("Target element:", event.target);
});

// Arrow function syntax
button.addEventListener("click", (event) => {
  console.log("Button clicked with arrow function!");
});

// Named function (easier to remove later)
function handleButtonClick(event) {
  console.log("Button clicked with named function!");
}

button.addEventListener("click", handleButtonClick);

// Remove event listener
button.removeEventListener("click", handleButtonClick);
```

### Removing Event Listeners

To stop listening for an event, you can remove the event listener using the `removeEventListener` method. This method requires the same event type and callback function that was used to add the listener.

```javascript
// Remove an event listener
function handleButtonClick(event) {
  console.log("Button clicked!", event);
}
button.addEventListener("click", handleButtonClick);
// Later, remove the event listener
button.removeEventListener("click", handleButtonClick);
```

### Event Handling

Here's an example of a comprehensive event handler that demonstrates how to access various properties of the event object:

```html
<button id="myButton">Click Me!</button>
```

```javascript
// Comprehensive event handler
function handleButtonClick(event) {
  console.log("Button clicked!");
  console.log("Event type:", event.type);
  console.log("Target element:", event.target);
  console.log("Current target:", event.currentTarget);
  console.log("Event coordinates:", {
    x: event.clientX,
    y: event.clientY,
  });
  // Prevent default action if necessary
  event.preventDefault();
  // Stop propagation if necessary
  event.stopPropagation();
}
const button = document.querySelector("#myButton");
button.addEventListener("click", handleButtonClick);
```

### Event Delegation

Event delegation is a powerful technique that allows you to handle events at a higher level in the DOM hierarchy, rather than attaching event listeners to individual elements. It simplifies event handling by attaching a single listener to a parent element instead of adding listeners to each child. This boosts performance and makes it easier to manage dynamic content. This is particularly useful for dynamically generated content or when you have many similar elements. By attaching a single event listener to a parent element, you can manage events for all child elements that match a specific selector.

```html
<ul id="myList">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

```javascript
// Instead of adding listeners to many child elements,
// add one listener to the parent and check the target
const list = document.querySelector("#myList");

list.addEventListener("click", function (event) {
  // Check if clicked element is a list item
  if (event.target.tagName === "LI") {
    console.log("List item clicked:", event.target.textContent);
    event.target.classList.toggle("selected");
  }

  // Or use closest() to find the nearest matching ancestor
  const listItem = event.target.closest("li");
  if (listItem) {
    console.log("Clicked on or inside list item:", listItem.textContent);
  }
});

// This works even for dynamically added elements!
const newItem = document.createElement("li");
newItem.textContent = "New item";
list.appendChild(newItem); // Will respond to clicks automatically
```

##### How It Works:

The listener on the parent checks `event.target` to see which child triggered the event, allowing you to handle multiple elements with one listener:

```html
<div id="parent">
  <button>Button 1</button>
  <button>Button 2</button>
  <button>Button 3</button>
</div>
<script>
  document.getElementById("parent").addEventListener("click", function (event) {
    if (event.target.tagName === "BUTTON") {
      console.log("Clicked on:", event.target.textContent);
    }
  });
</script>
```

## Understanding Event Flow

Event flow refers to the order in which events are processed in the Document Object Model (DOM). It consists of two main phases: **capturing** and **bubbling**. Understanding these phases is crucial for effective event handling in JavaScript.

### Capturing Phase

The **capturing phase** begins at the top of the DOM, starting from the window or document, and travels down the DOM tree to the target element. It's less commonly used than bubbling but handy when you want to catch an event before it reaches a specific element.

> Think of it like a security checkpoint, where you can intercept the event before it gets to its final destination!

```javascript
// Capturing phase example
document.getElementById("parent").addEventListener(
  "click",
  () => {
    console.log("Parent clicked (capturing)");
  },
  true, // Use capture phase
);
document.getElementById("child").addEventListener("click", (event) => {
  console.log("Child clicked (capturing)");
  // event.stopPropagation(); // Prevents bubbling to parent
});
```

##### How It Works:

An event listener can be attached to the parent elements to handle events during this phase. By setting the third argument of addEventListener to true, you indicate that the listener should respond during the capturing phase.

```html
<div id="outer" style="padding: 50px; background: lightgray;">
  <div id="inner" style="padding: 20px; background: gray;">Click Me!</div>
</div>
<script>
  document.getElementById("outer").addEventListener(
    "click",
    function (event) {
      console.log("Outer div clicked during capturing phase!");
    },
    true,
  ); // Capturing phase

  document.getElementById("inner").addEventListener("click", function (event) {
    console.log("Inner div clicked!");
  });
</script>
```

In this example, clicking the inner div first triggers the capturing listener on the outer div, followed by the listener on the inner div.

### Bubbling Phase

The **bubbling phase** happens after an event reaches its target element. Once triggered, the event "bubbles up" through the DOM hierarchy, from the target back to the window.

> It's like dropping a pebble in a pond—after hitting the water (target), the ripples move outward (up the DOM).

By default, event listeners handle events during this phase, making it the go-to phase for most event handling in JavaScript.

```javascript
// Bubbling phase example
document.getElementById("parent").addEventListener("click", () => {
  console.log("Parent clicked (bubbling)");
});
document.getElementById("child").addEventListener("click", (event) => {
  console.log("Child clicked (bubbling)");
  // event.stopPropagation(); // Prevents bubbling to parent
});
```

##### How It Works:

By default, when you attach an event listener without specifying the phase, it operates in the bubbling phase.

```html
<div id="outer" style="padding: 50px; background: lightgray;">
  <div id="inner" style="padding: 20px; background: gray;">Click Me!</div>
</div>
<script>
  // Bubbling phase by default
  document.getElementById("outer").addEventListener("click", function (event) {
    console.log("Outer div clicked during bubbling phase!");
  });

  document.getElementById("inner").addEventListener("click", function (event) {
    console.log("Inner div clicked!");
  });
</script>
```

### Event Propagation and Control

```javascript
// Event bubbling example
document.getElementById("parent").addEventListener("click", () => {
  console.log("Parent clicked");
});

document.getElementById("child").addEventListener("click", (event) => {
  console.log("Child clicked");
  // event.stopPropagation(); // Prevents bubbling to parent
});

// Event capturing (useCapture = true)
document.getElementById("parent").addEventListener(
  "click",
  () => {
    console.log("Parent clicked (capturing)");
  },
  true,
);

// Prevent default behavior
document.getElementById("link").addEventListener("click", (event) => {
  event.preventDefault(); // Prevents navigation
  console.log("Link clicked but navigation prevented");
});

// Once option - listener runs only once
button.addEventListener("click", handleClick, { once: true });

// Passive option - improves performance for scroll events
window.addEventListener("scroll", handleScroll, { passive: true });
```

### Safe Removal with Event Cleanup

```javascript
function safeRemoveElement(element) {
  // Remove event listeners before removing element
  element.removeEventListener("click", handleClick);
  element.removeEventListener("change", handleChange);

  // Clear any intervals or timeouts
  if (element.intervalId) {
    clearInterval(element.intervalId);
  }

  // Remove the element
  element.remove();
}

// Example with cleanup
const button = document.getElementById("dynamicButton");
if (button) {
  safeRemoveElement(button);
}
```

## Understanding Default Actions

Default actions are the built-in behaviors of HTML elements that occur when events are triggered. For instance:

- Clicking a hyperlink navigates to a new page
- Submitting a form sends data to the server

### Preventing Default Actions

You can prevent default actions using the `preventDefault()` method, which allows you to implement custom behavior instead of the browser's default action. This is particularly useful for forms, links, and other interactive elements.

```javascript
// Prevent default action of a link
document.getElementById("myLink").addEventListener("click", function (event) {
  event.preventDefault(); // Prevents navigation
  console.log("Link clicked, but navigation prevented!");
});
// Prevent default action of a form submission
document.getElementById("myForm").addEventListener("submit", function (event) {
  event.preventDefault(); // Prevents form submission
  console.log("Form submitted, but default action prevented!");
});
```

##### How It Works:

Call `event.preventDefault()` within the event handler function to stop the default action from occurring:

```html
<a href="https://example.com" id="myLink">Click Me!</a>
<script>
  document.getElementById("myLink").addEventListener("click", function (event) {
    // Prevents navigation
    event.preventDefault();
    console.log("Link clicked, but navigation prevented!");
  });
</script>
```

### Custom Events

Custom events allow you to create and dispatch your own events, which can be useful for decoupling components or triggering specific actions in response to certain conditions. They can carry additional data through the `detail` property. It is a powerful feature for building modular and reusable components.

```javascript
// Create a custom event
const customEvent = new CustomEvent("userLogin", {
  detail: {
    username: "john_doe",
    timestamp: new Date(),
  },
});

// Dispatch the custom event
document.dispatchEvent(customEvent);

// Listen for the custom event
document.addEventListener("userLogin", function (event) {
  console.log("User logged in:", event.detail.username);
  console.log("Login time:", event.detail.timestamp);
});

// More complex custom event
function createNotification(message, type = "info") {
  const event = new CustomEvent("notification", {
    detail: { message, type },
    bubbles: true,
    cancelable: true,
  });

  document.dispatchEvent(event);
}

// Usage
createNotification("User data saved successfully!", "success");
```

<BackToTop />
