import BackToTop from "@/components/BackToTop";

# The Currency Provider

## Table of Contents

## Introduction

The Currency Provider is a crucial part of our e-commerce platform, enabling users to view product prices in their preferred currency. This provider will handle currency conversion, formatting, and persistence across sessions.

It will also integrate with the authentication provider to ensure a seamless user experience, allowing users to set their preferred currency and have it persist across sessions.

### Why Currency Management is Critical for Global E-commerce

Currency handling in e-commerce goes far beyond simple number conversion. It's a complex system that impacts:

1. **Customer Trust & Conversion**: Users are 3x more likely to purchase when prices are shown in their local currency
2. **Legal Compliance**: Many countries require prices to be displayed in local currency
3. **Revenue Optimization**: Dynamic pricing strategies based on regional purchasing power
4. **User Experience**: Consistent currency display across all touchpoints
5. **Business Intelligence**: Accurate financial reporting across multiple currencies

### Global E-commerce Statistics

- **73%** of customers prefer to make purchases in their native currency
- **92%** of users abandon carts when forced to calculate foreign exchange manually
- **E-commerce sites** with multi-currency support see **25% higher conversion rates**
- **67%** of international customers expect real-time exchange rates

## International E-commerce Challenges

### Currency-Related UX Problems

1. **Mental Math Barrier**: Users shouldn't calculate exchange rates manually
2. **Price Shock**: Unexpected conversion at checkout leads to abandonment
3. **Trust Issues**: Outdated exchange rates create credibility problems
4. **Comparison Difficulty**: Users can't easily compare prices across products
5. **Payment Processing**: Currency mismatch between display and payment

### Technical Challenges

1. **Rate Accuracy**: Keeping exchange rates current and precise
2. **Performance**: Real-time conversion without UI lag
3. **Fallback Strategies**: Handling API failures gracefully
4. **Precision**: Handling floating-point arithmetic accurately
5. **Caching**: Balancing freshness with performance

## Currency Architecture Overview

### System Components Architecture

```txt showLineNumbers=false
graph TD
    A[CurrencyProvider] --> B[Exchange Rate API]
    A --> C[Fallback Rate System]
    A --> D[Currency Formatter]
    A --> E[Persistence Layer]

    B --> F[Real-time Rates]
    C --> G[Static Rates]
    D --> H[Intl.NumberFormat]
    E --> I[localStorage]

    A --> J[Price Conversion Engine]
    J --> K[USD Base Conversion]
    J --> L[Target Currency Conversion]

    A --> M[Currency Selection]
    M --> N[User Preferences]
    M --> O[Regional Detection]
```

### Data Flow Architecture

1. **Initialization**: Load persisted currency preferences and fetch latest rates
2. **Rate Management**: Continuous updates with fallback mechanisms
3. **Price Conversion**: Real-time conversion using USD as base currency
4. **Formatting**: Culture-aware price display using internationalization APIs
5. **Persistence**: Automatic saving of user preferences and rate caching

### Performance Optimization Strategy

- **Memoization**: Cache conversion results for identical inputs
- **Debouncing**: Limit API calls during rapid currency switches
- **Prefetching**: Load common currency rates proactively
- **Lazy Loading**: Only fetch rates for currencies actually used

## The `import` Statements and Interfaces

```tsx
// src/app/context/currencyContext.tsx
"use client";

import React, { createContext, useContext, useEffect, useState } from "react";

export interface CurrencyRates {
  [key: string]: number;
}

export interface CurrencyData {
  code: string;
  name: string;
  symbol: string;
}

export interface CurrencyContextType {
  currentCurrency: CurrencyData;
  rates: CurrencyRates;
  isLoading: boolean;
  error: string | null;
  setCurrency: (currency: CurrencyData) => void;
  convertPrice: (price: number, fromCurrency?: string) => number;
  formatPrice: (price: number, fromCurrency?: string) => string;
  refreshRates: () => Promise<void>;
}
```

### Explanation of the Code

This interface design represents the foundation of our international currency system, carefully crafted to handle the complexities of global e-commerce.

### Deep Dive into Interface Architecture

#### CurrencyRates Interface Analysis

```tsx
export interface CurrencyRates {
  [key: string]: number;
}
```

##### Design Philosophy:

- **Dynamic Key Structure**: Allows support for any currency code without interface modifications
- **Numeric Precision**: Uses JavaScript numbers for exchange rates (sufficient for most e-commerce use cases)
- **Extensibility**: New currencies can be added without code changes
- **Type Safety**: Ensures rate values are always numeric

###### Real-world Considerations:

- Exchange rates are typically provided with 4-6 decimal places
- JavaScript's number precision is sufficient for currency calculations up to ~15 significant digits
- For financial applications requiring higher precision, consider using libraries like `decimal.js`

##### CurrencyData Interface Analysis

```tsx
export interface CurrencyData {
  code: string; // ISO 4217 currency code (e.g., "USD", "EUR")
  name: string; // Human-readable currency name
  symbol: string; // Currency symbol for display
}
```

###### Standards Compliance:

- **ISO 4217**: International standard for currency codes
- **Unicode Support**: Symbols support international characters (₹, ¥, €)
- **Accessibility**: Names provide screen-reader friendly descriptions
- **Localization Ready**: Structure supports future i18n enhancements

##### CurrencyContextType Interface Analysis

```tsx
export interface CurrencyContextType {
  // State Properties
  currentCurrency: CurrencyData; // Currently selected currency
  rates: CurrencyRates; // All available exchange rates
  isLoading: boolean; // Loading state for UX
  error: string | null; // Error handling for API failures

  // Core Operations
  setCurrency: (currency: CurrencyData) => void; // Currency selection
  convertPrice: (price: number, fromCurrency?: string) => number; // Price conversion
  formatPrice: (price: number, fromCurrency?: string) => string; // Formatted display
  refreshRates: () => Promise<void>; // Manual refresh
}
```

###### Method Design Patterns:

1. **`setCurrency`**: Synchronous operation for immediate UI updates
2. **`convertPrice`**: Pure function for mathematical conversion only
3. **`formatPrice`**: Combines conversion with locale-aware formatting
4. **`refreshRates`**: Async operation with promise-based error handling

###### Optional Parameters Strategy:

```tsx
convertPrice: (price: number, fromCurrency?: string) => number;
```

- **Default Assumption**: Prices are in USD unless specified
- **Flexibility**: Supports conversion from any currency
- **Backwards Compatibility**: Existing code works without modification

### Advanced TSX Patterns

#### Union Types for Error Handling

```tsx
error: string | null;
```

##### Benefits:

- **Explicit Null Handling**: tsx enforces null checks
- **Clear State**: Distinguishes between "no error" (null) and "error message" (string)
- **Type Safety**: Prevents accidental string operations on null values

##### Function Signature Design

```tsx
formatPrice: (price: number, fromCurrency?: string) => string;
```

###### Considerations:

- **Return Type Specificity**: Always returns formatted string for display
- **Parameter Ordering**: Most common parameter (price) comes first
- **Optional Parameters**: Less common parameter (fromCurrency) is optional
- **Default Values**: Handled internally rather than in signature for cleaner API

### Interface Evolution Strategy

The interfaces are designed for future enhancements:

```tsx
// Future enhancement possibilities
export interface EnhancedCurrencyData extends CurrencyData {
  locale?: string; // For regional formatting
  decimalPlaces?: number; // Custom precision per currency
  grouping?: boolean; // Thousand separators
  prefix?: boolean; // Symbol position preference
}

export interface AdvancedCurrencyRates extends CurrencyRates {
  timestamp?: number; // Rate freshness tracking
  source?: string; // Rate provider identification
  spread?: number; // Buy/sell spread for trading
}
```

### Integration with Browser APIs

The interfaces are designed to work seamlessly with modern browser APIs:

```tsx
// Intl.NumberFormat integration
const formatter = new Intl.NumberFormat(locale, {
  style: "currency",
  currency: currentCurrency.code, // Uses our CurrencyData.code
  // Additional options based on currency characteristics
});

// Intl.DisplayNames integration (future enhancement)
const currencyDisplayNames = new Intl.DisplayNames(["en"], {
  type: "currency",
});
```

This design ensures our currency system leverages native browser internationalization capabilities while maintaining type safety and extensibility.

## Currency Constants

```tsx
// src/app/context/currencyContext.tsx
const defaultCurrency: CurrencyData = {
  code: "USD",
  name: "US Dollar",
  symbol: "$",
};

const currencies: CurrencyData[] = [
  { code: "USD", name: "US Dollar", symbol: "$" },
  { code: "EUR", name: "Euro", symbol: "€" },
  { code: "GBP", name: "British Pound", symbol: "£" },
  { code: "JPY", name: "Japanese Yen", symbol: "¥" },
  { code: "AUD", name: "Australian Dollar", symbol: "A$" },
  { code: "CAD", name: "Canadian Dollar", symbol: "C$" },
  { code: "CNY", name: "Chinese Yuan", symbol: "¥" },
  { code: "INR", name: "Indian Rupee", symbol: "₹" },
  { code: "RUB", name: "Russian Ruble", symbol: "₽" },
  { code: "AED", name: "UAE Dirham", symbol: "د.إ" },
  { code: "BMD", name: "Bermudian Dollar", symbol: "$" },
  { code: "MNT", name: "Mongolian Tögrög", symbol: "₮" },
  { code: "BRL", name: "Brazilian Real", symbol: "R$" },
  { code: "VUV", name: "Vanuatu Vatu", symbol: "VT" },
  { code: "ZWL", name: "Zimbabwean Dollar", symbol: "Z$" },
  { code: "ZAR", name: "South African Rand", symbol: "R" },
  { code: "XOF", name: "West African CFA Franc", symbol: "Fr" },
  { code: "MAD", name: "Moroccan Dirham", symbol: "د.م." },
  { code: "WST", name: "Samoan Tālā", symbol: "T" },
  { code: "TZS", name: "Tanzanian Shilling", symbol: "TSh" },
  { code: "UAH", name: "Ukrainian Hryvnia", symbol: "₴" },
  { code: "VND", name: "Vietnamese Đồng", symbol: "₫" },
  { code: "SGD", name: "Singapore Dollar", symbol: "S$" },
  { code: "PLN", name: "Polish Złoty", symbol: "zł" },
  { code: "NOK", name: "Norwegian Krone", symbol: "kr" },
  { code: "MXN", name: "Mexican Peso", symbol: "$" },
  { code: "THB", name: "Thai Baht", symbol: "฿" },
  { code: "KRW", name: "South Korean Won", symbol: "₩" },
  { code: "ISK", name: "Icelandic Króna", symbol: "kr" },
  { code: "CHF", name: "Swiss Franc", symbol: "CHF" },
  { code: "DOP", name: "Dominican Peso", symbol: "RD$" },
  { code: "HKD", name: "Hong Kong Dollar", symbol: "HK$" },
  { code: "IDR", name: "Indonesian Rupiah", symbol: "Rp" },
];
```

### Explanation of the Code

This currency configuration represents a strategic approach to global market coverage, balancing market reach with implementation complexity.

### Currency Selection Strategy

#### Default Currency Analysis

```tsx
const defaultCurrency: CurrencyData = {
  code: "USD",
  name: "US Dollar",
  symbol: "$",
};
```

##### Strategic Rationale:

- **USD as Base**: Most international commerce is priced in USD
- **Exchange Rate Standard**: USD serves as the common conversion base
- **API Compatibility**: Most exchange rate APIs use USD as primary currency
- **Business Logic**: Simplifies accounting and financial reporting

##### Comprehensive Currency Coverage

Our currency selection covers **major economic regions**:

###### Tier 1 - Global Reserve Currencies:

- USD (United States) - World's primary reserve currency
- EUR (European Union) - Second largest reserve currency
- GBP (United Kingdom) - Historic global currency
- JPY (Japan) - Major Asian reserve currency

###### Tier 2 - Major Trading Currencies:

- AUD, CAD - Resource-rich developed economies
- CNY - World's second-largest economy
- CHF - Safe-haven currency

###### Tier 3 - Regional Powers:

- INR (India) - Large emerging market
- BRL (Brazil) - Latin America's largest economy
- RUB (Russia) - Major commodity exporter

###### Tier 4 - Strategic Markets:

- Emerging markets and specialized economies
- Tourism-dependent economies (AED, THB)
- Resource extraction economies (ZAR, NOK)

### Symbol Design Considerations

#### Unicode Support Strategy

```tsx
{ code: "EUR", name: "Euro", symbol: "€" },
{ code: "GBP", name: "British Pound", symbol: "£" },
{ code: "JPY", name: "Japanese Yen", symbol: "¥" },
{ code: "INR", name: "Indian Rupee", symbol: "₹" },
```

##### Technical Implementation:

- **Unicode Compatibility**: All symbols use proper Unicode characters
- **Font Support**: Symbols are widely supported across device fonts
- **Fallback Strategy**: ASCII alternatives available for older systems
- **RTL Support**: Arabic currency symbols (د.إ) support right-to-left display

##### Symbol Disambiguation

Notice how we handle symbol conflicts:

```tsx
{ code: "USD", name: "US Dollar", symbol: "$" },
{ code: "CAD", name: "Canadian Dollar", symbol: "C$" },
{ code: "AUD", name: "Australian Dollar", symbol: "A$" },
{ code: "MXN", name: "Mexican Peso", symbol: "$" },
```

###### Disambiguation Strategy:

- **Regional Prefixes**: C$, A$, HK$ for clarity
- **Context-Aware Display**: Different symbols based on user location
- **ISO Code Fallback**: Always available as unambiguous identifier

### Market Coverage Analysis

#### Geographic Distribution

```javascript
const regionCoverage = {
  "North America": ["USD", "CAD", "MXN"],
  Europe: ["EUR", "GBP", "CHF", "NOK", "PLN", "UAH"],
  Asia: ["JPY", "CNY", "INR", "KRW", "THB", "SGD", "HKD", "IDR", "VND"],
  "Middle East": ["AED", "MAD"],
  Africa: ["ZAR", "XOF", "TZS"],
  Oceania: ["AUD", "VUV", "WST"],
  "South America": ["BRL", "DOP"],
};
```

##### Economic Significance

```javascript
const economicWeight = {
  "Major Economies (GDP > $1T)": [
    "USD",
    "CNY",
    "JPY",
    "EUR",
    "INR",
    "GBP",
    "BRL",
    "CAD",
    "AUD",
  ],
  "Regional Powers": ["MXN", "KRW", "RUB", "CHF", "THB"],
  "Emerging Markets": ["ZAR", "PLN", "UAH", "VND", "IDR"],
  "Specialized Markets": ["AED", "SGD", "HKD", "NOK"],
};
```

### Currency-Specific Formatting Rules

Different currencies have unique formatting requirements:

```tsx
// Zero decimal places for some currencies
const zeroDecimalCurrencies = ["JPY", "KRW", "VND", "IDR"];

// Different grouping patterns
const groupingPatterns = {
  USD: "1,234.56", // Comma thousands, period decimal
  EUR: "1.234,56", // Period thousands, comma decimal (some regions)
  INR: "1,23,456.78", // Indian numbering system
  CHF: "1'234.56", // Apostrophe thousands separator
};

// Symbol positioning
const symbolPositions = {
  USD: "before", // $1.00
  EUR: "after", // 1,00 €
  GBP: "before", // £1.00
  JPY: "before", // ¥100
};
```

### Performance Optimization in Currency Data

#### Memory Efficiency

```tsx
// Efficient storage - only essential data
const currencyData = currencies.reduce(
  (acc, currency) => {
    acc[currency.code] = currency;
    return acc;
  },
  {} as Record<string, CurrencyData>,
);

// Fast lookups O(1) instead of O(n)
const getCurrency = (code: string) => currencyData[code];
```

##### Lazy Loading Strategy

```tsx
// Load only active currencies initially
const activeCurrencies = ["USD", "EUR", "GBP", "JPY"];
const extendedCurrencies = currencies.filter(
  (c) => !activeCurrencies.includes(c.code),
);

// Load extended currencies on demand
const loadExtendedCurrencies = () => {
  return Promise.resolve(extendedCurrencies);
};
```

### Future Extensibility

The currency constants are designed for easy extension:

```tsx
// Cryptocurrency support (future)
const cryptoCurrencies: CurrencyData[] = [
  { code: "BTC", name: "Bitcoin", symbol: "₿" },
  { code: "ETH", name: "Ethereum", symbol: "Ξ" },
  { code: "USDC", name: "USD Coin", symbol: "USDC" },
];

// Regional currency sets (future)
const regionalSets = {
  european: currencies.filter((c) =>
    ["EUR", "GBP", "CHF", "NOK", "PLN"].includes(c.code),
  ),
  asian: currencies.filter((c) =>
    ["JPY", "CNY", "KRW", "INR", "THB"].includes(c.code),
  ),
  americas: currencies.filter((c) =>
    ["USD", "CAD", "BRL", "MXN"].includes(c.code),
  ),
};
```

This strategic currency selection and organization provides the foundation for a truly global e-commerce platform while maintaining performance and user experience standards.

## The `CurrencyContext` Component

```tsx
// src/app/context/currencyContext.tsx
const CurrencyContext = createContext<CurrencyContextType | undefined>(
  undefined,
);

export const useCurrency = () => {
  const context = useContext(CurrencyContext);
  if (!context) {
    throw new Error("useCurrency must be used within a CurrencyProvider");
  }
  return context;
};
```

### Explanation of the Code

This implementation establishes the foundational infrastructure for currency management, following advanced React patterns for context creation and consumption.

### Context Architecture Deep Dive

#### Context Creation Strategy

```tsx
const CurrencyContext = createContext<CurrencyContextType | undefined>(
  undefined,
);
```

##### Advanced Design Patterns:

1. **Undefined Initial Value**: Forces proper provider wrapping and prevents silent failures
2. **Type Union Strategy**: `CurrencyContextType | undefined` enables compile-time safety
3. **Generic Type Parameter**: Ensures tsx knows the exact shape of context data
4. **Fail-Fast Philosophy**: Immediate error detection during development

##### Custom Hook Implementation Analysis

```tsx
export const useCurrency = () => {
  const context = useContext(CurrencyContext);
  if (!context) {
    throw new Error("useCurrency must be used within a CurrencyProvider");
  }
  return context;
};
```

###### Hook Design Benefits:

1. **Encapsulation**: Hides React Context complexity from consumers
2. **Error Boundary**: Clear, actionable error messages for developers
3. **Type Narrowing**: After null check, tsx guarantees non-undefined context
4. **Consistent API**: Single point of access for all currency operations
5. **Development Experience**: Better debugging and error tracking

### Advanced Context Patterns

#### Error Message Strategy

```tsx
throw new Error("useCurrency must be used within a CurrencyProvider");
```

##### Error Design Philosophy:

- **Specific**: Clearly identifies the required provider
- **Actionable**: Tells developers exactly what to do
- **Contextual**: References the specific hook name
- **Development-Friendly**: Helps with debugging and onboarding

##### Type Safety Benefits

```tsx
// Without custom hook (error-prone)
const context = useContext(CurrencyContext);
if (context) {
  // Developer must remember null check
  const { formatPrice } = context;
}

// With custom hook (type-safe)
const { formatPrice } = useCurrency(); // Always defined, no null checks needed
```

### Performance Considerations

#### Context Value Optimization

```tsx
// The provider will need to memoize the context value
const contextValue = useMemo(
  () => ({
    currentCurrency,
    rates,
    isLoading,
    error,
    setCurrency,
    convertPrice,
    formatPrice,
    refreshRates,
  }),
  [currentCurrency, rates, isLoading, error],
);
```

##### Selective Re-rendering

```tsx
// Components can destructure only needed values
const ProductPrice = ({ price }) => {
  const { formatPrice } = useCurrency(); // Only re-renders when formatPrice changes
  return <span>{formatPrice(price)}</span>;
};

const CurrencySelector = () => {
  const { currentCurrency, setCurrency } = useCurrency(); // Different dependencies
  return <CurrencyDropdown value={currentCurrency} onChange={setCurrency} />;
};
```

### Context Consumer Patterns

#### Basic Usage Pattern

```tsx
const ProductCard = ({ product }) => {
  const { formatPrice, currentCurrency } = useCurrency();

  return (
    <div>
      <h3>{product.name}</h3>
      <p className="price">{formatPrice(product.price)}</p>
      <small>Price in {currentCurrency.name}</small>
    </div>
  );
};
```

##### Advanced Usage Pattern

```tsx
const ShoppingCart = () => {
  const { convertPrice, formatPrice, currentCurrency } = useCurrency();
  const { items } = useCart();

  // Calculate totals in current currency
  const total = items.reduce((sum, item) => {
    return sum + convertPrice(item.price * item.quantity);
  }, 0);

  const savings = items.reduce((sum, item) => {
    const originalPrice = convertPrice(item.originalPrice * item.quantity);
    const currentPrice = convertPrice(item.price * item.quantity);
    return sum + (originalPrice - currentPrice);
  }, 0);

  return (
    <div>
      <h2>Shopping Cart</h2>
      {items.map((item) => (
        <CartItem key={item.id} item={item} />
      ))}
      <div className="totals">
        <p>Subtotal: {formatPrice(total)}</p>
        {savings > 0 && (
          <p className="savings">You saved: {formatPrice(savings)}</p>
        )}
      </div>
    </div>
  );
};
```

### Error Handling Integration

#### Component Error Boundaries

```tsx
class CurrencyErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Check if it's a currency context error
    if (error.message.includes("useCurrency must be used within")) {
      return { hasError: true, errorType: "provider" };
    }
    return { hasError: true, errorType: "unknown" };
  }

  render() {
    if (this.state.hasError) {
      if (this.state.errorType === "provider") {
        return (
          <div className="currency-error">
            <h3>Currency System Error</h3>
            <p>This component requires currency functionality.</p>
            <p>Please ensure it's wrapped with CurrencyProvider.</p>
          </div>
        );
      }
    }

    return this.props.children;
  }
}
```

##### Development VS Production Error Handling

```tsx
const useCurrency = () => {
  const context = useContext(CurrencyContext);
  if (!context) {
    const error = new Error(
      "useCurrency must be used within a CurrencyProvider",
    );

    // In development, throw immediately for debugging
    if (process.env.NODE_ENV === "development") {
      throw error;
    }

    // In production, log error and return safe defaults
    console.error(error);
    return {
      currentCurrency: { code: "USD", name: "US Dollar", symbol: "$" },
      rates: { USD: 1 },
      isLoading: false,
      error: "Currency system unavailable",
      setCurrency: () => {},
      convertPrice: (price) => price,
      formatPrice: (price) => `$${price.toFixed(2)}`,
      refreshRates: async () => {},
    };
  }
  return context;
};
```

This robust context implementation provides the foundation for reliable currency management while maintaining excellent developer experience and type safety throughout the application.

## The `CurrencyProvider` Component

```tsx
// src/app/context/currencyContext.tsx
export const CurrencyProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [currentCurrency, setCurrentCurrency] =
    useState<CurrencyData>(defaultCurrency);
  const [rates, setRates] = useState<CurrencyRates>({});
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchExchangeRates = async () => {
    try {
      setIsLoading(true);
      setError(null);

      const apiKey = process.env.NEXT_PUBLIC_EXCHANGE_RATE_API_KEY;

      // If no API key, use fallback rates immediately
      if (!apiKey) {
        console.warn("Exchange rate API key not found. Using fallback rates.");
        setFallbackRates();
        return;
      }

      const response = await fetch(
        `https://v6.exchangerate-api.com/v6/${apiKey}/latest/USD`,
      );

      if (!response.ok) {
        console.warn(
          `Exchange rate API error: ${response.status}. Using fallback rates.`,
        );
        setFallbackRates();
        return;
      }

      const data = await response.json();

      if (data.result !== "success") {
        console.warn(
          `Exchange rate API error: ${
            data["error-type"] || "Unknown"
          }. Using fallback rates.`,
        );
        setFallbackRates();
        return;
      }

      setRates(data.conversion_rates);
    } catch (err) {
      console.warn("Error fetching exchange rates:", err);
      setFallbackRates();
    } finally {
      setIsLoading(false);
    }
  };

  const setFallbackRates = () => {
    // Use static fallback rates (approximate values as of 2024)
    setRates({
      USD: 1,
      EUR: 0.92,
      GBP: 0.79,
      JPY: 149.5,
      AUD: 1.52,
      CAD: 1.36,
      CNY: 7.23,
      INR: 83.1,
      RUB: 92.5,
      AED: 3.67,
      BMD: 1,
      MNT: 3400,
      BRL: 5.25,
      VUV: 118,
      ZWL: 13000,
      ZAR: 18.5,
      XOF: 602,
      MAD: 10.1,
      WST: 2.7,
      TZS: 2550,
      UAH: 38.4,
      VND: 24300,
      SGD: 1.34,
      PLN: 4.06,
      NOK: 10.6,
      MXN: 17.1,
      THB: 36.2,
      KRW: 1380,
      ISK: 138,
      CHF: 0.89,
      DOP: 58.2,
      HKD: 7.83,
      IDR: 16000,
    });
    setError(null); // Don't show error for fallback rates
  };

  useEffect(() => {
    fetchExchangeRates();

    // Refresh rates every hour
    const interval = setInterval(fetchExchangeRates, 3600000);

    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    // Load saved currency preference from localStorage
    const savedCurrency = localStorage.getItem("preferred-currency");
    if (savedCurrency) {
      try {
        const currency = JSON.parse(savedCurrency);
        const validCurrency = currencies.find((c) => c.code === currency.code);
        if (validCurrency) {
          setCurrentCurrency(validCurrency);
        }
      } catch (err) {
        console.error("Error loading saved currency:", err);
      }
    }
  }, []);

  const setCurrency = (currency: CurrencyData) => {
    setCurrentCurrency(currency);
    localStorage.setItem("preferred-currency", JSON.stringify(currency));
  };

  const convertPrice = (
    price: number,
    fromCurrency: string = "USD",
  ): number => {
    if (!rates || Object.keys(rates).length === 0) {
      return price;
    }

    // Convert from source currency to USD first
    const usdPrice =
      fromCurrency === "USD" ? price : price / rates[fromCurrency];

    // Then convert from USD to target currency
    const convertedPrice = usdPrice * rates[currentCurrency.code];

    return convertedPrice;
  };

  const formatPrice = (price: number, fromCurrency: string = "USD"): string => {
    const convertedPrice = convertPrice(price, fromCurrency);

    // Format based on currency
    const formatter = new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: currentCurrency.code,
      minimumFractionDigits: currentCurrency.code === "JPY" ? 0 : 2,
      maximumFractionDigits: currentCurrency.code === "JPY" ? 0 : 2,
    });

    return formatter.format(convertedPrice);
  };

  const refreshRates = async () => {
    await fetchExchangeRates();
  };

  const contextValue: CurrencyContextType = {
    currentCurrency,
    rates,
    isLoading,
    error,
    setCurrency,
    convertPrice,
    formatPrice,
    refreshRates,
  };

  return (
    <CurrencyContext.Provider value={contextValue}>
      {children}
    </CurrencyContext.Provider>
  );
};

export { currencies };
export default CurrencyContext;
```

### Explanation of the Code

This CurrencyProvider implementation represents a production-ready solution for international e-commerce, incorporating advanced patterns for resilience, performance, and user experience.

### State Management Architecture

#### Multi-layered State Design

```tsx
const [currentCurrency, setCurrentCurrency] =
  useState<CurrencyData>(defaultCurrency);
const [rates, setRates] = useState<CurrencyRates>({});
const [isLoading, setIsLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
```

##### State Design Philosophy:

1. **`currentCurrency`**: User's selected currency preference
   - Initialized with USD for global compatibility
   - Persisted across sessions for UX continuity
   - Validates against supported currencies list

2. **`rates`**: Exchange rate database
   - Object structure for O(1) currency lookups
   - Empty initial state until rates are fetched
   - Supports both live and fallback rate systems

3. **`isLoading`**: Loading state management
   - Prevents UI flash during initial load
   - Enables loading indicators for better UX
   - Coordinates with error states for proper feedback

4. **`error`**: Error state tracking
   - Null indicates no error condition
   - String contains user-friendly error messages
   - Cleared automatically when operations succeed

## Exchange Rate Management

### API Integration Strategy

#### Primary API Integration

```tsx
const fetchExchangeRates = async () => {
  try {
    setIsLoading(true);
    setError(null);

    const apiKey = process.env.NEXT_PUBLIC_EXCHANGE_RATE_API_KEY;

    if (!apiKey) {
      console.warn("Exchange rate API key not found. Using fallback rates.");
      setFallbackRates();
      return;
    }

    const response = await fetch(
      `https://v6.exchangerate-api.com/v6/${apiKey}/latest/USD`,
    );
    // ... error handling and data processing
  } catch (err) {
    console.warn("Error fetching exchange rates:", err);
    setFallbackRates();
  } finally {
    setIsLoading(false);
  }
};
```

##### API Integration Best Practices:

1. **Environment Variable Security**: API keys are not hardcoded
2. **Graceful Degradation**: Fallback system ensures functionality continues
3. **Error Boundary Pattern**: Comprehensive error handling prevents crashes
4. **Loading State Management**: Proper UX feedback during network operations
5. **USD Base Currency**: Consistent with most financial APIs

##### Fallback Rate System

```tsx
const setFallbackRates = () => {
  setRates({
    USD: 1, // Base currency
    EUR: 0.92, // European markets
    GBP: 0.79, // UK market
    JPY: 149.5, // Asian markets
    AUD: 1.52,
    CAD: 1.36,
    CNY: 7.23,
    INR: 83.1,
    RUB: 92.5,
    AED: 3.67,
    BMD: 1,
    MNT: 3400,
    BRL: 5.25,
    VUV: 118,
    ZWL: 13000,
    ZAR: 18.5,
    XOF: 602,
    MAD: 10.1,
    WST: 2.7,
    TZS: 2550,
    UAH: 38.4,
    VND: 24300,
    SGD: 1.34,
    PLN: 4.06,
    NOK: 10.6,
    MXN: 17.1,
    THB: 36.2,
    KRW: 1380,
    ISK: 138,
    CHF: 0.89,
    DOP: 58.2,
    HKD: 7.83,
    IDR: 16000,
  });
  setError(null); // Don't show error for fallback rates
};
```

###### Fallback Strategy Benefits:

1. **Offline Functionality**: App works without internet connectivity
2. **API Reliability**: Continues working when external APIs fail
3. **Development Environment**: No API key required for development
4. **Performance**: Instant rates without network delays
5. **User Experience**: No service interruption during API outages

### Rate Refresh Mechanisms

#### Automatic Refresh System

```tsx
useEffect(() => {
  fetchExchangeRates();

  // Refresh rates every hour
  const interval = setInterval(fetchExchangeRates, 3600000);

  return () => clearInterval(interval);
}, []);
```

##### Refresh Strategy Analysis:

1. **Initial Load**: Fetches rates immediately on provider mount
2. **Hourly Updates**: Balances freshness with API usage limits
3. **Cleanup**: Prevents memory leaks with proper interval cleanup
4. **Background Updates**: Transparent to user experience

##### Manual Refresh Capability

```tsx
const refreshRates = async () => {
  await fetchExchangeRates();
};
```

###### Manual Refresh Benefits:

- User control over rate freshness
- Recovery mechanism for failed automatic updates
- Testing and debugging capabilities
- Premium feature for power users

### Persistence and User Preferences

#### Currency Preference Persistence

```tsx
useEffect(() => {
  const savedCurrency = localStorage.getItem("preferred-currency");
  if (savedCurrency) {
    try {
      const currency = JSON.parse(savedCurrency);
      const validCurrency = currencies.find((c) => c.code === currency.code);
      if (validCurrency) {
        setCurrentCurrency(validCurrency);
      }
    } catch (err) {
      console.error("Error loading saved currency:", err);
    }
  }
}, []);

const setCurrency = (currency: CurrencyData) => {
  setCurrentCurrency(currency);
  localStorage.setItem("preferred-currency", JSON.stringify(currency));
};
```

##### Persistence Strategy Benefits:

1. **User Experience**: Preferences remembered across sessions
2. **Data Validation**: Ensures saved currency is still supported
3. **Error Recovery**: Graceful handling of corrupted data
4. **Immediate Update**: Synchronous state change for responsive UI
5. **Cross-tab Synchronization**: Could be enhanced with storage events

## Currency Conversion Algorithms

### Two-step Conversion Process

#### USD-based Conversion Algorithm

```tsx
const convertPrice = (price: number, fromCurrency: string = "USD"): number => {
  if (!rates || Object.keys(rates).length === 0) {
    return price; // Return original price if no rates available
  }

  // Step 1: Convert source currency to USD
  const usdPrice = fromCurrency === "USD" ? price : price / rates[fromCurrency];

  // Step 2: Convert USD to target currency
  const convertedPrice = usdPrice * rates[currentCurrency.code];

  return convertedPrice;
};
```

##### Algorithm Benefits:

1. **USD Base Standard**: Aligns with international financial practices
2. **Accuracy**: Two-step process maintains precision
3. **Flexibility**: Supports conversion between any currency pair
4. **Fallback Safety**: Returns original price when rates unavailable
5. **Performance**: Simple mathematical operations

##### Precision and Rounding Considerations

```tsx
// Enhanced conversion with precision handling
const convertPriceWithPrecision = (
  price: number,
  fromCurrency: string = "USD",
): number => {
  const converted = convertPrice(price, fromCurrency);

  // Different precision for different currencies
  if (currentCurrency.code === "JPY" || currentCurrency.code === "KRW") {
    return Math.round(converted); // No decimal places
  }

  // Standard 2 decimal places for most currencies
  return Math.round(converted * 100) / 100;
};
```

## Internationalization Patterns

### Advanced Formatting with Intl API

#### Culture-aware Price Formatting

```tsx
const formatPrice = (price: number, fromCurrency: string = "USD"): string => {
  const convertedPrice = convertPrice(price, fromCurrency);

  const formatter = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: currentCurrency.code,
    minimumFractionDigits: currentCurrency.code === "JPY" ? 0 : 2,
    maximumFractionDigits: currentCurrency.code === "JPY" ? 0 : 2,
  });

  return formatter.format(convertedPrice);
};
```

##### Internationalization Features:

1. **Native Browser API**: Uses Intl.NumberFormat for accuracy
2. **Currency-specific Rules**: Different decimal places per currency
3. **Symbol Positioning**: Automatic symbol placement per locale
4. **Grouping Separators**: Correct thousands separators
5. **Regional Variants**: Supports regional formatting differences

##### Enhanced Formatting with Locale Detection

```tsx
// Future enhancement: locale-aware formatting
const formatPriceWithLocale = (
  price: number,
  fromCurrency: string = "USD",
): string => {
  const convertedPrice = convertPrice(price, fromCurrency);

  // Detect user's locale or use currency-specific locale
  const locale = getUserLocale() || getCurrencyLocale(currentCurrency.code);

  const formatter = new Intl.NumberFormat(locale, {
    style: "currency",
    currency: currentCurrency.code,
    minimumFractionDigits: getDecimalPlaces(currentCurrency.code),
    maximumFractionDigits: getDecimalPlaces(currentCurrency.code),
  });

  return formatter.format(convertedPrice);
};

// Helper functions for enhanced formatting
const getCurrencyLocale = (currencyCode: string): string => {
  const localeMap = {
    USD: "en-US",
    EUR: "de-DE",
    GBP: "en-GB",
    JPY: "ja-JP",
    CNY: "zh-CN",
    // ... more mappings
  };
  return localeMap[currencyCode] || "en-US";
};

const getDecimalPlaces = (currencyCode: string): number => {
  const zeroDecimalCurrencies = ["JPY", "KRW", "VND", "CLP"];
  return zeroDecimalCurrencies.includes(currencyCode) ? 0 : 2;
};
```

### Context Value Optimization

#### Memoized Context Value

```tsx
const contextValue: CurrencyContextType = useMemo(
  () => ({
    currentCurrency,
    rates,
    isLoading,
    error,
    setCurrency,
    convertPrice,
    formatPrice,
    refreshRates,
  }),
  [
    currentCurrency,
    rates,
    isLoading,
    error,
    // Functions are stable and don't need dependencies
  ],
);
```

##### Memoization Strategies

##### Function Memoization for Expensive Operations

```tsx
// Memoized conversion function for repeated calculations
const memoizedConvertPrice = useMemo(() => {
  const cache = new Map<string, number>();

  return (price: number, fromCurrency: string = "USD"): number => {
    const cacheKey = `${price}-${fromCurrency}-${currentCurrency.code}`;

    if (cache.has(cacheKey)) {
      return cache.get(cacheKey)!;
    }

    const converted = convertPrice(price, fromCurrency);
    cache.set(cacheKey, converted);

    // Limit cache size to prevent memory leaks
    if (cache.size > 1000) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }

    return converted;
  };
}, [currentCurrency.code, rates]);
```

##### Component-Level Optimization

```tsx
// Optimized price display component
const PriceDisplay = memo(({ price, fromCurrency, className }) => {
  const { formatPrice } = useCurrency();

  // Memoize formatted price to prevent recalculation
  const formattedPrice = useMemo(() => {
    return formatPrice(price, fromCurrency);
  }, [price, fromCurrency, formatPrice]);

  return <span className={className}>{formattedPrice}</span>;
});

// Usage in product lists
const ProductList = ({ products }) => {
  return (
    <div className="product-grid">
      {products.map((product) => (
        <ProductCard key={product.id}>
          <h3>{product.name}</h3>
          <PriceDisplay price={product.price} className="product-price" />
        </ProductCard>
      ))}
    </div>
  );
};
```

### Debouncing and Throttling

#### API Call Optimization

```tsx
// Debounced rate refresh for user-triggered updates
const debouncedRefreshRates = useCallback(
  debounce(async () => {
    await fetchExchangeRates();
  }, 5000), // 5 second debounce
  [],
);

// Throttled currency changes for rapid UI interactions
const throttledSetCurrency = useCallback(
  throttle((currency: CurrencyData) => {
    setCurrentCurrency(currency);
    localStorage.setItem("preferred-currency", JSON.stringify(currency));
  }, 100), // 100ms throttle
  [],
);
```

### Lazy Loading and Code Splitting

#### Dynamic Currency Loading

```tsx
// Lazy load extended currency data
const loadExtendedCurrencies = useMemo(() => {
  return lazy(() =>
    import("./extendedCurrencies").then((module) => ({
      default: () => module.extendedCurrencies,
    })),
  );
}, []);

// Conditional loading based on user region
const getRegionalCurrencies = async (region: string) => {
  const { regionalCurrencies } = await import(`./currencies/${region}`);
  return regionalCurrencies;
};
```

## Caching Strategies

### Multi-layer Caching System

#### Rate Caching Implementation

```tsx
interface CachedRates {
  rates: CurrencyRates;
  timestamp: number;
  ttl: number; // Time to live in milliseconds
}

const CACHE_DURATION = 60 * 60 * 1000; // 1 hour
const CACHE_KEY = "currency-rates-cache";

const getCachedRates = (): CachedRates | null => {
  try {
    const cached = localStorage.getItem(CACHE_KEY);
    if (!cached) return null;

    const cachedData: CachedRates = JSON.parse(cached);
    const now = Date.now();

    // Check if cache is still valid
    if (now - cachedData.timestamp < cachedData.ttl) {
      return cachedData;
    }

    // Cache expired, remove it
    localStorage.removeItem(CACHE_KEY);
    return null;
  } catch (error) {
    console.error("Error reading cached rates:", error);
    return null;
  }
};

const setCachedRates = (rates: CurrencyRates) => {
  const cacheData: CachedRates = {
    rates,
    timestamp: Date.now(),
    ttl: CACHE_DURATION,
  };

  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
  } catch (error) {
    console.error("Error caching rates:", error);
  }
};

// Enhanced fetch with caching
const fetchExchangeRatesWithCache = async () => {
  // Try cache first
  const cachedRates = getCachedRates();
  if (cachedRates) {
    setRates(cachedRates.rates);
    setIsLoading(false);
    return;
  }

  // Fetch from API if no cache
  try {
    setIsLoading(true);
    const response = await fetch(/* API call */);
    const data = await response.json();

    // Update state and cache
    setRates(data.conversion_rates);
    setCachedRates(data.conversion_rates);
  } catch (error) {
    setFallbackRates();
  } finally {
    setIsLoading(false);
  }
};
```

##### Conversion Result Caching

```tsx
class ConversionCache {
  private cache = new Map<string, { result: number; timestamp: number }>();
  private readonly TTL = 5 * 60 * 1000; // 5 minutes

  getCachedConversion(
    price: number,
    fromCurrency: string,
    toCurrency: string,
  ): number | null {
    const key = `${price}-${fromCurrency}-${toCurrency}`;
    const cached = this.cache.get(key);

    if (!cached) return null;

    // Check if cache entry is still valid
    if (Date.now() - cached.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }

    return cached.result;
  }

  setCachedConversion(
    price: number,
    fromCurrency: string,
    toCurrency: string,
    result: number,
  ) {
    const key = `${price}-${fromCurrency}-${toCurrency}`;
    this.cache.set(key, {
      result,
      timestamp: Date.now(),
    });

    // Cleanup old entries periodically
    this.cleanup();
  }

  private cleanup() {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp > this.TTL) {
        this.cache.delete(key);
      }
    }
  }
}

const conversionCache = new ConversionCache();
```

## Error Handling and Resilience

### Comprehensive Error Recovery

#### Network Error Handling

```tsx
const fetchWithRetry = async (
  url: string,
  options: RequestInit,
  retries = 3,
): Promise<Response> => {
  let lastError: Error;

  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url, {
        ...options,
        timeout: 5000, // 5 second timeout
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return response;
    } catch (error) {
      lastError = error as Error;

      // Wait before retrying (exponential backoff)
      if (i < retries - 1) {
        await new Promise((resolve) =>
          setTimeout(resolve, Math.pow(2, i) * 1000),
        );
      }
    }
  }

  throw lastError!;
};

// Enhanced fetch function with retry logic
const fetchExchangeRatesWithRetry = async () => {
  try {
    setIsLoading(true);
    setError(null);

    const apiKey = process.env.NEXT_PUBLIC_EXCHANGE_RATE_API_KEY;
    if (!apiKey) {
      setFallbackRates();
      return;
    }

    const response = await fetchWithRetry(
      `https://v6.exchangerate-api.com/v6/${apiKey}/latest/USD`,
      { method: "GET" },
    );

    const data = await response.json();

    if (data.result !== "success") {
      throw new Error(`API Error: ${data["error-type"] || "Unknown"}`);
    }

    setRates(data.conversion_rates);
    setCachedRates(data.conversion_rates);
  } catch (error) {
    console.error("Failed to fetch exchange rates after retries:", error);
    setError("Unable to update exchange rates. Using cached rates.");
    setFallbackRates();
  } finally {
    setIsLoading(false);
  }
};
```

##### Graceful Degradation Patterns

```tsx
// Safe conversion with fallback
const safeConvertPrice = (
  price: number,
  fromCurrency: string = "USD",
): number => {
  try {
    // Validate inputs
    if (typeof price !== "number" || isNaN(price) || price < 0) {
      console.warn("Invalid price provided for conversion:", price);
      return 0;
    }

    if (!rates || Object.keys(rates).length === 0) {
      console.warn("No exchange rates available, returning original price");
      return price;
    }

    if (!rates[fromCurrency]) {
      console.warn(`Exchange rate not found for currency: ${fromCurrency}`);
      return price;
    }

    if (!rates[currentCurrency.code]) {
      console.warn(
        `Exchange rate not found for target currency: ${currentCurrency.code}`,
      );
      return price;
    }

    return convertPrice(price, fromCurrency);
  } catch (error) {
    console.error("Error during price conversion:", error);
    return price; // Return original price as fallback
  }
};
```

### User-Friendly Error Messages

#### Error State Management

```tsx
interface CurrencyError {
  type: "network" | "api" | "validation" | "cache";
  message: string;
  recoverable: boolean;
  timestamp: number;
}

const setUserFriendlyError = (error: Error, type: CurrencyError["type"]) => {
  const errorMessages = {
    network: "Unable to connect to currency service. Using offline rates.",
    api: "Currency service temporarily unavailable. Rates may be outdated.",
    validation: "Invalid currency data detected. Using default settings.",
    cache: "Unable to save currency preferences. Settings may not persist.",
  };

  const userError: CurrencyError = {
    type,
    message: errorMessages[type],
    recoverable: type !== "validation",
    timestamp: Date.now(),
  };

  setError(userError.message);

  // Log technical details for debugging
  console.error(`Currency ${type} error:`, error);
};
```

## Integration Patterns

### Authentication Provider Integration

#### User-Specific Currency Preferences

```tsx
// Enhanced currency provider with authentication integration
const AuthAwareCurrencyProvider = ({ children }) => {
  const { user } = useAuth();
  const [userCurrencyPrefs, setUserCurrencyPrefs] = useState(null);

  // Load user-specific currency preferences
  useEffect(() => {
    if (user) {
      loadUserCurrencyPreferences(user.id).then((prefs) => {
        if (prefs && prefs.preferredCurrency) {
          const currency = currencies.find(
            (c) => c.code === prefs.preferredCurrency,
          );
          if (currency) {
            setCurrentCurrency(currency);
          }
        }
      });
    } else {
      // No user, fallback to default currency
      setCurrentCurrency(defaultCurrency);
    }
  }, [user]);

  // Sync currency changes with user preferences
  useEffect(() => {
    if (user) {
      updateUserCurrencyPreference(user.id, currentCurrency.code);
    }
  }, [currentCurrency, user]);

  return <CurrencyProvider>{children}</CurrencyProvider>;
};
```

## Next Steps

Next, we will implement the [Cart Provider](/ecommerce-platform/context-and-hooks/creating-context/cartProvider), a critical component responsible for managing all shopping cart operations within the platform.

This provider will:

- **Manage cart state efficiently**:
  Enable users to add, remove, and update items in their shopping cart with immediate feedback.

- **Ensure cart persistence**:
  Maintain cart contents across sessions, so users can resume shopping without losing their selections.

- **Integrate with authentication**:
  Sync cart data with user accounts, providing a seamless experience whether users are logged in or browsing as guests.

- **Support future extensibility**:
  Facilitate integration with checkout processes, promotions, and inventory management systems.

By implementing the Cart Provider, we lay the foundation for a robust and user-friendly shopping experience that encourages conversions and customer satisfaction.

<BackToTop />
