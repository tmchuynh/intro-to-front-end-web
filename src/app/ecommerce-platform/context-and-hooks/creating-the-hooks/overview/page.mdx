import BackToTop from "@/components/BackToTop";

# Overview

## Table of Contents

## Introduction

Custom hooks encapsulate reusable logic and provide a clean way to share stateful logic between components. Our application uses custom hooks for responsive design, authentication guards, order management, clipboard operations, and various utility functions.

Custom hooks are a powerful feature in React that allow you to encapsulate and reuse stateful logic across components. They enable you to create reusable functions that can manage state, handle side effects, and provide a clean API for your components.

## What are Custom Hooks?

Custom hooks are JavaScript functions that start with the prefix `use` and can call other hooks. They allow you to extract component logic into reusable functions, making your code cleaner and more maintainable. Custom hooks can manage state, handle side effects, and provide a consistent API for your components.

## Why Use Custom Hooks?

Custom hooks help you avoid code duplication, improve code organization, and make your components more readable. They allow you to encapsulate complex logic in a single function, making it easier to test and maintain. By using custom hooks, you can share logic between components without having to lift state up or pass props down through multiple levels of the component tree.

## Benefits of Custom Hooks

- **Reusability**: Custom hooks allow you to encapsulate logic that can be reused across multiple components, reducing code duplication.
- **Separation of Concerns**: Custom hooks help you separate logic from UI, making your components cleaner and easier to understand.
- **Testability**: Custom hooks can be tested independently, allowing you to write unit tests for your logic without involving the UI.
- **Consistency**: Custom hooks provide a consistent API for your components, making it easier to use and understand the logic they encapsulate.

## Pre-Built Hooks

We will be creating several custom hooks to handle various functionalities in our e-commerce platform. These hooks will include:

- **useOrderManagement**: A hook to manage order-related operations, such as fetching orders, updating order status, and handling order history.
- **useAuthGuard**: A hook to protect routes and ensure that only authenticated users can access certain pages.
- **useOrderNotifications**: A hook to manage order notifications, such as displaying success or error messages when an order is placed or updated.
- **useProtectedAction**: A hook to handle protected actions that require user authentication, such as placing an order or updating user profile information.
- **usePurchaseHistory**: A hook to manage the user's purchase history, allowing users to view their past orders and details.

We also have `useIsMobile` from `shadcn/ui`, which is a utility hook that helps you determine if a component is mounted. This can be useful for avoiding memory leaks and ensuring that state updates only occur when the component is still mounted. Our `Sidebar` component uses this hook to manage its state and ensure that it only updates when the component is mounted.

Let's examine the `useIsMobile` hook from `shadcn/ui`:

```tsx
// src/hooks/use-mobile.ts
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

/**
 * Custom hook to determine if the current viewport width is considered mobile.
 *
 * This hook uses the `window.matchMedia` API to listen for changes in the viewport width
 * and updates the state accordingly. The mobile breakpoint is defined by the `MOBILE_BREAKPOINT` constant.
 *
 * @returns {boolean} - Returns `true` if the viewport width is less than the mobile breakpoint, otherwise `false`.
 */
export function useIsMobile(): boolean {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}
```

##### Explanation of the `useMounted` Hook

The `useIsMobile` hook uses the `window.matchMedia` API to listen for changes in the viewport width. It sets the initial state based on the current viewport width and updates it whenever the viewport width changes. The hook returns a boolean value indicating whether the current viewport width is considered mobile (less than 768 pixels).

This hook is particularly useful for components that need to adapt their behavior based on the viewport size, such as responsive navigation menus or sidebars.

Within the `SidebarProvider`, `useIsMobile()` is used to determine if the sidebar should be displayed in a mobile-friendly manner. This allows the sidebar to adapt its layout and functionality based on the device being used.

```tsx
// src/components/ui/sidebar.tsx

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean;
    open?: boolean;
    onOpenChange?: (open: boolean) => void;
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile();
    const [openMobile, setOpenMobile] = React.useState(false);

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen);
    const open = openProp ?? _open;
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value;
        if (setOpenProp) {
          setOpenProp(openState);
        } else {
          _setOpen(openState);
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
      },
      [setOpenProp, open]
    );

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open);
    }, [isMobile, setOpen, setOpenMobile]);

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault();
          toggleSidebar();
        }
      };

      window.addEventListener("keydown", handleKeyDown);
      return () => window.removeEventListener("keydown", handleKeyDown);
    }, [toggleSidebar]);

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed";

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    );

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-data-[variant=inset]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    );
  }
);
```

##### Explanation of the `SidebarProvider`

The `SidebarProvider` component uses the `useIsMobile` hook to determine if the current device is mobile. It manages the sidebar's open state and provides a context for the sidebar's state and actions. The component also listens for keyboard shortcuts to toggle the sidebar, making it accessible and user-friendly.

This approach allows the sidebar to adapt its behavior based on the device being used, providing a better user experience across different screen sizes. This is particularly useful for responsive designs where the sidebar may need to collapse or expand based on the viewport size.

## Next Steps

Now that we have an overview of custom hooks and their benefits, we will start implementing our custom hooks for the e-commerce platform starting with the [useAuthGuard hook](/ecommerce-platform/context-and-hooks/creating-the-hooks/useAuthGuard). These hooks will encapsulate the logic for managing orders, authentication, notifications, and other functionalities, making our codebase cleaner and more maintainable.

<BackToTop />