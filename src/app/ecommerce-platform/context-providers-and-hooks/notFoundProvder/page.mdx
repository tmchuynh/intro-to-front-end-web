import BackToTop from "@/components/BackToTop";

# Creating the Not Found Provider

## Table of Contents

## Introduction

The Not Found Provider is a crucial component of our e-commerce platform, designed to handle scenarios where users attempt to access resources that do not exist. This provider will ensure that users receive a friendly and informative message when they encounter a 404 error, while also maintaining SEO best practices.

### Why Do We Need a Not Found Provider?

In an e-commerce platform, users might encounter non-existent pages for various reasons:
- **Product URLs**: Items that are no longer available or have been discontinued
- **Category Pages**: Product categories that have been removed or restructured
- **User Navigation**: Direct URL entry errors or broken external links
- **Search Results**: Links to products that are out of stock or removed

### Benefits of a Centralized Not Found State

1. **Consistent User Experience**: All 404 errors are handled uniformly across the application
2. **SEO Optimization**: Proper 404 handling helps search engines understand your site structure
3. **Analytics Tracking**: Centralized error tracking for business intelligence
4. **Dynamic Recovery**: Ability to suggest alternative products or redirect users to relevant content

## The `import` Statements

```typescript
// src/app/context/NotFoundContext.tsx
"use client";

import { NotFoundContextType } from "@/lib/types/types";
import { createContext, JSX, ReactNode, useContext, useState } from "react";
```

##### Explanation of the `import` Statements

- **`"use client"`**: This directive tells Next.js that this component runs on the client-side, which is necessary for React hooks and state management
- **`createContext`**: Creates a new React context that can be used to share data between components without prop drilling
- **`useContext`**: A React hook that allows components to consume context values
- **`useState`**: A React hook for managing local component state
- **`JSX`**: TypeScript type for JSX elements, ensuring type safety in our component returns
- **`ReactNode`**: TypeScript type that represents any valid React child (elements, strings, numbers, etc.)
- **`NotFoundContextType`**: Custom TypeScript interface that defines the shape of our context data

### Understanding React Context

React Context is a powerful feature that allows you to share state across your entire application without having to pass props down manually at every level. This is particularly useful for global state like authentication status, theme preferences, or in our case, error handling states.

## Using `createContext`

```typescript
// src/app/context/NotFoundContext.tsx
/**
 * Context for managing the state of a "not found" condition.
 *
 * This context can be used to share and update the "not found" status across different components in the application.
 * It is initialized with an `undefined` value, and consumers should check for this value to determine if the context has been properly initialized.
 */
const NotFoundContext = createContext<NotFoundContextType | undefined>(
  undefined
);
```

### Understanding the Context Creation

This code creates a new React context with the following characteristics:

- **Type Safety**: The context is typed as `NotFoundContextType | undefined`, ensuring TypeScript will catch any type mismatches
- **Initial Value**: We initialize the context with `undefined` to detect when the context is accessed outside of a provider
- **Generic Type**: The `<NotFoundContextType | undefined>` syntax tells TypeScript what shape the context data should have

The `undefined` initial value is a defensive programming practice. It allows us to throw meaningful errors when developers try to use the context outside of a provider component.

## NotFoundProvider

```typescript
// src/app/context/NotFoundContext.tsx

/**
 * NotFoundProvider component that provides a context for handling "not found" state.
 *
 * @param {Object} props - The props object.
 * @param {ReactNode} props.children - The child components that will have access to the context.
 *
 * @returns {JSX.Element} The NotFoundContext.Provider component with the provided context value.
 */
export const NotFoundProvider = ({
  children,
}: {
  children: ReactNode;
}): JSX.Element => {
  const [isNotFound, setIsNotFound] = useState(false);

  return (
    <NotFoundContext.Provider
      value={{ isNotFound, setNotFound: setIsNotFound }}
    >
      {children}
    </NotFoundContext.Provider>
  );
};
```

### Breaking Down the NotFoundProvider

Let's examine each part of this provider component:

#### 1. Component Props and TypeScript
```typescript
{
  children,
}: {
  children: ReactNode;
}
```
This uses TypeScript's inline type annotation to specify that the component expects a `children` prop of type `ReactNode`. The destructuring assignment extracts `children` directly from the props object.

#### 2. State Management
```typescript
const [isNotFound, setIsNotFound] = useState(false);
```
We use React's `useState` hook to create a boolean state variable:
- `isNotFound`: The current state value (initially `false`)
- `setIsNotFound`: The function to update the state

#### 3. Context Value Object
```typescript
value={{ isNotFound, setNotFound: setIsNotFound }}
```
The provider passes an object containing:
- `isNotFound`: The current boolean state
- `setNotFound`: A renamed reference to the state setter function

This object structure matches our `NotFoundContextType` interface, ensuring type safety.

#### 4. Provider Pattern
The component wraps its children with `NotFoundContext.Provider`, making the context value available to all descendant components in the React tree.

## `useNotFound` Hook

```typescript
/**
 * Custom hook to access the NotFoundContext.
 *
 * This hook provides the context value from NotFoundContext. It must be used within a NotFoundProvider,
 * otherwise it will throw an error.
 *
 * @throws {Error} If the hook is used outside of a NotFoundProvider.
 *
 * @returns {any} The context value from NotFoundContext.
 */
export const useNotFound = (): any => {
  const context = useContext(NotFoundContext);
  if (!context) {
    throw new Error("useNotFound must be used within a NotFoundProvider");
  }
  return context;
};
```

### Understanding the useNotFound Hook

This custom hook follows a common React pattern for consuming context safely:

#### 1. Context Consumption
```typescript
const context = useContext(NotFoundContext);
```
The `useContext` hook retrieves the current context value. If the component is not wrapped by a `NotFoundProvider`, this will return `undefined`.

#### 2. Error Boundary Pattern
```typescript
if (!context) {
  throw new Error("useNotFound must be used within a NotFoundProvider");
}
```
This defensive check ensures that:
- Developers get clear error messages when they forget to wrap components with the provider
- The hook never returns `undefined`, eliminating the need for null checks in consuming components
- Runtime errors are caught early during development

#### 3. Type Safety Benefits
By throwing an error when context is `undefined`, TypeScript knows that the return value will always be a valid `NotFoundContextType` object, providing better intellisense and compile-time checking.

### Custom Hook Benefits

Creating custom hooks for context consumption provides several advantages:
- **Simplified API**: Components don't need to import both `useContext` and the context object
- **Built-in Error Handling**: Automatic validation that the hook is used correctly
- **Consistent Usage**: All context consumption follows the same pattern
- **Better Developer Experience**: Clear error messages and TypeScript support

## Updating the `providers.tsx` File

Now that we have created the NotFoundProvider and the `useNotFound` hook, we can use it in our application. The provider should be wrapped around the components that need access to the not found state.

The updated `providers.tsx` file will look like this:

```tsx
// src/app/providers.tsx
"use client";

import { ThemeProvider } from "next-themes";
import { JSX, ReactNode } from "react";
import { NotFoundProvider } from "./context/NotFoundContext";

/**
 * Providers component that wraps its children with a ThemeProvider.
 *
 * @param {Object} props - The props object.
 * @param {ReactNode} props.children - The child components to be wrapped by the ThemeProvider.
 *
 * @returns {JSX.Element} The ThemeProvider component wrapping the children.
 */
export function Providers({ children }: { children: ReactNode }): JSX.Element {
  return (
    <ThemeProvider attribute="class" defaultTheme="light" enableSystem={true}>
      {/* Wrap children with NotFoundProvider to provide not found context */}
      <NotFoundProvider>{children}</NotFoundProvider>
    </ThemeProvider>
  );
}
```

### Provider Composition Explained

This implementation demonstrates several important React patterns:

#### 1. Provider Nesting
```tsx
<ThemeProvider>
  <NotFoundProvider>
    {children}
  </NotFoundProvider>
</ThemeProvider>
```
Providers can be nested to combine multiple contexts. The order matters - inner providers can access outer provider values, but not vice versa.

#### 2. Separation of Concerns
Each provider handles a specific aspect of application state:
- `ThemeProvider`: Manages visual theme (light/dark mode)
- `NotFoundProvider`: Manages error state and 404 handling

#### 3. Client-Side Directive
The `"use client"` directive is crucial because:
- React hooks only work in client components
- Context providers need to maintain state across re-renders
- Server-side rendering doesn't support stateful components

### Integration Strategy

This provider composition pattern allows for:
- **Modular Development**: Each provider can be developed and tested independently
- **Flexible Architecture**: New providers can be added without modifying existing ones
- **Performance Optimization**: Only components that need specific context will re-render when that context changes

## Implementation Examples

### Using the NotFound Provider in Components

Here's how you would use the `useNotFound` hook in a product page component:

```tsx
// src/app/products/[id]/page.tsx
"use client";

import { useNotFound } from "@/app/context/NotFoundContext";
import { useEffect } from "react";

export default function ProductPage({ params }: { params: { id: string } }) {
  const { isNotFound, setNotFound } = useNotFound();

  useEffect(() => {
    // Simulate checking if product exists
    const checkProductExists = async () => {
      try {
        const response = await fetch(`/api/products/${params.id}`);
        if (!response.ok) {
          setNotFound(true);
        }
      } catch (error) {
        setNotFound(true);
      }
    };

    checkProductExists();
  }, [params.id, setNotFound]);

  if (isNotFound) {
    return <NotFoundComponent />;
  }

  return <ProductDetails productId={params.id} />;
}
```

### Creating a Global Not Found Handler

```tsx
// src/components/NotFoundHandler.tsx
"use client";

import { useNotFound } from "@/app/context/NotFoundContext";
import Link from "next/link";

export function NotFoundHandler() {
  const { isNotFound, setNotFound } = useNotFound();

  if (!isNotFound) return null;

  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="text-center">
        <h1 className="text-4xl font-bold mb-4">Page Not Found</h1>
        <p className="mb-6">The page you're looking for doesn't exist.</p>
        <div className="space-x-4">
          <Link href="/" className="btn btn-primary">
            Go Home
          </Link>
          <button 
            onClick={() => setNotFound(false)}
            className="btn btn-secondary"
          >
            Try Again
          </button>
        </div>
      </div>
    </div>
  );
}
```

## Best Practices

### 1. Error State Management
- Always reset the not found state when navigating to new pages
- Provide clear feedback to users about what went wrong
- Offer actionable alternatives (suggested products, search, navigation)

### 2. SEO Considerations
- Return proper HTTP 404 status codes for not found pages
- Include meta tags for better search engine understanding
- Implement structured data for 404 pages

### 3. Performance Optimization
- Lazy load not found components to reduce initial bundle size
- Cache not found states for recently checked resources
- Implement proper cleanup in useEffect hooks

### 4. User Experience
- Provide helpful error messages that explain what happened
- Offer multiple recovery paths (search, categories, homepage)
- Track 404 errors for analytics and improvement opportunities

### 5. Testing Strategy
```tsx
// Example test for NotFoundProvider
import { render, screen } from "@testing-library/react";
import { NotFoundProvider, useNotFound } from "./NotFoundContext";

function TestComponent() {
  const { isNotFound, setNotFound } = useNotFound();
  return (
    <div>
      <span>{isNotFound ? "Not Found" : "Found"}</span>
      <button onClick={() => setNotFound(true)}>Set Not Found</button>
    </div>
  );
}

test("should toggle not found state", () => {
  render(
    <NotFoundProvider>
      <TestComponent />
    </NotFoundProvider>
  );
  
  expect(screen.getByText("Found")).toBeInTheDocument();
  fireEvent.click(screen.getByText("Set Not Found"));
  expect(screen.getByText("Not Found")).toBeInTheDocument();
});
```

## Next Steps

Head over to [Creating the Authentication Provider](/ecommerce-platform/context-providers-and-hooks/authProvider) to begin implementing the authentication provider. This will set the foundation for user management and secure access to the platform, establishing the security patterns and architectural principles that will be used throughout all subsequent provider implementations.

### What You've Learned

In this chapter, you've mastered several key concepts:

- **React Context API**: How to create and consume context for global state management
- **TypeScript Integration**: Proper typing for context providers and custom hooks
- **Error Handling Patterns**: Defensive programming with meaningful error messages
- **Provider Composition**: How to nest multiple providers for modular architecture
- **Custom Hook Design**: Creating reusable hooks with built-in validation

### Skills to Apply Next

The Authentication Provider will introduce you to:

- **Advanced State Management**: Complex state objects and reducer patterns
- **Security Best Practices**: Token handling, session management, and secure storage
- **API Integration**: Connecting to authentication services and handling responses
- **Testing Strategies**: Unit testing for complex provider logic with mocked dependencies
- **Performance Optimization**: Memoization and preventing unnecessary re-renders

### Architecture Patterns You'll Encounter

Each subsequent provider will build upon these foundational concepts while introducing new patterns and techniques specific to their domain of responsibility:

1. **State Normalization**: Organizing complex data structures efficiently
2. **Async State Management**: Handling loading states, errors, and data fetching
3. **Cache Strategies**: Implementing intelligent caching for better performance
4. **Event Handling**: Cross-component communication and state synchronization
5. **Persistence Patterns**: Local storage integration and state rehydration

<BackToTop />
