import BackToTop from "@/components/BackToTop";

# Users Settings

## Table of Contents

## The `import` Statements

```tsx
// src/app/dashboard/settings/page.tsx
"use client";

import { fetchUserById } from "@/api";
import { useAuth } from "@/app/context/authContext";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Separator } from "@/components/ui/separator";
import { Switch } from "@/components/ui/switch";
import {
  AddressValidationResult,
  ValidatedAddress,
} from "@/lib/interfaces/address";
import {
  PaymentValidationResult,
  ValidatedPaymentMethod,
} from "@/lib/interfaces/payment";
import { DummyUser } from "@/lib/interfaces/user";
import { formatPostalCode } from "@/lib/utils/format";
import {
  formatExpiryDate,
  maskCardNumber,
  validateAndNormalizePaymentMethod,
  validatePaymentField,
  validatePaymentMethodEnhanced,
} from "@/lib/utils/payment";
import {
  validateAddressEnhanced,
  validateAddressField,
  validateAndNormalizeAddress,
} from "@/lib/utils/validate";
import {
  ArrowLeft,
  Bell,
  Check,
  CreditCard,
  Edit2,
  Lock,
  MapPin,
  Plus,
  Shield,
  Trash2,
  User,
  X,
} from "lucide-react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { toast } from "sonner";
```

### Explanation of the Code

This import section establishes the foundational dependencies for a sophisticated user settings management system within an e-commerce platform. The imports are strategically organized into several categories, each serving distinct functional purposes in creating a secure, accessible, and user-friendly settings interface.

#### Client-Side Rendering Configuration

The `"use client"` directive ensures this component operates entirely on the client side, providing real-time interactivity for settings modifications without server-side rendering delays. This approach is essential for immediate user feedback during form interactions and dynamic state updates.

#### Authentication and User Management Infrastructure

The authentication system imports (`useAuth`, `fetchUserById`, `DummyUser`) establish a robust foundation for user identity verification and profile management. The `useAuth` hook provides access to authentication state, user sessions, and membership management functions, while `fetchUserById` enables dynamic user data retrieval from external APIs for demonstration purposes.

#### UI Component Architecture

The extensive collection of Shadcn UI components creates a consistent, accessible interface framework. Alert dialogs provide secure confirmation mechanisms for critical actions like account deletion or membership cancellation. Form components (Input, Label, Select, Switch) ensure standardized data entry with built-in validation states and accessibility features. Card components organize content into logical sections, improving visual hierarchy and user navigation.

#### Validation and Data Processing Systems

Address and payment validation interfaces (`AddressValidationResult`, `ValidatedAddress`, `PaymentValidationResult`, `ValidatedPaymentMethod`) establish type-safe data structures for secure information processing. Utility functions for formatting (`formatPostalCode`, `formatExpiryDate`, `maskCardNumber`) ensure consistent data presentation while maintaining security standards for sensitive information display.

#### Navigation and State Management

Next.js routing hooks (`useRouter`) enable seamless navigation between settings sections and external pages. React state management hooks (`useState`, `useEffect`) coordinate complex state interactions across multiple form sections, real-time validation, and asynchronous data operations.

#### Security and User Experience Optimization

The import structure demonstrates enterprise-level consideration for security (masked card numbers, validated addresses), accessibility (proper labeling, keyboard navigation), and user experience (real-time validation, loading states, toast notifications). This architecture supports scalable settings management that can accommodate growing user bases and evolving feature requirements.

## The Interfaces

```tsx
// src/lib/interfaces/user.ts
interface SettingsFormData {
  username: string;
  email: string;
  phoneNumber: string;
  currentPassword: string;
  newPassword: string;
  confirmPassword: string;
  firstName: string;
  lastName: string;
  middleName: string;
  address: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
}

interface Address {
  id: string;
  address: string;
  city: string;
  state: string;
  postalCode: string;
  country: string;
  isDefault: boolean;
  isFromAPI: boolean;
}

interface PaymentMethod {
  id: string;
  cardNumber: string;
  cardType: string;
  cardExpire: string;
  cardHolderName: string;
  isDefault: boolean;
  isFromAPI: boolean;
}

interface NotificationSettings {
  emailMarketing: boolean;
  emailOrders: boolean;
  emailSecurity: boolean;
  pushNotifications: boolean;
  smsNotifications: boolean;
}

interface PrivacySettings {
  profileVisibility: "public" | "private" | "friends";
  dataSharing: boolean;
  analyticsTracking: boolean;
  personalizedAds: boolean;
}
```

### Explanation of the Code

This collection of TypeScript interfaces establishes a type system for managing user settings across multiple domains within an e-commerce platform. Each interface serves as a contract that ensures data consistency, enables compile-time validation, and provides clear documentation for the expected data structures throughout the settings management system.

#### Form Data Management Architecture

The `SettingsFormData` interface creates a centralized structure for all user-modifiable profile information. This design consolidates personal details (name fields), contact information (email, phone), security credentials (passwords), and address data into a single, manageable entity. The interface supports both read-only authentication data and editable profile fields, enabling flexible form management that respects system constraints while maximizing user control.

#### Address Management System

The `Address` interface implements a sophisticated address management system with built-in metadata tracking. The `isDefault` flag enables users to designate primary addresses for streamlined checkout processes, while the `isFromAPI` flag distinguishes between user-created addresses and system-imported data from external services. This dual-source approach supports data migration scenarios, API integrations, and prevents users from accidentally modifying critical imported address information.

#### Payment Method Infrastructure

The `PaymentMethod` interface establishes secure payment credential management with metadata tracking similar to the address system. Card information storage follows industry standards for PCI compliance considerations, while the `isDefault` and `isFromAPI` flags provide the same dual-source management capabilities. The interface supports multiple card types and includes cardholder name validation for enhanced security verification.

#### Notification Preferences Framework

The `NotificationSettings` interface creates a granular notification control system that empowers users to customize their communication preferences across multiple channels. Email notifications are categorized by purpose (marketing, orders, security) to provide specific opt-in/opt-out control, while push and SMS notifications offer additional delivery method choices. This approach ensures compliance with privacy regulations while maximizing user engagement through preferred communication channels.

#### Privacy and Data Control System

The `PrivacySettings` interface implements privacy management aligned with modern data protection standards. Profile visibility controls enable social commerce features while respecting user privacy preferences. Data sharing and analytics tracking toggles provide transparency and control over data usage, while personalized advertising settings ensure compliance with advertising consent requirements. This structure supports GDPR, CCPA, and other privacy regulation compliance while maintaining platform functionality.

<BackToTop />

## Constants

```tsx
// src/lib/interfaces/user.ts
const tabs = [
  { id: "profile", label: "Profile & Personal Info", icon: User },
  { id: "security", label: "Security & Password", icon: Lock },
  { id: "notifications", label: "Notifications", icon: Bell },
  { id: "privacy", label: "Privacy & Data", icon: Shield },
  { id: "billing", label: "Billing & Payment", icon: CreditCard },
];
```

## Using the Hooks and Storing Data

```tsx
// src/app/dashboard/settings/page.tsx

export default function SettingsPage() {
  const { user, isLoggedIn, logout, cancelMembership, isMembershipCancelled } =
    useAuth();
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [activeTab, setActiveTab] = useState("profile");

  const [formData, setFormData] = useState<SettingsFormData>({
    username: "",
    email: "",
    phoneNumber: "",
    currentPassword: "",
    newPassword: "",
    confirmPassword: "",
    firstName: "",
    lastName: "",
    middleName: "",
    address: "",
    city: "",
    state: "",
    zipCode: "",
    country: "US",
  });

  const [notifications, setNotifications] = useState<NotificationSettings>({
    emailMarketing: true,
    emailOrders: true,
    emailSecurity: true,
    pushNotifications: false,
    smsNotifications: false,
  });

  const [privacy, setPrivacy] = useState<PrivacySettings>({
    profileVisibility: "private",
    dataSharing: false,
    analyticsTracking: true,
    personalizedAds: false,
  });

  const [userData, setUserData] = useState<DummyUser | null>(null);
  const [addresses, setAddresses] = useState<Address[]>([]);
  const [paymentMethods, setPaymentMethods] = useState<PaymentMethod[]>([]);
  const [newAddress, setNewAddress] = useState<
    Omit<Address, "id" | "isDefault" | "isFromAPI">
  >({
    address: "",
    city: "",
    state: "",
    postalCode: "",
    country: "US",
  });
  const [newPaymentMethod, setNewPaymentMethod] = useState<
    Omit<PaymentMethod, "id" | "isDefault" | "isFromAPI">
  >({
    cardNumber: "",
    cardType: "",
    cardExpire: "",
    cardHolderName: "",
  });
  const [showAddAddress, setShowAddAddress] = useState(false);
  const [showAddPayment, setShowAddPayment] = useState(false);
  const [editingAddress, setEditingAddress] = useState<string | null>(null);
  const [editingPayment, setEditingPayment] = useState<string | null>(null);
  const [editAddressData, setEditAddressData] = useState<
    Omit<Address, "id" | "isDefault" | "isFromAPI">
  >({
    address: "",
    city: "",
    state: "",
    postalCode: "",
    country: "US",
  });
  const [editPaymentData, setEditPaymentData] = useState<
    Omit<PaymentMethod, "id" | "isDefault" | "isFromAPI">
  >({
    cardNumber: "",
    cardType: "",
    cardExpire: "",
    cardHolderName: "",
  });

  // Real-time validation error states
  const [newAddressErrors, setNewAddressErrors] = useState<
    Record<string, string>
  >({});
  const [editAddressErrors, setEditAddressErrors] = useState<
    Record<string, string>
  >({});
  const [newPaymentErrors, setNewPaymentErrors] = useState<
    Record<string, string>
  >({});
  const [editPaymentErrors, setEditPaymentErrors] = useState<
    Record<string, string>
  >({});
```

### Explanation of the Code

This state management architecture establishes the foundation for a sophisticated user settings interface that handles multiple data domains simultaneously. The implementation demonstrates enterprise-level React patterns for managing complex state interactions, real-time validation, and secure data processing within an e-commerce environment.

#### Authentication and Session Management

The `useAuth` hook integration provides centralized access to authentication state, user session management, and membership operations. This approach ensures consistent authentication behavior across the settings interface while enabling secure access to user-specific operations like membership cancellation and account deletion. The `useRouter` hook facilitates seamless navigation management, particularly for authentication-based redirects and post-action routing.

#### Multi-Domain State Architecture

The state management system implements a segmented approach, with separate state containers for different user data domains. The `formData` state manages core profile information with structured field organization, while specialized states handle addresses, payment methods, notifications, and privacy settings. This separation enables independent validation, error handling, and update operations across different settings sections.

#### Dynamic Data Loading and Synchronization

The component implements intelligent data loading that synchronizes user information from multiple sources. Local authentication data provides the baseline user identity, while API integration supplements this with additional profile details, addresses, and payment methods. The fallback mechanisms ensure graceful degradation when API services are unavailable, maintaining user experience continuity.

#### Real-Time Validation Framework

Error state management (`newAddressErrors`, `editAddressErrors`, `newPaymentErrors`, `editPaymentErrors`) enables immediate user feedback during data entry. This approach reduces form submission errors and improves user experience by providing guidance as users interact with form fields. The validation states are tightly coupled with their respective data states to ensure consistency.

#### Edit Mode Management

The editing state system (`editingAddress`, `editingPayment`, `showAddAddress`, `showAddPayment`) provides controlled transitions between view and edit modes. This pattern ensures that only one item can be edited at a time, preventing data conflicts and providing clear user interaction flows. The edit data containers (`editAddressData`, `editPaymentData`) maintain isolated copies of data during editing, allowing users to cancel changes without affecting the original data.

#### Security and Performance Considerations

The state structure implements security best practices by maintaining separation between sensitive data (payment information) and general profile data. Loading states provide user feedback during asynchronous operations, while error boundaries prevent individual section failures from affecting the entire settings interface. This architecture supports scalable user management that can accommodate growing user bases and evolving feature requirements.

<BackToTop />

## Getting User Data

```tsx
// src/app/dashboard/settings/page.tsx
useEffect(() => {
  if (!isLoggedIn) {
    router.push("/login");
    return;
  }

  if (user) {
    // Extract the DummyJSON user ID from the user ID
    let apiUserId = 1; // default fallback

    if (user.id.startsWith("demo-")) {
      // Extract the original DummyJSON user ID
      const demoId = user.id.replace("demo-", "");
      apiUserId = parseInt(demoId) || 1;
    } else {
      // For local users, use a consistent ID based on username hash or default to 1
      apiUserId =
        (Math.abs(
          user.username.split("").reduce((a, b) => {
            a = (a << 5) - a + b.charCodeAt(0);
            return a & a;
          }, 0),
        ) %
          30) +
        1; // Use hash to get a number between 1-30
    }

    // Load user data from DummyJSON API for demo purposes
    fetchUserById(apiUserId)
      .then((apiUser: DummyUser) => {
        setUserData(apiUser);
        setFormData((prev) => ({
          ...prev,
          username: apiUser.username || user.username || "",
          email: apiUser.email || user.email || "",
          phoneNumber: apiUser.phone || user.phoneNumber || "",
          firstName: apiUser.firstName || "",
          lastName: apiUser.lastName || "",
          middleName: "", // Not provided by API
        }));

        // Set addresses from API
        if (apiUser.address) {
          setAddresses([
            {
              id: "1",
              address: apiUser.address.address,
              city: apiUser.address.city,
              state: apiUser.address.state,
              postalCode: apiUser.address.postalCode,
              country: apiUser.address.country,
              isDefault: true,
              isFromAPI: true,
            },
          ]);
        }

        // Set payment methods from API
        if (apiUser.bank) {
          setPaymentMethods([
            {
              id: "1",
              cardNumber: apiUser.bank.cardNumber,
              cardType: apiUser.bank.cardType,
              cardExpire: apiUser.bank.cardExpire,
              cardHolderName: `${apiUser.firstName} ${apiUser.lastName}`,
              isDefault: true,
              isFromAPI: true,
            },
          ]);
        }
      })
      .catch((error: Error) => {
        console.error("Failed to fetch user data:", error);
        // Fallback to just setting the basic user info
        setFormData((prev) => ({
          ...prev,
          username: user.username || "",
          email: user.email || "",
          phoneNumber: user.phoneNumber || "",
        }));
      });
  }
}, [isLoggedIn, user, router]);
```

### Explanation of the Code

This sophisticated data loading system implements a multi-source user data aggregation strategy that combines local authentication state with external API data to create a user profile. The implementation demonstrates enterprise-level patterns for handling data synchronization, fallback mechanisms, and secure user information management within an e-commerce platform.

#### Authentication-Based Access Control

The initial authentication check (`!isLoggedIn`) provides security-first access control that immediately redirects unauthorized users to the login page. This approach prevents unauthorized access to sensitive user settings and ensures that only authenticated users can view or modify their personal information. The early return pattern optimizes performance by preventing unnecessary data loading operations for unauthenticated sessions.

#### Dynamic User ID Resolution

The user ID resolution logic demonstrates flexible identity management that accommodates both demo users and local authentication accounts. Demo users, identified by the "demo-" prefix, map to specific DummyJSON API user records, while local users utilize a hash-based ID generation system that provides consistent API user mapping. This dual approach enables seamless demonstration capabilities while supporting real user account integration.

#### Multi-Source Data Integration

The data loading strategy combines authentication system data with external API responses to create enriched user profiles. The API integration provides demonstration data including addresses and payment methods, while the local authentication system maintains core identity information. Fallback operators (`||`) ensure graceful handling of missing data fields while maintaining form functionality.

#### Structured Data Population

The data population process systematically organizes API responses into the application's data structures. Address information transforms from the API format into the local `Address` interface with appropriate metadata flags (`isDefault`, `isFromAPI`), while payment method data converts bank information into structured `PaymentMethod` objects. This transformation ensures consistent data handling across the application.

#### Error Handling and Resilience

The error handling implementation provides robust fallback mechanisms that maintain user experience even when external services fail. When API calls fail, the system gracefully falls back to populating forms with available authentication data, ensuring users can still access basic settings functionality. Error logging provides debugging capabilities while maintaining user interface stability.

#### Performance and User Experience Optimization

The `useEffect` dependency array ensures data loading occurs only when necessary (authentication state changes), preventing unnecessary API calls and improving application performance. The loading process is non-blocking, allowing the user interface to remain responsive while data synchronization occurs in the background. This approach balances data freshness with user experience quality.

## Handling Access Control

```tsx
// src/app/dashboard/settings/page.tsx

if (!isLoggedIn || !user) {
  return (
    <div className="flex justify-center items-center bg-background min-h-screen">
      <div className="text-center">
        <h1 className="mb-4 font-bold text-2xl">Access Denied</h1>
        <p className="mb-4 text-muted-foreground">
          Please log in to access your settings.
        </p>
        <Button asChild>
          <Link href="/login">Sign In</Link>
        </Button>
      </div>
    </div>
  );
}
```

<BackToTop />

## Handling Settings Changes

### Input Change Handler

```tsx
// src/app/dashboard/settings/page.tsx
const handleInputChange = (field: keyof SettingsFormData, value: string) => {
  setFormData((prev) => ({ ...prev, [field]: value }));
};
```

#### Explanation of the Code

This foundational input management function implements type-safe, real-time form data synchronization that serves as the backbone for user profile editing within the settings interface. The implementation demonstrates enterprise-level React patterns for handling controlled form components while maintaining data integrity and optimal performance.

#### Type-Safe Field Management

The function leverages TypeScript's `keyof` operator to ensure compile-time validation of field names against the `SettingsFormData` interface. This approach prevents runtime errors from invalid field references while providing intelligent autocomplete support during development. The type constraint ensures that only valid form fields can be updated, maintaining data structure integrity across the application.

#### Immutable State Updates

The implementation utilizes React's functional state update pattern with the spread operator to create new state objects rather than mutating existing ones. This approach ensures proper React state change detection, triggering necessary re-renders and maintaining component lifecycle integrity. The immutable update pattern also supports React DevTools debugging and enables potential future integration with state management libraries.

#### Real-Time User Experience

The immediate state updates provide responsive user feedback during form interactions, creating a smooth editing experience that mirrors modern application standards. Users see their changes reflected instantly without waiting for save operations, improving perceived performance and user satisfaction. This pattern supports progressive data entry workflows where users can make multiple edits before committing changes.

#### Performance Optimization

The function's simple signature and minimal processing overhead ensure optimal performance during rapid user input. The absence of validation or formatting logic in this core handler keeps the update cycle lightweight, while specialized handlers manage validation and formatting for specific field types. This separation of concerns enables efficient rendering cycles and responsive user interactions.

#### Integration Foundation

This base handler provides a consistent interface that other form management functions can build upon. Specialized handlers for addresses, payment methods, and other complex data types can utilize this pattern while adding their own validation and formatting logic. The standardized approach simplifies testing, debugging, and maintenance across the settings interface.

### Notifications Change Handler

```tsx
// src/app/dashboard/settings/page.tsx
const handleNotificationChange = (
  field: keyof NotificationSettings,
  value: boolean,
) => {
  setNotifications((prev) => ({ ...prev, [field]: value }));
};

const handleSaveNotifications = async () => {
  setIsLoading(true);
  try {
    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1000));
    toast.success("Notification preferences saved!");
  } catch (error) {
    toast.error("Failed to save preferences. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

#### Explanation of the Code

This notification management system implements user communication preference controls that align with modern privacy standards and user experience expectations. The implementation demonstrates enterprise-level approaches to consent management, preference persistence, and compliance with communication regulations within an e-commerce environment.

#### Granular Preference Management

The `handleNotificationChange` function provides fine-grained control over individual notification types through type-safe boolean state management. Each notification category (email marketing, order updates, security alerts, push notifications, SMS) can be independently controlled, allowing users to customize their communication experience precisely. This granular approach improves user satisfaction by respecting individual preferences while maintaining essential communication channels.

#### Real-Time Preference Updates

The immediate state updates enable users to see their preference changes reflected instantly in the interface, providing clear visual feedback about their selection status. This real-time approach reduces user confusion about current settings and creates confidence in the preference management system. The boolean state handling ensures clear on/off states without ambiguous intermediate values.

#### Asynchronous Preference Persistence

The `handleSaveNotifications` function implements secure, asynchronous preference storage with error handling and user feedback. The loading state management provides clear indication of save progress, while toast notifications confirm successful updates or alert users to problems. This approach ensures users understand when their preferences have been successfully stored and can take corrective action if needed.

#### Compliance and Legal Considerations

The notification system architecture supports compliance with privacy regulations like GDPR, CAN-SPAM, and TCPA by providing clear opt-in/opt-out mechanisms for different communication types. The separate handling of marketing, transactional, and security communications enables proper consent management and regulatory compliance. The persistence layer can be extended to maintain audit trails for compliance reporting.

#### User Experience Optimization

The combination of instant visual feedback and confirmed persistence creates a trustworthy preference management experience. Users can experiment with different settings combinations while knowing their changes are immediately visible and securely stored. The error handling ensures users aren't left wondering whether their preferences were saved, particularly important for privacy-conscious users who want control over their communication experience.

### Privacy Change Handler

```tsx
// src/app/dashboard/settings/page.tsx
const handlePrivacyChange = (field: keyof PrivacySettings, value: any) => {
  setPrivacy((prev) => ({ ...prev, [field]: value }));
};

const handleSavePrivacy = async () => {
  setIsLoading(true);
  try {
    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1000));
    toast.success("Privacy settings saved!");
  } catch (error) {
    toast.error("Failed to save privacy settings. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

#### Explanation of the Code

This privacy management system implements data protection controls that empower users to manage their digital footprint while ensuring compliance with global privacy regulations. The implementation demonstrates enterprise-level approaches to privacy consent management, data sharing controls, and user transparency within modern e-commerce platforms.

#### Flexible Privacy Control Architecture

The `handlePrivacyChange` function accommodates diverse privacy setting types through its flexible `any` value parameter, supporting both boolean toggles (data sharing, analytics tracking) and string-based selections (profile visibility levels). This versatility enables complex privacy control interfaces that can adapt to evolving privacy requirements and regulatory changes without requiring structural modifications to the core handling logic.

#### Multi-Dimensional Privacy Management

The privacy state management system addresses multiple privacy domains simultaneously, including profile visibility for social commerce features, data sharing preferences for third-party integrations, analytics tracking controls for user behavior analysis, and personalized advertising settings for marketing compliance. This approach ensures users have granular control over their data usage across all platform features.

#### Regulatory Compliance Foundation

The `handleSavePrivacy` function implements secure privacy preference persistence that supports compliance with GDPR, CCPA, and other data protection regulations. The asynchronous save operation can be extended to include consent timestamp logging, preference change auditing, and regulatory reporting capabilities. The error handling ensures privacy preferences are reliably stored, which is critical for maintaining compliance and user trust.

#### User Transparency and Control

The immediate state updates combined with persistent storage create a transparent privacy management experience where users understand exactly what data usage they're consenting to. The loading states and confirmation messages build user confidence in the privacy control system, while error handling ensures users know when their privacy preferences haven't been properly saved. This transparency is essential for building trust and meeting regulatory requirements for informed consent.

#### Extensibility for Future Privacy Requirements

The flexible architecture supports future privacy control additions without requiring fundamental changes to the handling logic. As privacy regulations evolve and new data protection requirements emerge, additional privacy settings can be seamlessly integrated into the existing system. This forward-thinking approach ensures the platform can adapt to changing privacy landscapes while maintaining consistent user experience patterns.

### Password Change Handler

```tsx
// src/app/dashboard/settings/page.tsx
const handleChangePassword = async () => {
  if (formData.newPassword !== formData.confirmPassword) {
    toast.error("New passwords don't match!");
    return;
  }
  if (formData.newPassword.length < 8) {
    toast.error("Password must be at least 8 characters long!");
    return;
  }

  setIsLoading(true);
  try {
    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1000));
    toast.success("Password changed successfully!");
    setFormData((prev) => ({
      ...prev,
      currentPassword: "",
      newPassword: "",
      confirmPassword: "",
    }));
  } catch (error) {
    toast.error("Failed to change password. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

#### Explanation of the Code

This secure password management function implements enterprise-level authentication security practices that protect user accounts while providing intuitive password update workflows. The implementation demonstrates validation, security enforcement, and user feedback patterns essential for maintaining account security within e-commerce platforms.

#### Multi-Layer Password Validation

The function implements progressive validation that catches common password security issues before attempting server communication. Password confirmation matching prevents user error-induced security weaknesses, while minimum length requirements enforce basic password strength standards. This client-side validation provides immediate feedback and reduces server load while maintaining security standards that can be expanded to include complexity requirements, common password detection, and breach database checks.

#### Security-First Change Process

The password change workflow follows security best practices by requiring current password verification (implied in form fields) and implementing secure transmission patterns. The asynchronous operation simulates secure API communication that would include proper encryption, rate limiting, and audit logging in production environments. The loading state prevents multiple simultaneous change attempts, reducing the risk of race conditions or duplicate requests.

#### User Experience and Security Balance

The implementation balances robust security requirements with user-friendly feedback mechanisms. Clear error messages guide users toward successful password changes without revealing sensitive security information. Success confirmations provide certainty that changes have been applied, while automatic form field clearing prevents password information from remaining in browser memory longer than necessary.

#### Form State Management and Cleanup

The successful password change triggers form cleanup that removes sensitive information from component state. This approach minimizes the exposure window for password data and prevents accidental password disclosure through form persistence or browser debugging tools. The reset operation returns the form to a clean state, ready for future password change attempts without residual data.

#### Error Handling and Recovery

The error handling system provides graceful recovery from various failure scenarios while maintaining security. Network failures, server errors, and validation failures are all handled with appropriate user feedback that guides recovery actions. The loading state management ensures users understand when operations are in progress and can take appropriate action based on the outcome, building trust in the security system's reliability.

<BackToTop />

## Handling Adding, Removing, and Updating Information

### Adding a New Address

```tsx
// src/app/dashboard/settings/page.tsx
const handleNewAddressChange = (
  field: keyof typeof newAddress,
  value: string,
) => {
  // Format postal code if it's a postal code field
  const formattedValue =
    field === "postalCode" && newAddress.country
      ? formatPostalCode(value, newAddress.country)
      : value;

  setNewAddress((prev) => ({ ...prev, [field]: formattedValue }));

  // Real-time validation - ensure field is a valid ValidatedAddress key
  if (field in newAddress) {
    validateNewAddressField(field as keyof ValidatedAddress, formattedValue);
  }
};
```

#### Explanation of the Code

This intelligent address input management system implements location-aware data formatting and real-time validation that enhances user experience while ensuring address data quality for shipping and billing operations. The implementation demonstrates enterprise-level approaches to international address handling, postal code standardization, and progressive validation within e-commerce address management systems.

#### International Address Format Intelligence

The conditional postal code formatting logic demonstrates sophisticated internationalization support that adapts to different postal code formats based on the selected country. This approach ensures addresses conform to local postal standards, improving delivery success rates and reducing shipping errors. The country-specific formatting can be extended to support diverse international address structures, including different field orders, postal code patterns, and address validation requirements.

#### Real-Time Validation Integration

The immediate validation trigger (`validateNewAddressField`) provides instant feedback about address data quality as users type, preventing submission of invalid addresses and improving the overall user experience. This real-time approach catches common address errors early in the input process, reducing form abandonment and shipping failures. The validation system can be enhanced to include address verification services, geocoding validation, and delivery route confirmation.

#### Type-Safe Address Management

The function leverages TypeScript's type system to ensure only valid address fields can be updated, preventing runtime errors and maintaining data structure integrity. The type casting to `ValidatedAddress` ensures compatibility with validation functions while maintaining flexibility for address input handling. This type safety extends to the validation system, ensuring consistent address data handling throughout the application.

#### Performance-Optimized State Updates

The state update pattern creates new address objects rather than mutating existing ones, ensuring proper React change detection and optimal re-rendering performance. The formatting operations are applied before state updates, minimizing processing during render cycles and maintaining responsive user interactions. This approach supports complex address forms with multiple fields without performance degradation.

#### User Experience Enhancement

The combination of intelligent formatting and immediate validation creates a guided address entry experience that helps users provide accurate shipping information. Users receive immediate feedback about format requirements and validation errors, reducing frustration and improving completion rates. The system builds confidence in address accuracy, which is critical for e-commerce transactions where shipping address errors can result in failed deliveries and customer dissatisfaction.

### Removing an Address

```tsx
// src/app/dashboard/settings/page.tsx
const handleRemoveAddress = async (addressId: string) => {
  const address = addresses.find((a) => a.id === addressId);
  if (address?.isFromAPI) {
    toast.error("Cannot remove address from API");
    return;
  }

  setIsLoading(true);
  try {
    setAddresses((prev) => prev.filter((a) => a.id !== addressId));
    toast.success("Address removed successfully!");
  } catch (error) {
    toast.error("Failed to remove address. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

#### Explanation of the Code

This secure address deletion system implements intelligent data protection mechanisms that preserve critical address information while enabling user control over their stored addresses. The implementation demonstrates enterprise-level data governance patterns that balance user autonomy with system integrity requirements within address management workflows.

#### Data Source Protection Logic

The `isFromAPI` flag verification creates a protective barrier around system-imported address data, preventing users from accidentally deleting critical addresses that may be linked to active orders, subscriptions, or system integrations. This protection mechanism ensures that addresses sourced from external APIs, customer service imports, or legacy system migrations remain stable while allowing users to manage their personally-added addresses freely.

#### Selective Deletion Permissions

The permission check system distinguishes between user-created and system-managed addresses, implementing different access levels based on data source. This approach supports complex e-commerce scenarios where some addresses must remain permanent (corporate accounts, verified business addresses) while others can be freely managed by users. The error messaging provides clear feedback about why certain addresses cannot be removed, maintaining transparency in the user experience.

#### Optimistic State Management

The state filtering operation implements optimistic updates that immediately reflect address removal in the user interface, providing responsive feedback while the deletion processes. This approach improves perceived performance and user confidence in the deletion operation. The loading state management ensures users understand when deletion operations are in progress and prevents multiple simultaneous deletion attempts.

#### Data Integrity and Consistency

The filter-based removal operation maintains address list integrity by creating a new array without the deleted address, ensuring proper React state change detection and re-rendering. This immutable update pattern prevents state corruption and maintains consistency across components that depend on the address list. The approach supports undo functionality and audit logging if needed.

#### User Experience and Safety

The success feedback confirmation builds user confidence that their deletion request was processed successfully, while the loading state provides clear indication of operation progress. The error handling for protected addresses educates users about system constraints without creating frustration. This balance between user control and system protection maintains trust while preserving critical data integrity requirements.

### Updating an Address

```tsx
// src/app/dashboard/settings/page.tsx
const handleEditAddressChange = (
  field: keyof typeof editAddressData,
  value: string,
) => {
  // Format postal code if it's a postal code field
  const formattedValue =
    field === "postalCode" && editAddressData.country
      ? formatPostalCode(value, editAddressData.country)
      : value;

  setEditAddressData((prev) => ({ ...prev, [field]: formattedValue }));

  // Real-time validation - ensure field is a valid ValidatedAddress key
  if (field in editAddressData) {
    validateEditAddressField(field as keyof ValidatedAddress, formattedValue);
  }
};

const handleSaveEditAddress = async () => {
  if (!editingAddress) return;

  const validationErrors = validateAddressLocal(editAddressData);

  if (validationErrors.length > 0) {
    toast.error(validationErrors[0]);
    return;
  }

  setIsLoading(true);
  try {
    // Use normalization to ensure consistent data format
    const normalizedResult = validateAndNormalizeAddress(editAddressData);

    if (!normalizedResult.isValid || !normalizedResult.normalizedAddress) {
      toast.error("Address validation failed");
      return;
    }

    setAddresses((prev) =>
      prev.map((addr) =>
        addr.id === editingAddress
          ? { ...addr, ...normalizedResult.normalizedAddress }
          : addr,
      ),
    );

    setEditingAddress(null);
    setEditAddressErrors({});
    toast.success("Address updated successfully!");
  } catch (error) {
    toast.error("Failed to update address. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

#### Explanation of the Code

This address editing system implements sophisticated data management patterns that ensure address accuracy while providing intuitive modification workflows. The implementation demonstrates enterprise-level approaches to in-place editing, data validation, and state synchronization that maintain address data integrity throughout the editing process.

#### Intelligent Edit State Management

The `handleEditAddressChange` function creates an isolated editing environment that allows users to modify address information without affecting the original data until explicitly saved. The postal code formatting logic maintains country-specific standards during editing, ensuring users see properly formatted addresses as they type. This approach prevents partial edits from corrupting the address list while providing real-time visual feedback about address formatting.

#### Real-Time Validation during Editing

The immediate validation trigger during editing provides continuous feedback about address data quality, preventing users from submitting invalid addresses and reducing editing friction. The validation system operates on the edit data copy, ensuring that validation errors don't interfere with the original address data. This pattern supports complex validation rules that can include postal code format checking, state/province validation, and country-specific address requirements.

#### Save Validation

The `handleSaveEditAddress` function implements multi-layer validation that ensures address accuracy before updating the stored data. Local validation catches basic format errors, while the normalization process standardizes address data according to postal service requirements. The validation failure handling prevents corrupted addresses from entering the system while providing clear feedback about specific validation issues.

#### Atomic State Updates

The address update operation uses React's functional state update pattern to atomically replace the edited address while preserving all other addresses in the list. This approach ensures data consistency and prevents race conditions that could corrupt the address list. The state update pattern maintains referential integrity for components that depend on the address list while minimizing re-render overhead.

#### User Experience Optimization

The combination of isolated editing state, real-time validation, and atomic updates creates a smooth editing experience that builds user confidence in address management. Users can freely experiment with address modifications knowing their changes won't affect other addresses until explicitly saved. The loading states and validation feedback provide clear guidance throughout the editing process, reducing user frustration and improving completion rates for address updates.

### Adding a New Payment

```tsx
// src/app/dashboard/settings/page.tsx
const handleNewPaymentChange = (
  field: keyof typeof newPaymentMethod,
  value: string,
) => {
  let formattedValue = value;

  // Apply specific formatting based on field
  if (field === "cardNumber") {
    formattedValue = maskCardNumber(value);
  } else if (field === "cardExpire") {
    formattedValue = formatExpiryDate(value);
  }

  setNewPaymentMethod((prev) => ({ ...prev, [field]: formattedValue }));

  // Real-time validation - ensure field is a valid ValidatedPaymentMethod key
  if (field in newPaymentMethod) {
    validateNewPaymentField(
      field as keyof ValidatedPaymentMethod,
      formattedValue,
    );
  }
};
```

#### Explanation of the Code

This secure payment method input management system implements industry-standard security practices that protect sensitive financial information while providing intuitive payment method addition workflows. The implementation demonstrates PCI-DSS compliant approaches to card data handling, real-time formatting, and validation that ensure both security and user experience within e-commerce payment management.

#### Field-Specific Security Formatting

The conditional formatting logic applies appropriate security measures and user experience enhancements based on the field type being updated. Card number masking through `maskCardNumber` ensures sensitive payment information is never displayed in plain text, reducing the risk of shoulder surfing and accidental disclosure. Expiration date formatting via `formatExpiryDate` provides standardized MM/YY format that matches industry conventions and improves user input accuracy.

#### Real-Time Payment Validation

The immediate validation trigger (`validateNewPaymentField`) provides instant feedback about payment method data quality as users enter information, preventing submission of invalid payment methods and reducing payment processing failures. This real-time approach catches common payment entry errors early, including invalid card numbers, expired cards, and incorrect security codes. The validation system can be enhanced to include card type detection, issuer validation, and real-time fraud screening.

#### Secure State Management

The state update pattern ensures payment method information is handled securely while maintaining React's component lifecycle requirements. The formatted values are applied before state storage, ensuring consistent data representation throughout the application. This approach supports secure payment processing workflows where formatted data can be safely transmitted to payment processors without exposing raw user input.

#### Type-Safe Payment Processing

The function leverages TypeScript's type system to ensure only valid payment method fields can be updated, preventing data corruption and maintaining payment method structure integrity. The type casting to `ValidatedPaymentMethod` ensures compatibility with validation functions while maintaining flexibility for payment input handling. This type safety extends to payment processing systems, ensuring consistent payment data handling throughout the transaction flow.

#### User Experience and Security Balance

The combination of intelligent formatting, immediate validation, and secure state management creates a guided payment entry experience that helps users provide accurate payment information while maintaining security standards. Users receive immediate feedback about format requirements and validation errors, building confidence in the payment system while ensuring sensitive data is properly protected throughout the entry process.

### Removing a Payment

```tsx
// src/app/dashboard/settings/page.tsx
const handleRemovePaymentMethod = async (paymentId: string) => {
  const payment = paymentMethods.find((p) => p.id === paymentId);
  if (payment?.isFromAPI) {
    toast.error("Cannot remove payment method from API");
    return;
  }

  setIsLoading(true);
  try {
    setPaymentMethods((prev) => prev.filter((p) => p.id !== paymentId));
    toast.success("Payment method removed successfully!");
  } catch (error) {
    toast.error("Failed to remove payment method. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

#### Explanation of the Code

This secure payment method deletion system implements financial data protection mechanisms that safeguard critical payment information while enabling user control over their stored payment methods. The implementation demonstrates PCI-DSS compliant data governance patterns that balance user autonomy with financial security requirements within payment management workflows.

#### Financial Data Protection Logic

The `isFromAPI` flag verification creates a protective barrier around system-imported payment methods, preventing users from accidentally deleting payment methods that may be linked to active subscriptions, recurring payments, or system integrations. This protection mechanism ensures that payment methods sourced from external payment processors, corporate account setups, or legacy system migrations remain stable while allowing users to manage their personally-added payment methods freely.

#### Sensitive Data Access Control

The permission check system distinguishes between user-created and system-managed payment methods, implementing different access levels based on data source and payment method criticality. This approach supports complex e-commerce scenarios where some payment methods must remain permanent (corporate cards, subscription methods) while others can be freely managed by users. The error messaging provides clear feedback about deletion restrictions while maintaining security transparency.

#### Secure State Cleanup

The filter-based removal operation implements secure cleanup that immediately removes payment method data from application state, reducing the exposure window for sensitive financial information. This optimistic update pattern provides responsive feedback while ensuring payment data is promptly removed from memory. The immutable update approach prevents state corruption and maintains consistency across components that depend on the payment method list.

#### Financial Compliance Considerations

The deletion workflow supports financial compliance requirements by implementing proper data retention policies and access controls. The system can be extended to include audit logging for payment method deletions, compliance reporting capabilities, and secure data archival processes. The loading state management ensures users understand when deletion operations are in progress and prevents multiple simultaneous deletion attempts that could compromise data integrity.

#### User Trust and Security Balance

The success feedback confirmation builds user confidence that their payment method deletion was processed securely, while the loading state provides clear indication of operation progress. The error handling for protected payment methods educates users about financial security constraints without creating frustration. This balance between user control and financial protection maintains trust while preserving critical payment method security requirements.

### Updating a Payment

```tsx
// src/app/dashboard/settings/page.tsx
const handleEditPaymentChange = (
  field: keyof typeof editPaymentData,
  value: string,
) => {
  let formattedValue = value;

  // Apply specific formatting based on field
  if (field === "cardNumber") {
    formattedValue = maskCardNumber(value);
  } else if (field === "cardExpire") {
    formattedValue = formatExpiryDate(value);
  }

  setEditPaymentData((prev) => ({ ...prev, [field]: formattedValue }));

  // Real-time validation - ensure field is a valid ValidatedPaymentMethod key
  if (field in editPaymentData) {
    validateEditPaymentField(
      field as keyof ValidatedPaymentMethod,
      formattedValue,
    );
  }
};

const handleSaveEditPayment = async () => {
  if (!editingPayment) return;

  const validationErrors = validatePaymentMethodLocal(editPaymentData);

  if (validationErrors.length > 0) {
    toast.error(validationErrors[0]);
    return;
  }

  setIsLoading(true);
  try {
    // Use normalization to ensure consistent data format
    const normalizedResult = validateAndNormalizePaymentMethod(editPaymentData);

    if (!normalizedResult.isValid || !normalizedResult.normalizedPayment) {
      toast.error("Payment method validation failed");
      return;
    }

    setPaymentMethods((prev) =>
      prev.map((payment) =>
        payment.id === editingPayment
          ? {
              ...payment,
              ...normalizedResult.normalizedPayment!,
              cardType: normalizedResult.normalizedPayment!.cardType,
            }
          : payment,
      ),
    );

    setEditingPayment(null);
    setEditPaymentErrors({});
    toast.success("Payment method updated successfully!");
  } catch (error) {
    toast.error("Failed to update payment method. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

#### Explanation of the Code

This secure payment method editing system implements sophisticated financial data management patterns that ensure payment information accuracy while providing intuitive modification workflows. The implementation demonstrates PCI-DSS compliant approaches to sensitive financial data editing, validation, and state synchronization that maintain payment security throughout the editing process.

#### Secure Edit State Management

The `handleEditPaymentChange` function creates an isolated editing environment that allows users to modify payment information without affecting the original data until explicitly saved. The secure formatting logic (card number masking, expiration date formatting) maintains PCI compliance standards during editing while ensuring users see properly formatted payment information as they type. This approach prevents partial edits from exposing sensitive payment data while providing real-time visual feedback.

#### Real-Time Financial Validation

The immediate validation trigger during editing provides continuous feedback about payment method data quality, preventing users from submitting invalid payment information and reducing payment processing failures. The validation system operates on the edit data copy, ensuring that validation errors don't interfere with the original payment method data. This pattern supports complex financial validation rules including card number validation, expiration date checking, and issuer verification.

#### Financial Data Validation

The `handleSaveEditPayment` function implements multi-layer validation that ensures payment method accuracy before updating stored financial data. Local validation catches basic format errors, while the normalization process standardizes payment data according to payment processor requirements. The validation failure handling prevents corrupted payment methods from entering the system while providing clear feedback about specific financial validation issues.

#### Atomic Payment State Updates

The payment method update operation uses React's functional state update pattern to atomically replace the edited payment method while preserving all other payment methods in the list. This approach ensures financial data consistency and prevents race conditions that could corrupt the payment method list. The state update pattern maintains referential integrity for components that depend on the payment method list while minimizing re-render overhead.

#### Enhanced Financial Security

The card type detection and normalization process ensures payment methods are properly categorized and validated according to card issuer requirements. The secure state management prevents sensitive payment information from remaining in memory longer than necessary, while the loading states provide clear indication of processing progress. This approach balances user experience with stringent financial security requirements essential for e-commerce payment processing.

<BackToTop />

## Canceling an Edit

```tsx
// src/app/dashboard/settings/page.tsx
const handleCancelEdit = () => {
  setEditingAddress(null);
  setEditingPayment(null);
  setEditAddressErrors({});
  setEditPaymentErrors({});
  setEditAddressData({
    address: "",
    city: "",
    state: "",
    postalCode: "",
    country: "US",
  });
  setEditPaymentData({
    cardNumber: "",
    cardType: "",
    cardExpire: "",
    cardHolderName: "",
  });
};
```

### Explanation of the Code

This edit cancellation system implements secure state cleanup mechanisms that protect user data integrity while providing intuitive cancellation workflows for complex editing operations. The implementation demonstrates enterprise-level patterns for managing edit state, validation cleanup, and user experience optimization within multi-domain settings management.

#### Multi-Domain State Reset

The function systematically resets editing states across both address and payment method domains, ensuring no residual edit data remains in memory after cancellation. This cleanup prevents data leakage between different editing sessions and maintains clear boundaries between edit and view modes. The atomic reset operation ensures consistent state regardless of which editing mode was active, supporting user mental models of cancellation behavior.

#### Validation State Cleanup

The validation error clearing process removes all field-specific error messages and validation states, returning the interface to a clean state that accurately reflects the original data. This cleanup prevents confusing error states from persisting after edit cancellation and ensures users start with fresh validation contexts when they next attempt to edit information. The error state reset supports both real-time validation cleanup and prevents false positive error displays.

#### Memory Management and Security

The reset of edit data containers (`editAddressData`, `editPaymentData`) to empty states ensures that partially-entered sensitive information is immediately removed from component memory. This approach minimizes the exposure window for sensitive data like payment information and addresses, supporting security best practices for data handling. The immediate cleanup reduces the risk of accidental data disclosure through browser debugging tools or memory inspection.

#### User Experience Continuity

The cancellation mechanism provides users with confidence that their editing actions can be safely abandoned without affecting their stored information. The immediate state reset creates clear visual feedback that the cancellation was successful, while the return to view mode provides continuity with the pre-edit interface state. This pattern supports user exploration of edit interfaces without fear of accidental data modification.

#### State Consistency Assurance

The reset operation ensures that all edit-related state variables return to their initial values, preventing partial edit states from corrupting future editing sessions. This consistency check supports reliable user experience patterns where users can repeatedly enter and exit edit modes without accumulating state artifacts. The reset pattern provides a foundation for complex editing workflows that maintain state integrity across multiple interaction cycles.

## Saving Profile Changes

```tsx
// src/app/dashboard/settings/page.tsx
const handleSaveProfile = async () => {
  setIsLoading(true);
  try {
    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1000));
    toast.success("Profile updated successfully!");
  } catch (error) {
    toast.error("Failed to update profile. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

### Explanation of the Code

This secure profile persistence system implements user data synchronization that maintains data integrity while providing reliable profile update workflows. The implementation demonstrates enterprise-level approaches to user data management, API integration, and state synchronization that ensure profile changes are securely processed and properly reflected throughout the application.

#### Asynchronous Profile Data Processing

The asynchronous operation simulates secure API communication that would include proper authentication, data validation, and server-side processing in production environments. The loading state management provides clear user feedback during the persistence process, preventing multiple simultaneous save attempts that could create data conflicts. This pattern supports complex profile update workflows that may include server-side validation, data normalization, and integration with external user management systems.

#### User Feedback and Confirmation

The success and error messaging system provides clear confirmation about profile update outcomes, building user confidence in the data persistence process. Users receive immediate feedback about whether their changes were successfully saved or if corrective action is needed. The toast notification system ensures users are aware of save results even if they navigate away from the settings page, supporting workflows where users make multiple changes before leaving the interface.

#### Data Integrity and Validation

The save operation can be extended to include server-side validation that ensures profile data meets business requirements, security standards, and regulatory compliance needs. The error handling system supports detailed validation feedback that guides users toward successful profile updates. This validation layer protects against data corruption while maintaining user experience quality.

#### State Management and Synchronization

The loading state coordination ensures users understand when profile operations are in progress and prevents interface interactions that could interfere with the save process. The successful save completion triggers any necessary state updates that keep the local interface synchronized with the persisted data. This synchronization supports complex applications where profile changes may affect other interface elements or user permissions.

#### Security and Performance Considerations

The profile save operation implements security patterns that protect user data during transmission and processing, while the performance optimization ensures responsive user experience even with complex profile data structures. The implementation supports audit logging, change tracking, and compliance reporting requirements that are essential for enterprise user management systems. This foundation enables scalable profile management that can accommodate growing user bases and evolving data requirements.

<BackToTop />

## Deleting the Account

```tsx
// src/app/dashboard/settings/page.tsx
const handleDeleteAccount = async () => {
  setIsLoading(true);
  try {
    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1000));
    logout();
    router.push("/");
    toast.success("Account deleted successfully.");
  } catch (error) {
    toast.error("Failed to delete account. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

### Explanation of the Code

This secure account deletion system implements user data removal workflows that comply with privacy regulations while maintaining data integrity and providing clear user guidance throughout the deletion process. The implementation demonstrates enterprise-level approaches to account lifecycle management, data privacy compliance, and secure session termination within user account systems.

#### Secure Deletion Processing

The asynchronous deletion operation simulates secure API communication that would include proper authentication verification, data cascading deletion, and audit logging in production environments. The process ensures that all user-associated data is properly handled according to privacy regulations and business requirements. This includes removing personal information, transaction history, and associated metadata while preserving anonymized analytics data as permitted by privacy policies.

#### Immediate Session Termination

The automatic logout execution (`logout()`) immediately terminates the user session to prevent continued access after account deletion, ensuring security and preventing confusion about account status. This immediate session cleanup protects against potential security vulnerabilities where deleted accounts might maintain active sessions. The session termination triggers proper cleanup of authentication tokens, cached user data, and session storage.

#### Post-Deletion Navigation Flow

The automatic redirection to the home page (`router.push("/")`) provides a clear transition away from user-specific interfaces after account deletion, preventing users from accessing deleted account features. This navigation pattern supports user understanding that their account deletion was successful while providing a logical next step in their interaction with the platform. The redirection can be enhanced to include deletion confirmation pages or account recovery information.

#### User Feedback and Confirmation

The success notification system provides clear confirmation that the account deletion was processed successfully, building user confidence in the deletion process while ensuring they understand the operation's completion. The error handling ensures users are informed if deletion attempts fail, enabling them to take corrective action or contact support. This feedback system supports transparency requirements common in privacy regulation compliance.

#### Data Privacy and Compliance

The deletion workflow supports GDPR, CCPA, and other privacy regulation requirements by implementing proper data removal procedures and user notification systems. The implementation can be extended to include data export capabilities, deletion confirmation requirements, and compliance audit trails. The loading state management prevents multiple deletion attempts that could complicate compliance tracking and ensures users understand when deletion operations are in progress.

## Canceling Membership

```tsx
// src/app/dashboard/settings/page.tsx
const handleCancelMembership = async () => {
  setIsLoading(true);
  try {
    const result = await cancelMembership();
    if (result.success) {
      toast.success(result.message);
    } else {
      toast.error(result.message);
    }
  } catch (error) {
    toast.error("Failed to cancel membership. Please try again.");
  } finally {
    setIsLoading(false);
  }
};
```

### Explanation of the Code

This membership cancellation system implements subscription lifecycle management that balances user autonomy with business retention strategies while maintaining compliance with subscription regulations. The implementation demonstrates enterprise-level approaches to subscription management, billing system integration, and customer relationship preservation within membership-based e-commerce platforms.

#### Subscription Service Integration

The `cancelMembership` function integration provides centralized access to subscription management services that handle complex billing operations, proration calculations, and subscription state transitions. This approach ensures consistent membership cancellation behavior across the platform while enabling proper integration with payment processors, billing systems, and customer management platforms. The centralized function supports complex cancellation workflows that may include retention offers, feedback collection, and account downgrade options.

#### Business Process Coordination

The membership cancellation workflow coordinates multiple business processes including subscription termination, access level modifications, and billing cycle adjustments. The function can be extended to include retention strategies such as pause options, discount offers, or alternative subscription tiers that may reduce churn while respecting user cancellation requests. This coordination ensures that cancellation processes align with business objectives while maintaining customer satisfaction.

#### Financial and Legal Compliance

The cancellation process supports subscription regulation compliance including proper notice periods, refund processing, and cancellation confirmation requirements. The implementation ensures that users receive appropriate documentation of their cancellation and understand when their subscription benefits will terminate. The system can accommodate different regional subscription laws and business policy requirements for cancellation processing.

#### Customer Experience Management

The user feedback system provides clear confirmation of cancellation processing while maintaining positive customer relationships even during subscription termination. The success messaging acknowledges the user's decision while potentially offering alternative engagement options or feedback collection opportunities. Error handling ensures users understand when cancellation attempts fail and provides guidance for resolution.

#### Retention and Recovery Opportunities

The cancellation workflow creates opportunities for retention marketing and customer recovery programs through proper data collection and customer journey tracking. The system can be enhanced to include exit surveys, retention offers, and reactivation campaigns that may recover subscribers while respecting their cancellation decisions. This approach balances immediate cancellation processing with long-term customer relationship management strategies.

<BackToTop />

## Validations

### Address Validation

```tsx
// src/lib/utils/validate.ts
const validateNewAddressField = (
  field: keyof ValidatedAddress,
  value: string,
) => {
  const error = validateAddressField(field, value, newAddress);
  setNewAddressErrors((prev) => ({
    ...prev,
    [field]: error || "",
  }));
};

const validateEditAddressField = (
  field: keyof ValidatedAddress,
  value: string,
) => {
  const error = validateAddressField(field, value, editAddressData);
  setEditAddressErrors((prev) => ({
    ...prev,
    [field]: error || "",
  }));
};

const validateAddressLocal = (
  address: Omit<Address, "id" | "isDefault" | "isFromAPI">,
): string[] => {
  // Convert local Address interface to ValidatedAddress for API validation
  const validatedAddress: Partial<ValidatedAddress> = {
    address: address.address,
    city: address.city,
    state: address.state,
    postalCode: address.postalCode,
    country: address.country,
  };

  const result: AddressValidationResult =
    validateAddressEnhanced(validatedAddress);

  // Convert validation errors to string array
  return result.errors.map((error: any) => error.message);
};
```

#### Explanation of the Code

These functions validate address fields in real-time as the user types. They call `validateAddressField` to check for errors and update the corresponding error state (`newAddressErrors` or `editAddressErrors`). This provides immediate feedback to the user about any issues with their address information.

### Payment Validation

```tsx
// src/lib/utils/payment.ts
const validateNewPaymentField = (
  field: keyof ValidatedPaymentMethod,
  value: string,
) => {
  const error = validatePaymentField(field, value, newPaymentMethod);
  setNewPaymentErrors((prev) => ({
    ...prev,
    [field]: error || "",
  }));
};

const validateEditPaymentField = (
  field: keyof ValidatedPaymentMethod,
  value: string,
) => {
  const error = validatePaymentField(field, value, editPaymentData);
  setEditPaymentErrors((prev) => ({
    ...prev,
    [field]: error || "",
  }));
};

const validatePaymentMethodLocal = (
  payment: Omit<PaymentMethod, "id" | "isDefault" | "isFromAPI">,
): string[] => {
  // Convert local PaymentMethod interface to ValidatedPaymentMethod for API validation
  const validatedPayment: Partial<ValidatedPaymentMethod> = {
    cardNumber: payment.cardNumber,
    cardType: payment.cardType,
    cardExpire: payment.cardExpire,
    cardHolderName: payment.cardHolderName,
  };

  const result: PaymentValidationResult =
    validatePaymentMethodEnhanced(validatedPayment);

  // Convert validation errors to string array
  return result.errors.map((error: any) => error.message);
};
```

#### Explanation of the Code

These functions validate payment fields in real-time as the user types. They call `validatePaymentField` to check for errors and update the corresponding error state (`newPaymentErrors` or `editPaymentErrors`). This provides immediate feedback to the user about any issues with their payment information.

<BackToTop />

## Displaying the Form

```tsx
// src/app/dashboard/settings/page.tsx
  return (
    <div className="bg-background min-h-screen">
      <div className="mx-auto px-6 lg:px-8 py-8 max-w-7xl">
        <div className="mb-8">
          <Button variant="ghost" size="sm" asChild>
            <Link href="/dashboard">
              <ArrowLeft className="mr-2 w-4 h-4" />
              Back to Dashboard
            </Link>
          </Button>
          <h1 className="font-bold text-3xl">Settings Page</h1>
          <p className="text-muted-foreground">
            Pariatur amet sit ad deserunt duis elit cillum amet dolore anim
            cupidatat.
          </p>
        </div>

        <div className="gap-8 grid lg:grid-cols-4">
          {/* Sidebar */}
          <div className="lg:col-span-1">
            <Card>
              <CardContent className="p-4">
                <nav className="space-y-2">
                  {tabs.map((tab) => (
                    <button
                      key={tab.id}
                      onClick={() => setActiveTab(tab.id)}
                      className={`w-full flex items-center gap-3 px-3 py-2 text-left text-sm rounded-md transition-colors ${
                        activeTab === tab.id
                          ? "bg-primary text-primary-foreground"
                          : "hover:bg-muted"
                      }`}
                    >
                      <tab.icon className="w-4 h-4" />
                      {tab.label}
                    </button>
                  ))}
                </nav>
              </CardContent>
            </Card>
          </div>

          {/* Main Content */}
          <div className="lg:col-span-3">
            {activeTab === "profile" && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <User className="w-5 h-5" />
                    Profile & Personal Information
                  </CardTitle>
                  {userData && (
                    <p className="text-muted-foreground text-sm">
                      All personal information (username, email, phone, address,
                      payment methods) is from the same DummyJSON API user (ID:{" "}
                      {userData.id}) - {userData.firstName} {userData.lastName}.
                    </p>
                  )}
                </CardHeader>
                <CardContent className="space-y-6">
                  {/* Read-only user info from auth */}
                  <div className="gap-4 grid md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="username">Username (Read-only)</Label>
                      <Input
                        id="username"
                        value={formData.username}
                        readOnly
                        className="bg-muted"
                        placeholder="Username"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="email">Email (Read-only)</Label>
                      <Input
                        id="email"
                        type="email"
                        value={formData.email}
                        readOnly
                        className="bg-muted"
                        placeholder="Email"
                      />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="phoneNumber">
                      Phone Number (Read-only)
                    </Label>
                    <Input
                      id="phoneNumber"
                      type="tel"
                      value={formData.phoneNumber}
                      readOnly
                      className="bg-muted"
                      placeholder="Phone number"
                    />
                  </div>

                  <Separator />

                  {/* Editable name fields */}
                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">
                      Personal Information
                    </h3>
                    <div className="gap-4 grid md:grid-cols-3">
                      <div className="space-y-2">
                        <Label htmlFor="firstName">First Name</Label>
                        <Input
                          id="firstName"
                          value={formData.firstName}
                          onChange={(e) =>
                            handleInputChange("firstName", e.target.value)
                          }
                          placeholder="Enter first name"
                        />
                      </div>
                      <div className="space-y-2">
                        <Label htmlFor="middleName">Middle Name</Label>
                        <Input
                          id="middleName"
                          value={formData.middleName}
                          onChange={(e) =>
                            handleInputChange("middleName", e.target.value)
                          }
                          placeholder="Enter middle name (optional)"
                        />
                      </div>
                      <div className="space-y-2">
                        <Label htmlFor="lastName">Last Name</Label>
                        <Input
                          id="lastName"
                          value={formData.lastName}
                          onChange={(e) =>
                            handleInputChange("lastName", e.target.value)
                          }
                          placeholder="Enter last name"
                        />
                      </div>
                    </div>
                  </div>

                  <Separator />

                  {/* Address Management */}
                  <div className="space-y-4">
                    <div className="flex justify-between items-center">
                      <div>
                        <h3 className="font-semibold text-lg">
                          Saved Addresses
                        </h3>
                        {userData && (
                          <p className="text-muted-foreground text-sm">
                            Address belongs to {userData.firstName}{" "}
                            {userData.lastName}. Existing addresses cannot be
                            edited or removed.
                          </p>
                        )}
                      </div>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setShowAddAddress(true)}
                      >
                        <Plus className="mr-2 w-4 h-4" />
                        Add Address
                      </Button>
                    </div>

                    {addresses.length > 0 ? (
                      <div className="space-y-3">
                        {addresses.map((address) => (
                          <Card key={address.id} className="p-4">
                            {editingAddress === address.id ? (
                              // Edit mode
                              <div className="space-y-4">
                                <h4 className="font-medium">Edit Address</h4>
                                <div className="space-y-3">
                                  <div className="space-y-2">
                                    <Label htmlFor="editAddress">
                                      Street Address
                                    </Label>
                                    <Input
                                      id="editAddress"
                                      value={editAddressData.address}
                                      onChange={(e) =>
                                        handleEditAddressChange(
                                          "address",
                                          e.target.value
                                        )
                                      }
                                      placeholder="Enter street address"
                                      className={
                                        editAddressErrors.address
                                          ? "border-red-500"
                                          : ""
                                      }
                                    />
                                    {editAddressErrors.address && (
                                      <p className="text-red-500 text-sm">
                                        {editAddressErrors.address}
                                      </p>
                                    )}
                                  </div>
                                  <div className="gap-4 grid md:grid-cols-3">
                                    <div className="space-y-2">
                                      <Label htmlFor="editCity">City</Label>
                                      <Input
                                        id="editCity"
                                        value={editAddressData.city}
                                        onChange={(e) =>
                                          handleEditAddressChange(
                                            "city",
                                            e.target.value
                                          )
                                        }
                                        placeholder="Enter city"
                                        className={
                                          editAddressErrors.city
                                            ? "border-red-500"
                                            : ""
                                        }
                                      />
                                      {editAddressErrors.city && (
                                        <p className="text-red-500 text-sm">
                                          {editAddressErrors.city}
                                        </p>
                                      )}
                                    </div>
                                    <div className="space-y-2">
                                      <Label htmlFor="editState">
                                        State/Province
                                      </Label>
                                      <Input
                                        id="editState"
                                        value={editAddressData.state}
                                        onChange={(e) =>
                                          handleEditAddressChange(
                                            "state",
                                            e.target.value
                                          )
                                        }
                                        placeholder="Enter state"
                                        className={
                                          editAddressErrors.state
                                            ? "border-red-500"
                                            : ""
                                        }
                                      />
                                      {editAddressErrors.state && (
                                        <p className="text-red-500 text-sm">
                                          {editAddressErrors.state}
                                        </p>
                                      )}
                                    </div>
                                    <div className="space-y-2">
                                      <Label htmlFor="editZipCode">
                                        ZIP/Postal Code
                                      </Label>
                                      <Input
                                        id="editZipCode"
                                        value={editAddressData.postalCode}
                                        onChange={(e) =>
                                          handleEditAddressChange(
                                            "postalCode",
                                            e.target.value
                                          )
                                        }
                                        placeholder="Enter ZIP code"
                                        className={
                                          editAddressErrors.postalCode
                                            ? "border-red-500"
                                            : ""
                                        }
                                      />
                                      {editAddressErrors.postalCode && (
                                        <p className="text-red-500 text-sm">
                                          {editAddressErrors.postalCode}
                                        </p>
                                      )}
                                    </div>
                                  </div>
                                  <div className="space-y-2">
                                    <Label htmlFor="editCountry">Country</Label>
                                    <Select
                                      value={editAddressData.country}
                                      onValueChange={(value) => {
                                        handleEditAddressChange(
                                          "country",
                                          value
                                        );
                                        // Re-validate state and postal code when country changes
                                        if (editAddressData.state) {
                                          validateEditAddressField(
                                            "state",
                                            editAddressData.state
                                          );
                                        }
                                        if (editAddressData.postalCode) {
                                          validateEditAddressField(
                                            "postalCode",
                                            editAddressData.postalCode
                                          );
                                        }
                                      }}
                                    >
                                      <SelectTrigger
                                        className={
                                          editAddressErrors.country
                                            ? "border-red-500"
                                            : ""
                                        }
                                      >
                                        <SelectValue placeholder="Select country" />
                                      </SelectTrigger>
                                      <SelectContent>
                                        <SelectItem value="US">
                                          United States
                                        </SelectItem>
                                        <SelectItem value="CA">
                                          Canada
                                        </SelectItem>
                                        <SelectItem value="GB">
                                          United Kingdom
                                        </SelectItem>
                                        <SelectItem value="AU">
                                          Australia
                                        </SelectItem>
                                        <SelectItem value="DE">
                                          Germany
                                        </SelectItem>
                                        <SelectItem value="FR">
                                          France
                                        </SelectItem>
                                        <SelectItem value="JP">
                                          Japan
                                        </SelectItem>
                                        <SelectItem value="CN">
                                          China
                                        </SelectItem>
                                        <SelectItem value="IN">
                                          India
                                        </SelectItem>
                                        <SelectItem value="BR">
                                          Brazil
                                        </SelectItem>
                                      </SelectContent>
                                    </Select>
                                    {editAddressErrors.country && (
                                      <p className="text-red-500 text-sm">
                                        {editAddressErrors.country}
                                      </p>
                                    )}
                                  </div>
                                </div>
                                <div className="flex gap-2">
                                  <Button
                                    onClick={handleSaveEditAddress}
                                    disabled={isLoading}
                                    size="sm"
                                  >
                                    <Check className="mr-2 w-4 h-4" />
                                    {isLoading ? "Saving..." : "Save"}
                                  </Button>
                                  <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={handleCancelEdit}
                                  >
                                    <X className="mr-2 w-4 h-4" />
                                    Cancel
                                  </Button>
                                </div>
                              </div>
                            ) : (
                              // View mode
                              <div className="flex justify-between items-start">
                                <div className="space-y-1">
                                  <div className="flex items-center gap-2">
                                    <MapPin className="w-4 h-4" />
                                    <span className="font-medium">
                                      {address.isDefault && (
                                        <span className="bg-primary mr-2 px-2 py-1 rounded text-primary-foreground text-xs">
                                          Default
                                        </span>
                                      )}
                                      {address.isFromAPI && (
                                        <span className="bg-blue-500 mr-2 px-2 py-1 rounded text-white text-xs">
                                          API
                                        </span>
                                      )}
                                      Address
                                    </span>
                                  </div>
                                  <p className="text-muted-foreground text-sm">
                                    {address.address}
                                  </p>
                                  <p className="text-muted-foreground text-sm">
                                    {address.city}, {address.state}{" "}
                                    {address.postalCode}
                                  </p>
                                  <p className="text-muted-foreground text-sm">
                                    {address.country}
                                  </p>
                                </div>
                                <div className="flex gap-2">
                                  {address.isFromAPI ? (
                                    <span className="text-muted-foreground text-xs">
                                      Cannot be edited or removed
                                    </span>
                                  ) : (
                                    <>
                                      <Button
                                        variant="outline"
                                        size="sm"
                                        onClick={() =>
                                          handleEditAddress(address)
                                        }
                                      >
                                        <Edit2 className="w-4 h-4" />
                                      </Button>
                                      <Button
                                        variant="destructive"
                                        size="sm"
                                        onClick={() =>
                                          handleRemoveAddress(address.id)
                                        }
                                      >
                                        <Trash2 className="w-4 h-4" />
                                      </Button>
                                    </>
                                  )}
                                </div>
                              </div>
                            )}
                          </Card>
                        ))}
                      </div>
                    ) : (
                      <p className="text-muted-foreground text-sm">
                        No saved addresses
                      </p>
                    )}

                    {/* Add New Address Form */}
                    {showAddAddress && (
                      <Card className="p-4 border-dashed">
                        <div className="space-y-4">
                          <h4 className="font-medium">Add New Address</h4>
                          <div className="space-y-3">
                            <div className="space-y-2">
                              <Label htmlFor="newAddress">Street Address</Label>
                              <Input
                                id="newAddress"
                                value={newAddress.address}
                                onChange={(e) =>
                                  handleNewAddressChange(
                                    "address",
                                    e.target.value
                                  )
                                }
                                placeholder="Enter street address"
                                className={
                                  newAddressErrors.address
                                    ? "border-red-500"
                                    : ""
                                }
                              />
                              {newAddressErrors.address && (
                                <p className="text-red-500 text-sm">
                                  {newAddressErrors.address}
                                </p>
                              )}
                            </div>
                            <div className="gap-4 grid md:grid-cols-3">
                              <div className="space-y-2">
                                <Label htmlFor="newCity">City</Label>
                                <Input
                                  id="newCity"
                                  value={newAddress.city}
                                  onChange={(e) =>
                                    handleNewAddressChange(
                                      "city",
                                      e.target.value
                                    )
                                  }
                                  placeholder="Enter city"
                                  className={
                                    newAddressErrors.city
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {newAddressErrors.city && (
                                  <p className="text-red-500 text-sm">
                                    {newAddressErrors.city}
                                  </p>
                                )}
                              </div>
                              <div className="space-y-2">
                                <Label htmlFor="newState">State/Province</Label>
                                <Input
                                  id="newState"
                                  value={newAddress.state}
                                  onChange={(e) =>
                                    handleNewAddressChange(
                                      "state",
                                      e.target.value
                                    )
                                  }
                                  placeholder="Enter state"
                                  className={
                                    newAddressErrors.state
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {newAddressErrors.state && (
                                  <p className="text-red-500 text-sm">
                                    {newAddressErrors.state}
                                  </p>
                                )}
                              </div>
                              <div className="space-y-2">
                                <Label htmlFor="newZipCode">
                                  ZIP/Postal Code
                                </Label>
                                <Input
                                  id="newZipCode"
                                  value={newAddress.postalCode}
                                  onChange={(e) =>
                                    handleNewAddressChange(
                                      "postalCode",
                                      e.target.value
                                    )
                                  }
                                  placeholder="Enter ZIP code"
                                  className={
                                    newAddressErrors.postalCode
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {newAddressErrors.postalCode && (
                                  <p className="text-red-500 text-sm">
                                    {newAddressErrors.postalCode}
                                  </p>
                                )}
                              </div>
                            </div>
                            <div className="space-y-2">
                              <Label htmlFor="newCountry">Country</Label>
                              <Select
                                value={newAddress.country}
                                onValueChange={(value) => {
                                  handleNewAddressChange("country", value);
                                  // Re-validate state and postal code when country changes
                                  if (newAddress.state) {
                                    validateNewAddressField(
                                      "state",
                                      newAddress.state
                                    );
                                  }
                                  if (newAddress.postalCode) {
                                    validateNewAddressField(
                                      "postalCode",
                                      newAddress.postalCode
                                    );
                                  }
                                }}
                              >
                                <SelectTrigger
                                  className={
                                    newAddressErrors.country
                                      ? "border-red-500"
                                      : ""
                                  }
                                >
                                  <SelectValue placeholder="Select country" />
                                </SelectTrigger>
                                <SelectContent>
                                  <SelectItem value="US">
                                    United States
                                  </SelectItem>
                                  <SelectItem value="CA">Canada</SelectItem>
                                  <SelectItem value="GB">
                                    United Kingdom
                                  </SelectItem>
                                  <SelectItem value="AU">Australia</SelectItem>
                                  <SelectItem value="DE">Germany</SelectItem>
                                  <SelectItem value="FR">France</SelectItem>
                                  <SelectItem value="JP">Japan</SelectItem>
                                  <SelectItem value="CN">China</SelectItem>
                                  <SelectItem value="IN">India</SelectItem>
                                  <SelectItem value="BR">Brazil</SelectItem>
                                </SelectContent>
                              </Select>
                              {newAddressErrors.country && (
                                <p className="text-red-500 text-sm">
                                  {newAddressErrors.country}
                                </p>
                              )}
                            </div>
                          </div>
                          <div className="flex gap-2">
                            <Button
                              onClick={handleAddAddress}
                              disabled={isLoading}
                              size="sm"
                            >
                              {isLoading ? "Adding..." : "Add Address"}
                            </Button>
                            <Button
                              variant="outline"
                              size="sm"
                              onClick={() => setShowAddAddress(false)}
                            >
                              Cancel
                            </Button>
                          </div>
                        </div>
                      </Card>
                    )}
                  </div>

                  <Button
                    onClick={handleSaveProfile}
                    disabled={isLoading}
                    className="w-full"
                  >
                    {isLoading ? "Saving..." : "Save Profile"}
                  </Button>
                </CardContent>
              </Card>
            )}

            {activeTab === "security" && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Lock className="w-5 h-5" />
                    Security & Password
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-6">
                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">Change Password</h3>
                    <div className="space-y-2">
                      <Label htmlFor="currentPassword">Current Password</Label>
                      <Input
                        id="currentPassword"
                        type="password"
                        value={formData.currentPassword}
                        onChange={(e) =>
                          handleInputChange("currentPassword", e.target.value)
                        }
                        placeholder="Enter current password"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="newPassword">New Password</Label>
                      <Input
                        id="newPassword"
                        type="password"
                        value={formData.newPassword}
                        onChange={(e) =>
                          handleInputChange("newPassword", e.target.value)
                        }
                        placeholder="Enter new password"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="confirmPassword">
                        Confirm New Password
                      </Label>
                      <Input
                        id="confirmPassword"
                        type="password"
                        value={formData.confirmPassword}
                        onChange={(e) =>
                          handleInputChange("confirmPassword", e.target.value)
                        }
                        placeholder="Confirm new password"
                      />
                    </div>
                    <Button onClick={handleChangePassword} disabled={isLoading}>
                      {isLoading ? "Changing..." : "Change Password"}
                    </Button>
                  </div>

                  <Separator />

                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">
                      Two-Factor Authentication
                    </h3>
                    <p className="text-muted-foreground text-sm">
                      Add an extra layer of security to your account by enabling
                      two-factor authentication.
                    </p>
                    <Button variant="outline">
                      Enable Two-Factor Authentication
                    </Button>
                  </div>

                  <Separator />

                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">Active Sessions</h3>
                    <p className="text-muted-foreground text-sm">
                      Manage and monitor your active sessions across different
                      devices.
                    </p>
                    <Button variant="outline">View Active Sessions</Button>
                  </div>
                </CardContent>
              </Card>
            )}

            {activeTab === "notifications" && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Bell className="w-5 h-5" />
                    Notification Preferences
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-6">
                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">
                      Email Notifications
                    </h3>
                    <div className="space-y-4">
                      <div className="flex justify-between items-center">
                        <div>
                          <Label htmlFor="emailOrders">Order Updates</Label>
                          <p className="text-muted-foreground text-sm">
                            Receive emails about your order status and shipping
                            updates
                          </p>
                        </div>
                        <Switch
                          id="emailOrders"
                          checked={notifications.emailOrders}
                          onCheckedChange={(checked) =>
                            handleNotificationChange("emailOrders", checked)
                          }
                        />
                      </div>
                      <div className="flex justify-between items-center">
                        <div>
                          <Label htmlFor="emailMarketing">
                            Marketing & Promotions
                          </Label>
                          <p className="text-muted-foreground text-sm">
                            Receive emails about sales, new products, and
                            special offers
                          </p>
                        </div>
                        <Switch
                          id="emailMarketing"
                          checked={notifications.emailMarketing}
                          onCheckedChange={(checked) =>
                            handleNotificationChange("emailMarketing", checked)
                          }
                        />
                      </div>
                      <div className="flex justify-between items-center">
                        <div>
                          <Label htmlFor="emailSecurity">Security Alerts</Label>
                          <p className="text-muted-foreground text-sm">
                            Receive emails about account security and login
                            activity
                          </p>
                        </div>
                        <Switch
                          id="emailSecurity"
                          checked={notifications.emailSecurity}
                          onCheckedChange={(checked) =>
                            handleNotificationChange("emailSecurity", checked)
                          }
                        />
                      </div>
                    </div>
                  </div>

                  <Separator />

                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">
                      Push Notifications
                    </h3>
                    <div className="flex justify-between items-center">
                      <div>
                        <Label htmlFor="pushNotifications">
                          Browser Notifications
                        </Label>
                        <p className="text-muted-foreground text-sm">
                          Receive push notifications in your browser
                        </p>
                      </div>
                      <Switch
                        id="pushNotifications"
                        checked={notifications.pushNotifications}
                        onCheckedChange={(checked) =>
                          handleNotificationChange("pushNotifications", checked)
                        }
                      />
                    </div>
                  </div>

                  <Separator />

                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">SMS Notifications</h3>
                    <div className="flex justify-between items-center">
                      <div>
                        <Label htmlFor="smsNotifications">Text Messages</Label>
                        <p className="text-muted-foreground text-sm">
                          Receive important updates via SMS
                        </p>
                      </div>
                      <Switch
                        id="smsNotifications"
                        checked={notifications.smsNotifications}
                        onCheckedChange={(checked) =>
                          handleNotificationChange("smsNotifications", checked)
                        }
                      />
                    </div>
                  </div>

                  <Button
                    onClick={handleSaveNotifications}
                    disabled={isLoading}
                    className="w-full"
                  >
                    {isLoading ? "Saving..." : "Save Notification Preferences"}
                  </Button>
                </CardContent>
              </Card>
            )}

            {activeTab === "privacy" && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Shield className="w-5 h-5" />
                    Privacy & Data Settings
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-6">
                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">
                      Profile Visibility
                    </h3>
                    <div className="space-y-2">
                      <Label htmlFor="profileVisibility">
                        Who can see your profile?
                      </Label>
                      <Select
                        value={privacy.profileVisibility}
                        onValueChange={(
                          value: "public" | "private" | "friends"
                        ) => handlePrivacyChange("profileVisibility", value)}
                      >
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="public">Public</SelectItem>
                          <SelectItem value="friends">Friends Only</SelectItem>
                          <SelectItem value="private">Private</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  </div>

                  <Separator />

                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">Data & Analytics</h3>
                    <div className="space-y-4">
                      <div className="flex justify-between items-center">
                        <div>
                          <Label htmlFor="dataSharing">Data Sharing</Label>
                          <p className="text-muted-foreground text-sm">
                            Allow sharing of anonymized data with partners
                          </p>
                        </div>
                        <Switch
                          id="dataSharing"
                          checked={privacy.dataSharing}
                          onCheckedChange={(checked) =>
                            handlePrivacyChange("dataSharing", checked)
                          }
                        />
                      </div>
                      <div className="flex justify-between items-center">
                        <div>
                          <Label htmlFor="analyticsTracking">
                            Analytics Tracking
                          </Label>
                          <p className="text-muted-foreground text-sm">
                            Help us improve our service by allowing analytics
                            tracking
                          </p>
                        </div>
                        <Switch
                          id="analyticsTracking"
                          checked={privacy.analyticsTracking}
                          onCheckedChange={(checked) =>
                            handlePrivacyChange("analyticsTracking", checked)
                          }
                        />
                      </div>
                      <div className="flex justify-between items-center">
                        <div>
                          <Label htmlFor="personalizedAds">
                            Personalized Advertising
                          </Label>
                          <p className="text-muted-foreground text-sm">
                            Show ads based on your interests and activity
                          </p>
                        </div>
                        <Switch
                          id="personalizedAds"
                          checked={privacy.personalizedAds}
                          onCheckedChange={(checked) =>
                            handlePrivacyChange("personalizedAds", checked)
                          }
                        />
                      </div>
                    </div>
                  </div>

                  <Separator />

                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">
                      Data Export & Deletion
                    </h3>
                    <p className="text-muted-foreground text-sm">
                      Manage your personal data and account
                    </p>
                    <div className="flex gap-2">
                      <Button variant="outline">Export My Data</Button>
                      <AlertDialog>
                        <AlertDialogTrigger asChild>
                          <Button variant="destructive">
                            <Trash2 className="mr-2 w-4 h-4" />
                            Delete Account
                          </Button>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                          <AlertDialogHeader>
                            <AlertDialogTitle>
                              Are you absolutely sure?
                            </AlertDialogTitle>
                            <AlertDialogDescription>
                              This action cannot be undone. This will
                              permanently delete your account and remove your
                              data from our servers.
                            </AlertDialogDescription>
                          </AlertDialogHeader>
                          <AlertDialogFooter>
                            <AlertDialogCancel>Cancel</AlertDialogCancel>
                            <AlertDialogAction
                              onClick={handleDeleteAccount}
                              disabled={isLoading}
                            >
                              {isLoading ? "Deleting..." : "Delete Account"}
                            </AlertDialogAction>
                          </AlertDialogFooter>
                        </AlertDialogContent>
                      </AlertDialog>
                    </div>
                  </div>

                  <Button
                    onClick={handleSavePrivacy}
                    disabled={isLoading}
                    className="w-full"
                  >
                    {isLoading ? "Saving..." : "Save Privacy Settings"}
                  </Button>
                </CardContent>
              </Card>
            )}

            {activeTab === "billing" && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <CreditCard className="w-5 h-5" />
                    Billing & Payment Methods
                  </CardTitle>
                  {userData && (
                    <p className="text-muted-foreground text-sm">
                      Payment information belongs to {userData.firstName}{" "}
                      {userData.lastName} (User ID: {userData.id}). Existing
                      methods cannot be edited or removed, but you can add new
                      ones.
                    </p>
                  )}
                </CardHeader>
                <CardContent className="space-y-6">
                  <div className="space-y-4">
                    <div className="flex justify-between items-center">
                      <h3 className="font-semibold text-lg">Payment Methods</h3>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setShowAddPayment(true)}
                      >
                        <Plus className="mr-2 w-4 h-4" />
                        Add Payment Method
                      </Button>
                    </div>

                    {paymentMethods.length > 0 ? (
                      <div className="space-y-3">
                        {paymentMethods.map((payment) => (
                          <Card key={payment.id} className="p-4">
                            {editingPayment === payment.id ? (
                              // Edit mode
                              <div className="space-y-4">
                                <h4 className="font-medium">
                                  Edit Payment Method
                                </h4>
                                <div className="space-y-3">
                                  <div className="space-y-2">
                                    <Label htmlFor="editCardHolderName">
                                      Cardholder Name
                                    </Label>
                                    <Input
                                      id="editCardHolderName"
                                      value={editPaymentData.cardHolderName}
                                      onChange={(e) =>
                                        handleEditPaymentChange(
                                          "cardHolderName",
                                          e.target.value
                                        )
                                      }
                                      placeholder="Enter cardholder name"
                                      className={
                                        editPaymentErrors.cardHolderName
                                          ? "border-red-500"
                                          : ""
                                      }
                                    />
                                    {editPaymentErrors.cardHolderName && (
                                      <p className="text-red-500 text-sm">
                                        {editPaymentErrors.cardHolderName}
                                      </p>
                                    )}
                                  </div>
                                  <div className="space-y-2">
                                    <Label htmlFor="editCardNumber">
                                      Card Number
                                    </Label>
                                    <Input
                                      id="editCardNumber"
                                      value={editPaymentData.cardNumber}
                                      onChange={(e) =>
                                        handleEditPaymentChange(
                                          "cardNumber",
                                          e.target.value
                                        )
                                      }
                                      placeholder="1234 5678 9012 3456"
                                      maxLength={23} // Allow for spacing
                                      className={
                                        editPaymentErrors.cardNumber
                                          ? "border-red-500"
                                          : ""
                                      }
                                    />
                                    {editPaymentErrors.cardNumber && (
                                      <p className="text-red-500 text-sm">
                                        {editPaymentErrors.cardNumber}
                                      </p>
                                    )}
                                  </div>
                                  <div className="gap-4 grid md:grid-cols-2">
                                    <div className="space-y-2">
                                      <Label htmlFor="editCardExpire">
                                        Expiry Date
                                      </Label>
                                      <Input
                                        id="editCardExpire"
                                        value={editPaymentData.cardExpire}
                                        onChange={(e) =>
                                          handleEditPaymentChange(
                                            "cardExpire",
                                            e.target.value
                                          )
                                        }
                                        placeholder="MM/YY"
                                        maxLength={5}
                                        className={
                                          editPaymentErrors.cardExpire
                                            ? "border-red-500"
                                            : ""
                                        }
                                      />
                                      {editPaymentErrors.cardExpire && (
                                        <p className="text-red-500 text-sm">
                                          {editPaymentErrors.cardExpire}
                                        </p>
                                      )}
                                    </div>
                                    <div className="space-y-2">
                                      <Label htmlFor="editCardType">
                                        Card Type
                                      </Label>
                                      <Select
                                        value={editPaymentData.cardType}
                                        onValueChange={(value) =>
                                          setEditPaymentData((prev) => ({
                                            ...prev,
                                            cardType: value,
                                          }))
                                        }
                                      >
                                        <SelectTrigger>
                                          <SelectValue placeholder="Select card type" />
                                        </SelectTrigger>
                                        <SelectContent>
                                          <SelectItem value="Visa">
                                            Visa
                                          </SelectItem>
                                          <SelectItem value="Mastercard">
                                            Mastercard
                                          </SelectItem>
                                          <SelectItem value="American Express">
                                            American Express
                                          </SelectItem>
                                          <SelectItem value="Discover">
                                            Discover
                                          </SelectItem>
                                        </SelectContent>
                                      </Select>
                                    </div>
                                  </div>
                                </div>
                                <div className="flex gap-2">
                                  <Button
                                    onClick={handleSaveEditPayment}
                                    disabled={isLoading}
                                    size="sm"
                                  >
                                    <Check className="mr-2 w-4 h-4" />
                                    {isLoading ? "Saving..." : "Save"}
                                  </Button>
                                  <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={handleCancelEdit}
                                  >
                                    <X className="mr-2 w-4 h-4" />
                                    Cancel
                                  </Button>
                                </div>
                              </div>
                            ) : (
                              // View mode
                              <div className="flex justify-between items-start">
                                <div className="space-y-1">
                                  <div className="flex items-center gap-2">
                                    <CreditCard className="w-4 h-4" />
                                    <span className="font-medium">
                                      {payment.isDefault && (
                                        <span className="bg-primary mr-2 px-2 py-1 rounded text-primary-foreground text-xs">
                                          Default
                                        </span>
                                      )}
                                      {payment.isFromAPI && (
                                        <span className="bg-blue-500 mr-2 px-2 py-1 rounded text-white text-xs">
                                          API
                                        </span>
                                      )}
                                      {payment.cardType}
                                    </span>
                                  </div>
                                  <p className="text-muted-foreground text-sm">
                                    {maskCardNumber(payment.cardNumber)}
                                  </p>
                                  <p className="text-muted-foreground text-sm">
                                    Expires: {payment.cardExpire}
                                  </p>
                                  <p className="text-muted-foreground text-sm">
                                    {payment.cardHolderName}
                                  </p>
                                </div>
                                <div className="flex gap-2">
                                  {payment.isFromAPI ? (
                                    <span className="text-muted-foreground text-xs">
                                      Cannot be edited or removed
                                    </span>
                                  ) : (
                                    <>
                                      <Button
                                        variant="outline"
                                        size="sm"
                                        onClick={() =>
                                          handleEditPayment(payment)
                                        }
                                      >
                                        <Edit2 className="w-4 h-4" />
                                      </Button>
                                      <Button
                                        variant="destructive"
                                        size="sm"
                                        onClick={() =>
                                          handleRemovePaymentMethod(payment.id)
                                        }
                                      >
                                        <Trash2 className="w-4 h-4" />
                                      </Button>
                                    </>
                                  )}
                                </div>
                              </div>
                            )}
                          </Card>
                        ))}
                      </div>
                    ) : (
                      <p className="text-muted-foreground text-sm">
                        No saved payment methods
                      </p>
                    )}

                    {/* Add New Payment Method Form */}
                    {showAddPayment && (
                      <Card className="p-4 border-dashed">
                        <div className="space-y-4">
                          <h4 className="font-medium">
                            Add New Payment Method
                          </h4>
                          <div className="space-y-3">
                            <div className="space-y-2">
                              <Label htmlFor="cardHolderName">
                                Cardholder Name
                              </Label>
                              <Input
                                id="cardHolderName"
                                value={newPaymentMethod.cardHolderName}
                                onChange={(e) =>
                                  handleNewPaymentChange(
                                    "cardHolderName",
                                    e.target.value
                                  )
                                }
                                placeholder="Enter cardholder name"
                                className={
                                  newPaymentErrors.cardHolderName
                                    ? "border-red-500"
                                    : ""
                                }
                              />
                              {newPaymentErrors.cardHolderName && (
                                <p className="text-red-500 text-sm">
                                  {newPaymentErrors.cardHolderName}
                                </p>
                              )}
                            </div>
                            <div className="space-y-2">
                              <Label htmlFor="cardNumber">Card Number</Label>
                              <Input
                                id="cardNumber"
                                value={newPaymentMethod.cardNumber}
                                onChange={(e) =>
                                  handleNewPaymentChange(
                                    "cardNumber",
                                    e.target.value
                                  )
                                }
                                placeholder="1234 5678 9012 3456"
                                maxLength={23} // Allow for spacing
                                className={
                                  newPaymentErrors.cardNumber
                                    ? "border-red-500"
                                    : ""
                                }
                              />
                              {newPaymentErrors.cardNumber && (
                                <p className="text-red-500 text-sm">
                                  {newPaymentErrors.cardNumber}
                                </p>
                              )}
                            </div>
                            <div className="gap-4 grid md:grid-cols-2">
                              <div className="space-y-2">
                                <Label htmlFor="cardExpire">Expiry Date</Label>
                                <Input
                                  id="cardExpire"
                                  value={newPaymentMethod.cardExpire}
                                  onChange={(e) =>
                                    handleNewPaymentChange(
                                      "cardExpire",
                                      e.target.value
                                    )
                                  }
                                  placeholder="MM/YY"
                                  maxLength={5}
                                  className={
                                    newPaymentErrors.cardExpire
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {newPaymentErrors.cardExpire && (
                                  <p className="text-red-500 text-sm">
                                    {newPaymentErrors.cardExpire}
                                  </p>
                                )}
                              </div>
                              <div className="space-y-2">
                                <Label htmlFor="cardType">Card Type</Label>
                                <Select
                                  value={newPaymentMethod.cardType}
                                  onValueChange={(value) =>
                                    setNewPaymentMethod((prev) => ({
                                      ...prev,
                                      cardType: value,
                                    }))
                                  }
                                >
                                  <SelectTrigger>
                                    <SelectValue placeholder="Select card type" />
                                  </SelectTrigger>
                                  <SelectContent>
                                    <SelectItem value="Visa">Visa</SelectItem>
                                    <SelectItem value="Mastercard">
                                      Mastercard
                                    </SelectItem>
                                    <SelectItem value="American Express">
                                      American Express
                                    </SelectItem>
                                    <SelectItem value="Discover">
                                      Discover
                                    </SelectItem>
                                  </SelectContent>
                                </Select>
                              </div>
                            </div>
                          </div>
                          <div className="flex gap-2">
                            <Button
                              onClick={handleAddPaymentMethod}
                              disabled={isLoading}
                              size="sm"
                            >
                              {isLoading ? "Adding..." : "Add Payment Method"}
                            </Button>
                            <Button
                              variant="outline"
                              size="sm"
                              onClick={() => setShowAddPayment(false)}
                            >
                              Cancel
                            </Button>
                          </div>
                        </div>
                      </Card>
                    )}
                  </div>

                  <Separator />

                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">Billing History</h3>
                    <p className="text-muted-foreground text-sm">
                      View and download your past invoices and receipts
                    </p>
                    <Button variant="outline">View Billing History</Button>
                  </div>

                  <Separator />

                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">Membership</h3>
                    <div className="space-y-3">
                      <p className="text-muted-foreground text-sm">
                        Manage your membership subscription and benefits
                      </p>

                      {user.membershipTier && (
                        <div className="bg-muted/50 p-4 border rounded-lg">
                          <div className="flex justify-between items-start mb-2">
                            <div>
                              <h4 className="font-medium">
                                {user.membershipTier.name} Member
                              </h4>
                              <p className="text-muted-foreground text-sm">
                                {user.membershipTier.discountPercentage}%
                                discount on all purchases
                              </p>
                            </div>
                            <div
                              className={`px-2 py-1 rounded-full text-xs font-medium ${
                                isMembershipCancelled
                                  ? "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200"
                                  : "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200"
                              }`}
                            >
                              {isMembershipCancelled ? "Cancelled" : "Active"}
                            </div>
                          </div>

                          {user.membershipExpiry && (
                            <p className="text-muted-foreground text-sm">
                              {isMembershipCancelled
                                ? `Benefits end on ${new Date(
                                    user.membershipExpiry
                                  ).toLocaleDateString("en-US", {
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                  })}`
                                : `Renews on ${new Date(
                                    user.membershipExpiry
                                  ).toLocaleDateString("en-US", {
                                    year: "numeric",
                                    month: "long",
                                    day: "numeric",
                                  })}`}
                            </p>
                          )}

                          {isMembershipCancelled &&
                            user.membershipCancellationDate && (
                              <p className="mt-1 text-muted-foreground text-sm">
                                Cancelled on{" "}
                                {new Date(
                                  user.membershipCancellationDate
                                ).toLocaleDateString("en-US", {
                                  year: "numeric",
                                  month: "long",
                                  day: "numeric",
                                })}
                              </p>
                            )}
                        </div>
                      )}
                    </div>

                    <div className="flex gap-2">
                      <Button variant="outline" asChild>
                        <Link href="/membership">View Membership</Link>
                      </Button>
                      {user.membershipTier && !isMembershipCancelled && (
                        <AlertDialog>
                          <AlertDialogTrigger asChild>
                            <Button
                              variant="outline"
                              className="text-destructive hover:text-destructive"
                            >
                              Cancel Membership
                            </Button>
                          </AlertDialogTrigger>
                          <AlertDialogContent>
                            <AlertDialogHeader>
                              <AlertDialogTitle>
                                Are you sure you want to cancel your{" "}
                                {user.membershipTier.name} membership?
                              </AlertDialogTitle>
                            </AlertDialogHeader>
                            <div className="space-y-2">
                              <p>
                                Your membership benefits will remain active
                                until the 21st of this month. If today is after
                                the 21st, your benefits will continue until the
                                21st of next month.
                              </p>
                              <p className="font-medium">
                                You can reactivate your membership at any time
                                before it expires.
                              </p>
                            </div>
                            <AlertDialogFooter>
                              <AlertDialogCancel>
                                Keep Membership
                              </AlertDialogCancel>
                              <AlertDialogAction
                                onClick={handleCancelMembership}
                                disabled={isLoading}
                                className="bg-destructive hover:bg-destructive/90 text-destructive-foreground"
                              >
                                {isLoading
                                  ? "Cancelling..."
                                  : "Cancel Membership"}
                              </AlertDialogAction>
                            </AlertDialogFooter>
                          </AlertDialogContent>
                        </AlertDialog>
                      )}
                      {isMembershipCancelled && (
                        <Button variant="outline" asChild>
                          <Link href="/membership">Reactivate Membership</Link>
                        </Button>
                      )}
                    </div>
                  </div>

                  <Separator />

                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg">Tax Information</h3>
                    <p className="text-muted-foreground text-sm">
                      Manage your tax settings and download tax documents
                    </p>
                    <Button variant="outline">Tax Settings</Button>
                  </div>
                </CardContent>
              </Card>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
```

### Explanation of the Code

This user settings management system represents a enterprise-level implementation of user account control within an e-commerce platform, demonstrating sophisticated patterns for handling sensitive user data, privacy controls, and financial information management. The implementation showcases modern React development practices while maintaining strict security standards and optimal user experience design.

#### Multi-Domain Settings Architecture

The tabbed interface design organizes complex user settings into logical domains (Profile, Privacy, Billing), enabling users to navigate efficiently between different types of account management tasks. This separation of concerns improves cognitive load management while ensuring that related settings are grouped together for intuitive access. The tab system supports extensibility for additional settings domains without compromising the interface's clarity or usability.

#### Profile Management System

The profile management section implements secure personal information handling with real-time validation, data formatting, and error prevention. User identity fields (name, email, phone) include intelligent formatting and validation that adapts to different data types and regional requirements. The password management system follows security best practices with strength validation, confirmation matching, and secure state cleanup after successful changes.

#### Privacy Control and Compliance Framework

The privacy settings implementation provides granular control over user data usage, communication preferences, and third-party data sharing in alignment with modern privacy regulations. The notification management system enables users to customize their communication experience across multiple channels while maintaining compliance with marketing consent requirements. Account deletion functionality includes appropriate confirmation dialogs and security warnings to prevent accidental data loss.

#### Secure Financial Data Management

The billing information section demonstrates PCI-compliant payment method management with secure data formatting, validation, and storage patterns. Payment method addition and editing workflows include real-time validation, card type detection, and secure state management that minimizes exposure of sensitive financial data. The address management system supports international formatting and validation requirements essential for global e-commerce operations.

#### Enterprise-Level User Experience

The component integrates loading states, error handling, success confirmations, and progressive validation to create a professional user experience that builds trust and confidence in the platform's security. The responsive design ensures consistent functionality across devices while maintaining accessibility standards. The implementation balances functionality with intuitive interfaces that encourage user engagement with account management features.

#### Security and Performance Optimization

Throughout the implementation, security considerations take precedence through data masking, secure state management, validation at multiple layers, and proper cleanup of sensitive information. Performance optimizations include efficient state updates, minimal re-rendering, and optimized validation patterns that maintain responsiveness even with complex form interactions. This approach ensures the settings interface can scale to support growing user bases while maintaining security and performance standards.

## Next Steps

Though we’ve successfully implemented key features like the shopping cart, checkout process, and user dashboard, we still haven’t provided our visitors with the ability to purchase a membership—an essential component for offering premium features, exclusive products, or special discounts that drive recurring revenue and customer loyalty.

To address this, let’s [create the membership page](/ecommerce-platform/creating-the-pages/membership), where users can:

- **Learn about membership benefits**:
  Clearly communicate the advantages of becoming a member, such as free shipping, early access to sales, members-only products, loyalty rewards, or personalized recommendations.

- **Compare membership plans**:
  Present multiple subscription options (e.g., monthly, yearly) with transparent pricing and a breakdown of included perks so customers can choose the plan that best suits their needs.

- **Sign up and pay securely**:
  Integrate a reliable payment gateway to handle subscription transactions, ensuring secure processing of recurring payments and compliance with billing standards.

- **Manage membership status**:
  Provide an interface for existing members to upgrade, downgrade, or cancel their membership, giving them full control over their subscription.

- **Access exclusive content or features**:
  Offer immediate access to members-only sections of your platform upon successful signup, enhancing perceived value and reinforcing their decision to join.

The membership page should be designed to highlight the value proposition clearly and motivate visitors to subscribe. It must also be responsive, visually aligned with your platform’s branding, and fully accessible to all users. By implementing a compelling, easy-to-use membership system, you can boost customer engagement, generate predictable revenue, and deepen customer loyalty.

<BackToTop />
