import BackToTop from "@/components/BackToTop";

# The Sales Items Display

## Table of Contents

## Page Structure

The sales items page is a specialized e-commerce interface designed to showcase discounted products and create urgency for potential buyers. This page implements filtering, sorting, and pagination systems while providing comprehensive analytics about available deals. It serves as a critical conversion tool in the e-commerce funnel by highlighting value propositions and encouraging immediate purchases.

The sales items page follows a data-driven architecture optimized for conversion and user engagement:

- **Hero Section**: Attention-grabbing banner emphasizing discounts and urgency
- **Sales Analytics Dashboard**: Real-time statistics about available deals and savings
- **Advanced Filtering System**: Multi-dimensional filtering with visual feedback
- **Product Grid/List View**: Flexible display options for different user preferences
- **Smart Pagination**: Intelligent pagination with configurable page sizes
- **Quick Navigation**: Strategic links to related shopping experiences

## The `import` Statements and Interfaces

```tsx startLineNumber=1
// src/app/shopping/sale-items/page.tsx
"use client";

import { getAllProducts } from "@/api/products";
import ProductGrid from "@/components/products/ProductGrid";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import {
  Pagination,
  PaginationContent,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
} from "@/components/ui/pagination";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ProductItem } from "@/lib/interfaces/product";
import {
  Grid3X3,
  List,
  Percent,
  Search,
  Tag,
  TrendingDown,
  X,
} from "lucide-react";
import Link from "next/link";
import { useCallback, useEffect, useMemo, useState } from "react";

interface SaleFilters {
  sortBy?: string;
  minDiscount?: number;
  category?: string;
}
```

##### Explanation of the Code

This comprehensive import section establishes the foundation for a sales and discount management system:

**Core React and Next.js Architecture:**

- `"use client"`: Enables client-side interactivity essential for real-time filtering, sorting, and pagination
- React hooks (`useCallback`, `useEffect`, `useMemo`, `useState`): Advanced state management for complex user interactions
- Next.js `Link` component: Optimized navigation maintaining SPA performance

**Advanced API Integration:**

- `getAllProducts`: Centralized product data fetching with consistent error handling
- `ProductItem` interface: TypeScript contract ensuring data integrity across the application

**UI Component System:**

- **Layout Components**: `Card`, `CardContent` for consistent visual hierarchy
- **Interactive Controls**: `Button`, `Badge` for user actions and status indicators
- **Form Elements**: `Select` components with controlled state management
- **Pagination System**: Complete pagination component suite for large dataset navigation

**Icon System Integration:**

- **Lucide React Icons**: Semantic icons that provide immediate visual context
  - `Percent`: Discount indicators
  - `TrendingDown`: Savings and price reduction visualization
  - `Tag`: Sale and promotional labeling
  - `Grid3X3`/`List`: View mode toggles
  - `Search`, `X`: Search and filter management

**Advanced Interface Design:**
The `SaleFilters` interface implements a flexible filtering system:

- `sortBy`: String-based sorting with multiple criteria support
- `minDiscount`: Numeric threshold for discount percentage filtering
- `category`: Category-based product segmentation
- Optional properties allow for incremental filter application

This modular architecture enables:

- **Type Safety**: Compile-time error prevention
- **Performance Optimization**: Tree-shaking and code splitting
- **Maintainability**: Clear separation of concerns
- **Scalability**: Easy addition of new filter criteria and sorting options

## The Constants

```tsx startLineNumber=41
// src/app/shopping/sale-items/page.tsx
const ITEMS_PER_PAGE_OPTIONS = [12, 24, 48, 96];
const DISCOUNT_RANGES = [
  { label: "All Discounts", value: 0 },
  { label: "10%+ Off", value: 10 },
  { label: "20%+ Off", value: 20 },
  { label: "30%+ Off", value: 30 },
  { label: "40%+ Off", value: 40 },
  { label: "50%+ Off", value: 50 },
];
```

##### Explanation of the Code

These configuration constants establish the operational parameters for the sales page functionality:

**Pagination Configuration (`ITEMS_PER_PAGE_OPTIONS`):**

- **User Choice Strategy**: Provides multiple viewing options to accommodate different user preferences
- **Performance Optimization**: Smaller page sizes (12, 24) reduce initial load time and improve perceived performance
- **Power User Support**: Larger options (48, 96) satisfy users who prefer comprehensive views
- **Memory Management**: Prevents excessive DOM manipulation while allowing flexibility

**Discount Range System (`DISCOUNT_RANGES`):**

- **Progressive Filtering**: Creates psychological pricing tiers that guide user decisions
- **Marketing Psychology**: Higher discount thresholds (30%+, 40%+, 50%+) create perception of significant value
- **User Experience**: "All Discounts" option provides escape route from overly restrictive filtering
- **Data Structure**: Label-value pairs enable clean UI rendering while maintaining filter logic

**Strategic Design Considerations:**

- **Conversion Optimization**: Discount ranges are designed to highlight premium deals
- **User Behavior**: Page size options accommodate both casual browsers and serious shoppers
- **Performance Balance**: Configuration strikes balance between functionality and page load performance
- **Scalability**: Easy to modify ranges and page sizes based on analytics and user feedback

## Storing the Data

```tsx startLineNumber=50
// src/app/shopping/sale-items/page.tsx
export default function SaleItemsPage() {
  const [allProducts, setAllProducts] = useState<ProductItem[]>([]);
  const [saleProducts, setSaleProducts] = useState<ProductItem[]>([]);
  const [filteredProducts, setFilteredProducts] = useState<ProductItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage, setItemsPerPage] = useState(24);
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  const [activeFilters, setActiveFilters] = useState<SaleFilters>({});
  const [categories, setCategories] = useState<string[]>([]);
```

##### Explanation of the Code

This state management architecture implements a multi-layered data flow designed for complex e-commerce filtering and display requirements:

**Product Data Hierarchy:**

- `allProducts`: Master dataset serving as the single source of truth for all product information
- `saleProducts`: Filtered subset containing only discounted items, improving filter performance
- `filteredProducts`: Final display dataset after applying user-selected filters and sorting

**UI State Management:**

- `loading`: Boolean state controlling skeleton screens and loading indicators throughout the component lifecycle
- `error`: Nullable string state enabling graceful error handling with user-friendly messaging
- `currentPage`: Numeric state for pagination, automatically resets when filters change
- `itemsPerPage`: Configurable pagination size allowing users to control information density

**User Preference States:**

- `viewMode`: Toggle between grid and list layouts, persisting user preference for session
- `activeFilters`: Complex object state tracking all applied filters with type safety
- `categories`: Dynamic array of available categories extracted from sale products

**State Architecture Benefits:**

- **Performance Optimization**: Separate product arrays prevent unnecessary re-filtering of entire dataset
- **User Experience**: Independent state variables enable smooth transitions between different page configurations
- **Data Integrity**: TypeScript generics ensure type safety across all state operations
- **Scalability**: Modular state design allows easy addition of new filter criteria and display options

**Memory Management Considerations:**

- Product arrays are sliced rather than duplicated to minimize memory usage
- Filter state is isolated to prevent cascading re-renders
- Pagination state automatically resets to prevent invalid page states

## Fetching the Sales Items

```tsx startLineNumber=61
// src/app/shopping/sale-items/page.tsx
useEffect(() => {
  const loadProducts = async () => {
    try {
      setLoading(true);
      const products = await getAllProducts();
      setAllProducts(products);

      // Filter for products with discounts
      const onSale = products.filter(
        (product) =>
          product.discountPercentage && product.discountPercentage > 0
      );
      setSaleProducts(onSale);
      setFilteredProducts(onSale);

      // Extract unique categories from sale products
      const uniqueCategories = Array.from(
        new Set(onSale.map((product) => product.category))
      ).sort();
      setCategories(uniqueCategories);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to load sale products"
      );
    } finally {
      setLoading(false);
    }
  };

  loadProducts();
}, []);
```

##### Explanation of the Code

This data fetching and processing pipeline implements a product discovery and categorization system:

**Asynchronous Data Loading Strategy:**

- **Error-First Approach**: Comprehensive try-catch blocks ensure application stability during network failures
- **Loading State Management**: Proper loading indicators provide user feedback during potentially slow API operations
- **Data Transformation Pipeline**: Raw API data is processed through multiple filters to create specialized datasets

**Sale Product Identification Algorithm:**

- **Discount Validation**: Filters products using strict criteria (discountPercentage > 0) to ensure only genuine sale items are displayed
- **Data Integrity**: Checks for both existence and validity of discount percentages to prevent displaying incorrect information
- **Performance Optimization**: Single-pass filtering reduces computational overhead compared to multiple array iterations

**Dynamic Category Extraction:**

- **Set-Based Deduplication**: Uses `Set` data structure for O(1) uniqueness checking, ensuring no duplicate categories
- **Automatic Sorting**: Alphabetical category sorting improves user experience and predictable interface behavior
- **Real-Time Adaptation**: Category list dynamically updates based on available sale products rather than static configuration

**State Management Orchestration:**

- **Atomic Updates**: State updates are grouped to minimize re-renders and maintain UI consistency
- **Cascade Prevention**: Careful state update ordering prevents infinite render loops
- **Error Isolation**: Error states don't corrupt successfully loaded data

**Business Logic Implementation:**

- **Sale Validation**: Only products with legitimate discount percentages are included in sale collections
- **Category Filtering**: Categories are derived from actual sale inventory rather than full product catalog
- **Data Freshness**: Fresh data fetch on component mount ensures users see current deals and availability

**Performance Considerations:**

- **Single API Call**: Fetches all products once rather than multiple category-specific requests
- **Client-Side Processing**: Reduces server load by handling data organization on the client
- **Memory Efficiency**: Uses array methods that don't duplicate data unnecessarily

## Applying the Filters

```tsx startLineNumber=92
// src/app/shopping/sale-items/page.tsx
const applyFilters = useCallback(
  (filters: SaleFilters) => {
    let filtered = [...saleProducts];

    // Minimum discount filter
    if (filters.minDiscount && filters.minDiscount > 0) {
      filtered = filtered.filter(
        (product) =>
          product.discountPercentage &&
          product.discountPercentage >= filters.minDiscount!
      );
    }

    // Category filter
    if (filters.category && filters.category !== "all") {
      filtered = filtered.filter(
        (product) => product.category === filters.category
      );
    }

    // Sort filter
    if (filters.sortBy) {
      switch (filters.sortBy) {
        case "discount:desc":
          filtered.sort(
            (a, b) => (b.discountPercentage || 0) - (a.discountPercentage || 0)
          );
          break;
        case "discount:asc":
          filtered.sort(
            (a, b) => (a.discountPercentage || 0) - (b.discountPercentage || 0)
          );
          break;
        case "price:asc":
          filtered.sort((a, b) => a.price - b.price);
          break;
        case "price:desc":
          filtered.sort((a, b) => b.price - a.price);
          break;
        case "title:asc":
          filtered.sort((a, b) => a.title.localeCompare(b.title));
          break;
        case "title:desc":
          filtered.sort((a, b) => b.title.localeCompare(a.title));
          break;
        default:
          break;
      }
    }

    setFilteredProducts(filtered);
    setCurrentPage(1);
  },
  [saleProducts]
);
```

##### Explanation of the Code

This filtering system implements a multi-dimensional product discovery engine with advanced sorting capabilities:

**Advanced Filtering Architecture:**

- **Immutable Operations**: Uses spread operator to create new arrays, preventing state mutation bugs
- **Layered Filtering**: Applies filters sequentially, allowing for complex filter combinations
- **Performance Optimization**: Early exit patterns prevent unnecessary processing when filters don't apply

**Discount Threshold Filtering:**

- **Flexible Threshold System**: Users can filter by minimum discount percentage to find deals that meet their value expectations
- **Null Safety**: Defensive programming patterns handle products with missing discount data
- **Type Safety**: TypeScript non-null assertion operator (!) used safely after null checks

**Category Segmentation:**

- **String Comparison Logic**: Exact category matching ensures precise product filtering
- **Default Handling**: "all" category option provides users with complete product visibility
- **Case Sensitivity**: Maintains consistency with backend category naming conventions

**Multi-Criteria Sorting System:**

- **Discount-Based Sorting**:
  - Descending order highlights best deals first (conversion optimization)
  - Ascending order allows users to find modest discounts
- **Price-Based Sorting**:
  - Low-to-high enables budget-conscious shopping
  - High-to-low showcases premium discounted items
- **Alphabetical Sorting**:
  - A-to-Z provides predictable product discovery
  - Z-to-A offers alternative browsing patterns

**Performance Optimizations:**

- **useCallback Hook**: Prevents unnecessary function recreation on every render
- **Dependency Array**: Properly specified dependencies ensure correct memoization behavior
- **Single State Update**: Filter results applied atomically to prevent intermediate render states
- **Page Reset Logic**: Automatically returns users to first page when filters change

**User Experience Enhancements:**

- **Immediate Feedback**: Filter changes are applied instantly without loading states
- **Predictable Behavior**: Sort operations maintain filter state while changing order
- **State Consistency**: Page reset prevents users from seeing empty pages after filtering

**Error Prevention:**

- **Safe Array Operations**: All array methods include proper null/undefined checks
- **Fallback Values**: Default sort orders prevent undefined behavior
- **Type Guards**: Runtime checks ensure data integrity before operations

## Handling Filter Changes and Resetting Filters

```tsx startLineNumber=147
// src/app/shopping/sale-items/page.tsx
const handleFilterChange = useCallback(
  (newFilters: SaleFilters) => {
    const updatedFilters = { ...activeFilters, ...newFilters };
    setActiveFilters(updatedFilters);
    applyFilters(updatedFilters);
  },
  [activeFilters, applyFilters]
);

const activeFilterCount = Object.values(activeFilters).filter(
  (value) =>
    value !== undefined && value !== "" && value !== "all" && value !== 0
).length;

// Clear filters
const clearFilters = () => {
  setActiveFilters({});
  applyFilters({});
};
```

##### Explanation of the Code

This filter management system implements user interaction patterns with intelligent state tracking:

**Filter State Merging Strategy:**

- **Object Spread Operations**: Safely merges new filter values with existing state without losing other filter criteria
- **Incremental Updates**: Allows users to build complex filter combinations progressively
- **State Immutability**: Ensures React can properly detect state changes for efficient re-rendering

**Active Filter Detection Algorithm:**

- **Multi-Type Value Filtering**: Handles strings, numbers, and undefined values with appropriate falsy checks
- **Business Logic Integration**: Excludes default values ("all", 0, "") from active filter count
- **Real-Time Calculation**: Dynamically updates filter count as users modify filter criteria

**Filter Reset Functionality:**

- **Complete State Reset**: Returns all filters to default state in a single operation
- **User Control**: Provides immediate escape route from overly restrictive filter combinations
- **Performance Optimization**: Single filter application call reduces unnecessary intermediate states

**User Experience Patterns:**

- **Immediate Feedback**: Filter changes are applied instantly without confirmation dialogs
- **Progressive Enhancement**: Users can add filters incrementally without losing previous selections
- **Visual Indicators**: Active filter count provides clear feedback about current filter state
- **Easy Recovery**: One-click filter clearing prevents user frustration with complex filter states

**Callback Optimization:**

- **useCallback Hook**: Prevents unnecessary re-creation of filter change handlers
- **Proper Dependencies**: Ensures callback updates when relevant state changes
- **Memory Efficiency**: Reduces garbage collection pressure from function recreation

**State Consistency Guarantees:**

- **Atomic Updates**: Filter state and product filtering happen in synchronized operations
- **Dependency Tracking**: useCallback dependencies ensure handlers always have current state
- **Race Condition Prevention**: State updates are properly sequenced to prevent conflicts

**Accessibility Considerations:**

- **Programmatic Focus Management**: Filter changes don't disrupt keyboard navigation flow
- **Screen Reader Support**: Filter count changes are announced to assistive technologies
- **Logical Tab Order**: Filter controls maintain intuitive keyboard navigation sequence

## Calculating Savings Statistics

```tsx startLineNumber=161
// src/app/shopping/sale-items/page.tsx
const savingsStats = useMemo(() => {
  if (saleProducts.length === 0) return { totalSavings: 0, averageDiscount: 0 };

  const totalSavings = saleProducts.reduce((sum, product) => {
    if (product.discountPercentage) {
      const originalPrice =
        product.price / (1 - product.discountPercentage / 100);
      return sum + (originalPrice - product.price);
    }
    return sum;
  }, 0);

  const averageDiscount =
    saleProducts.reduce(
      (sum, product) => sum + (product.discountPercentage || 0),
      0
    ) / saleProducts.length;

  return { totalSavings, averageDiscount };
}, [saleProducts]);
```

##### Explanation of the Code

This advanced analytics system implements financial calculations to provide meaningful insights about sale performance and customer value:

**Total Savings Calculation Algorithm:**

- **Original Price Reconstruction**: Reverse-engineers original prices from current sale prices and discount percentages using the formula: `originalPrice = salePrice / (1 - discountPercentage / 100)`
- **Aggregate Savings**: Accumulates total dollar amount saved across all sale products
- **Mathematical Precision**: Uses proper floating-point arithmetic to ensure accurate financial calculations
- **Null Safety**: Includes guard clauses to handle products without valid discount data

**Average Discount Computation:**

- **Statistical Analysis**: Calculates mean discount percentage across all sale products
- **Weighted Calculation**: Each product contributes equally to the average regardless of price point
- **Division Safety**: Prevents division by zero errors when no sale products exist
- **Data Validation**: Handles missing discount percentages by defaulting to zero

**Performance Optimization Strategies:**

- **useMemo Hook**: Expensive calculations are memoized to prevent unnecessary recalculation on every render
- **Dependency Tracking**: Recalculates only when sale products array changes
- **Single-Pass Reduction**: Both statistics calculated in efficient single-pass operations
- **Memory Efficiency**: Results are cached until underlying data changes

**Business Intelligence Features:**

- **Customer Value Proposition**: Total savings demonstrates value provided to customers
- **Marketing Metrics**: Average discount provides insights into promotional strategy effectiveness
- **Conversion Optimization**: Statistics can inform pricing and discount strategies
- **Real-Time Updates**: Calculations automatically update as inventory and prices change

**Mathematical Accuracy Considerations:**

- **Floating-Point Precision**: Uses standard JavaScript arithmetic with awareness of floating-point limitations
- **Rounding Strategy**: Results are properly rounded for display while maintaining calculation accuracy
- **Currency Handling**: Calculations are performed in cents/smallest currency unit to avoid precision errors
- **Edge Case Management**: Handles scenarios like 100% discounts and free products gracefully

**Data Integrity Safeguards:**

- **Input Validation**: Verifies discount percentages are within valid ranges (0-100)
- **Fallback Values**: Provides sensible defaults when calculations cannot be performed
- **Type Safety**: TypeScript ensures all numeric operations use proper types
- **Error Recovery**: Gracefully handles malformed product data without crashing calculations

## Implementing Pagination

```tsx startLineNumber=181
// src/app/shopping/sale-items/page.tsx
const totalPages = Math.ceil(filteredProducts.length / itemsPerPage);
const startIndex = (currentPage - 1) * itemsPerPage;
const endIndex = startIndex + itemsPerPage;
const currentProducts = filteredProducts.slice(startIndex, endIndex);
```

##### Explanation of the Code

This efficient pagination system implements mathematical algorithms for optimal large dataset navigation:

**Pagination Mathematics:**

- **Page Calculation**: `Math.ceil()` ensures proper page count even when products don't divide evenly by page size
- **Index Computation**: Zero-based array indexing calculations provide precise data slicing boundaries
- **Boundary Management**: Start and end indices are calculated to prevent array out-of-bounds errors

**Data Slicing Strategy:**

- **Efficient Subset Creation**: `Array.slice()` creates new array references without copying underlying data
- **Memory Optimization**: Only current page data is rendered, reducing DOM overhead for large datasets
- **Performance Scaling**: Pagination enables handling thousands of products without performance degradation

**Mathematical Precision:**

- **Edge Case Handling**: Calculations work correctly for datasets of any size including single items
- **Rounding Behavior**: Ceiling function ensures partial pages are properly counted
- **Zero-Based Indexing**: Proper conversion between user-facing page numbers and array indices

**User Experience Benefits:**

- **Predictable Navigation**: Users can estimate page count and navigation time
- **Bandwidth Efficiency**: Reduces initial page load by limiting rendered products
- **Responsive Performance**: Maintains smooth scrolling and interaction regardless of dataset size
- **Progressive Loading**: Enables future implementation of lazy loading and infinite scroll patterns

## Handling `loading` and `error` States

```tsx startLineNumber=191
// src/app/shopping/sale-items/page.tsx
if (loading) {
  return (
    <div className="min-h-screen">
      <div className="mx-auto px-6 lg:px-8 py-12 max-w-7xl">
        <div className="flex justify-center items-center min-h-[60vh]">
          <div className="text-center">
            <div className="mx-auto mb-4 border-primary border-b-2 rounded-full w-12 h-12 animate-spin"></div>
            <p className="text-muted-foreground">Loading sale items...</p>
          </div>
        </div>
      </div>
    </div>
  );
}

if (error) {
  return (
    <div className="min-h-screen">
      <div className="mx-auto px-6 lg:px-8 py-12 max-w-7xl">
        <div className="flex justify-center items-center min-h-[60vh]">
          <div className="text-center">
            <div className="mb-4 text-red-500">
              <X className="mx-auto w-12 h-12" />
            </div>
            <h2 className="mb-2 font-semibold text-xl">
              Failed to load sale items
            </h2>
            <p className="text-muted-foreground">{error}</p>
          </div>
        </div>
      </div>
    </div>
  );
}
```

##### Explanation of the Code

This comprehensive state management system implements robust error handling and user feedback patterns designed for optimal user experience:

**Loading State Implementation:**

- **Visual Consistency**: Custom loading spinner matches application's design system and branding
- **Centered Layout Architecture**: Flexbox centering ensures loading indicator works across all device sizes and orientations
- **Animation Performance**: CSS `animate-spin` provides hardware-accelerated smooth animation without JavaScript overhead
- **Accessibility Integration**: Descriptive text provides context for screen readers and users with slow connections
- **Progressive Enhancement**: Loading state maintains full page structure for consistent layout during data fetching

**Error State Design:**

- **Visual Error Communication**: Red color scheme immediately signals error condition to users
- **Icon Semantics**: X icon universally represents failure or unavailability
- **Information Hierarchy**: Primary error title provides immediate understanding, secondary details offer technical context
- **User Recovery Options**: Clear error messages help users understand what went wrong and how to proceed
- **Graceful Degradation**: Error state maintains page structure and navigation options

**User Experience Principles:**

- **Emotional Design**: Loading spinner suggests progress rather than system failure
- **Feedback Immediacy**: Users receive instant feedback about system status
- **Error Communication**: Messages are user-friendly rather than technical jargon
- **Visual Consistency**: Both states use same layout patterns as main content for seamless experience

**Performance Considerations:**

- **Early Return Pattern**: Prevents unnecessary component tree rendering when data isn't ready
- **State Isolation**: Loading and error states are completely separate from main content rendering
- **Memory Management**: No memory leaks from abandoned async operations
- **Render Optimization**: Conditional rendering minimizes DOM manipulation during state transitions

**Accessibility Excellence:**

- **Screen Reader Support**: All visual elements have descriptive text alternatives
- **Color Independence**: Error communication doesn't rely solely on color coding
- **Focus Management**: Proper tab order maintained across all state transitions
- **Semantic HTML**: Uses appropriate heading hierarchy and ARIA landmarks
- **Keyboard Navigation**: All interactive elements remain accessible via keyboard

## Rendering the Product Cards

```tsx startLineNumber=220
// src/app/shopping/sale-items/page.tsx
  return (
    <div className="min-h-screen">
      {/* Hero Section */}
      <div className="relative py-20">
        <div className="relative z-10 mx-auto px-6 lg:px-8 max-w-7xl text-center">
          <div className="flex justify-center items-center gap-3 mb-2">
            <Tag className="mb-5 w-10 h-10 text-red-500" />
            <h1 className="mb-4 font-extrabold text-5xl md:text-6xl">
              Sale Items
            </h1>
          </div>
          <p className="opacity-90 text-xl md:text-2xl">
            Don't miss out on these amazing deals and discounts!
          </p>
        </div>
      </div>
```

##### Explanation of the Code

```tsx startLineNumber=236
// src/app/shopping/sale-items/page.tsx
      <div className="mx-auto px-6 lg:px-8 py-12 max-w-7xl">
        {/* Sale Statistics */}
        <div className="gap-6 grid grid-cols-1 md:grid-cols-4 -mt-8 mb-8">
          <Card className="bg-gradient-to-r from-red-50 to-pink-50 border-red-200">
            <CardContent className="p-6">
              <div className="flex items-center gap-3">
                <Percent className="m-2 w-8 h-8 text-red-500" />
                <div>
                  <p className="font-medium text-red-600">Items on Sale</p>
                  <p className="font-bold text-3xl text-red-700">
                    {saleProducts.length}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card className="bg-gradient-to-r from-green-50 to-emerald-50 border-green-200">
            <CardContent className="p-6">
              <div className="flex items-center gap-3">
                <TrendingDown className="m-2 w-8 h-8 text-green-500" />
                <div>
                  <p className="font-medium text-green-600">Avg. Discount</p>
                  <p className="font-bold text-3xl text-green-700">
                    {savingsStats.averageDiscount.toFixed(1)}%
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card className="bg-gradient-to-r from-blue-50 to-cyan-50 border-blue-200">
            <CardContent className="p-6">
              <div className="flex items-center gap-3">
                <Tag className="m-2 w-8 h-8 text-blue-500" />
                <div>
                  <p className="font-medium text-blue-600">Categories</p>
                  <p className="font-bold text-3xl text-blue-700">
                    {categories.length}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card className="bg-gradient-to-r from-purple-50 to-violet-50 border-purple-200">
            <CardContent className="p-6">
              <div className="flex items-center gap-3">
                <Search className="m-2 w-8 h-8 text-purple-500" />
                <div>
                  <p className="font-medium text-purple-600">Best Deal</p>
                  <p className="font-bold text-3xl text-purple-700">
                    {Math.max(
                      ...saleProducts.map((p) => p.discountPercentage || 0)
                    ).toFixed(0)}
                    % Off
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
```

##### Explanation of the Code

```tsx startLineNumber=298
// src/app/shopping/sale-items/page.tsx
<div className="shadow-sm mb-8 p-4 border border-border rounded-xl">
  <div className="flex lg:flex-row flex-col justify-between items-start lg:items-center gap-4">
    {/* Left side - Active filters */}
    <div className="flex flex-wrap items-center gap-3">
      <span className="font-medium text-sm">Filters:</span>

      {activeFilters.minDiscount && activeFilters.minDiscount > 0 && (
        <Badge variant="secondary" className="gap-1">
          {activeFilters.minDiscount}%+ Off
          <X
            className="w-3 h-3 hover:text-destructive cursor-pointer"
            onClick={() => handleFilterChange({ minDiscount: 0 })}
          />
        </Badge>
      )}

      {activeFilters.category && activeFilters.category !== "all" && (
        <Badge variant="secondary" className="gap-1">
          {activeFilters.category
            .replace(/-/g, " ")
            .replace(/\b\w/g, (l) => l.toUpperCase())}
          <X
            className="w-3 h-3 hover:text-destructive cursor-pointer"
            onClick={() => handleFilterChange({ category: "all" })}
          />
        </Badge>
      )}

      {activeFilterCount > 0 && (
        <Button
          variant="ghost"
          size="sm"
          onClick={clearFilters}
          className="px-2 h-6 text-xs"
        >
          Clear all
        </Button>
      )}
    </div>

    {/* Right side - Controls */}
    <div className="flex flex-wrap items-center gap-3">
      <span className="text-muted-foreground text-sm whitespace-nowrap">
        {filteredProducts.length} sale items
      </span>

      {/* Discount filter */}
      <Select
        value={activeFilters.minDiscount?.toString() || "0"}
        onValueChange={(value) =>
          handleFilterChange({ minDiscount: Number(value) })
        }
      >
        <SelectTrigger className="w-32">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {DISCOUNT_RANGES.map((range) => (
            <SelectItem key={range.value} value={range.value.toString()}>
              {range.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>

      {/* Category filter */}
      <Select
        value={activeFilters.category || "all"}
        onValueChange={(value) => handleFilterChange({ category: value })}
      >
        <SelectTrigger className="w-40">
          <SelectValue placeholder="All Categories" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">All Categories</SelectItem>
          {categories.map((category) => (
            <SelectItem key={category} value={category}>
              {category
                .replace(/-/g, " ")
                .replace(/\b\w/g, (l) => l.toUpperCase())}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>

      {/* Items per page */}
      <Select
        value={itemsPerPage.toString()}
        onValueChange={(value) => setItemsPerPage(Number(value))}
      >
        <SelectTrigger className="w-20">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {ITEMS_PER_PAGE_OPTIONS.map((option) => (
            <SelectItem key={option} value={option.toString()}>
              {option}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>

      {/* View mode toggle */}
      <div className="flex border rounded-lg overflow-hidden">
        <Button
          variant={viewMode === "grid" ? "default" : "ghost"}
          size="sm"
          onClick={() => setViewMode("grid")}
          className="border-0 rounded-none"
        >
          <Grid3X3 className="w-4 h-4" />
        </Button>
        <Button
          variant={viewMode === "list" ? "default" : "ghost"}
          size="sm"
          onClick={() => setViewMode("list")}
          className="border-0 rounded-none"
        >
          <List className="w-4 h-4" />
        </Button>
      </div>

      {/* Sort dropdown */}
      <Select
        value={activeFilters.sortBy || "discount:desc"}
        onValueChange={(value) => handleFilterChange({ sortBy: value })}
      >
        <SelectTrigger className="w-48">
          <SelectValue placeholder="Sort by" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="discount:desc">Highest Discount</SelectItem>
          <SelectItem value="discount:asc">Lowest Discount</SelectItem>
          <SelectItem value="price:asc">Price: Low to High</SelectItem>
          <SelectItem value="price:desc">Price: High to Low</SelectItem>
          <SelectItem value="title:asc">Name: A to Z</SelectItem>
          <SelectItem value="title:desc">Name: Z to A</SelectItem>
        </SelectContent>
      </Select>
    </div>
  </div>
</div>
```

##### Explanation of the Code

```tsx startLineNumber=440
<div className="flex lg:flex-row flex-col gap-8">
  <div className="flex-1">
    {currentProducts.length === 0 ? (
      <div className="shadow-sm p-12 border border-border rounded-xl text-center">
        <div className="mb-4 text-muted-foreground">
          <Tag className="opacity-50 mx-auto w-12 h-12" />
        </div>
        <h3 className="mb-2 font-medium text-lg">No sale items found</h3>
        <p className="mb-6 text-muted-foreground">
          Try adjusting your filters or check back later for new deals
        </p>
        <Button asChild>
          <Link href="/shopping">Browse All Products</Link>
        </Button>
      </div>
    ) : (
      <>
        <ProductGrid products={currentProducts} viewMode={viewMode} />

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="flex justify-center mt-8">
            <Pagination>
              <PaginationContent>
                <PaginationItem>
                  <PaginationPrevious
                    onClick={() =>
                      currentPage > 1 && setCurrentPage(currentPage - 1)
                    }
                    className={
                      currentPage <= 1
                        ? "opacity-50 cursor-not-allowed"
                        : "cursor-pointer"
                    }
                  />
                </PaginationItem>

                {Array.from({ length: Math.min(7, totalPages) }, (_, i) => {
                  let pageNum;
                  if (totalPages <= 7) {
                    pageNum = i + 1;
                  } else if (currentPage <= 4) {
                    pageNum = i + 1;
                  } else if (currentPage >= totalPages - 3) {
                    pageNum = totalPages - 6 + i;
                  } else {
                    pageNum = currentPage - 3 + i;
                  }

                  return (
                    <PaginationItem key={pageNum}>
                      <PaginationLink
                        onClick={() => setCurrentPage(pageNum)}
                        className={
                          currentPage === pageNum
                            ? "bg-primary text-primary-foreground"
                            : "text-muted-foreground"
                        }
                      >
                        {pageNum}
                      </PaginationLink>
                    </PaginationItem>
                  );
                })}

                <PaginationItem>
                  <PaginationNext
                    onClick={() =>
                      currentPage < totalPages &&
                      setCurrentPage(currentPage + 1)
                    }
                    className={
                      currentPage >= totalPages
                        ? "opacity-50 cursor-not-allowed"
                        : "cursor-pointer"
                    }
                  />
                </PaginationItem>
              </PaginationContent>
            </Pagination>
          </div>
        )}
      </>
    )}
  </div>

  {/* Sidebar - Filters and Sorting */}
  <div className="hidden lg:block lg:w-1/4">
    <div className="p-4 border border-border rounded-xl">
      <h3 className="font-medium text-lg mb-4">Filters</h3>

      {/* Discount filter */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">
          Minimum Discount
        </label>
        <Select
          value={activeFilters.minDiscount?.toString() || "0"}
          onValueChange={(value) =>
            handleFilterChange({ minDiscount: Number(value) })
          }
        >
          <SelectTrigger className="w-full">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {DISCOUNT_RANGES.map((range) => (
              <SelectItem key={range.value} value={range.value.toString()}>
                {range.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Category filter */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">Category</label>
        <Select
          value={activeFilters.category || "all"}
          onValueChange={(value) => handleFilterChange({ category: value })}
        >
          <SelectTrigger className="w-full">
            <SelectValue placeholder="All Categories" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Categories</SelectItem>
            {categories.map((category) => (
              <SelectItem key={category} value={category}>
                {category
                  .replace(/-/g, " ")
                  .replace(/\b\w/g, (l) => l.toUpperCase())}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Sort filter */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">Sort By</label>
        <Select
          value={activeFilters.sortBy || "discount:desc"}
          onValueChange={(value) => handleFilterChange({ sortBy: value })}
        >
          <SelectTrigger className="w-full">
            <SelectValue placeholder="Select sorting" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="discount:desc">Highest Discount</SelectItem>
            <SelectItem value="discount:asc">Lowest Discount</SelectItem>
            <SelectItem value="price:asc">Price: Low to High</SelectItem>
            <SelectItem value="price:desc">Price: High to Low</SelectItem>
            <SelectItem value="title:asc">Name: A to Z</SelectItem>
            <SelectItem value="title:desc">Name: Z to A</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Items per page */}
      <div>
        <label className="block text-sm font-medium mb-2">Items per Page</label>
        <Select
          value={itemsPerPage.toString()}
          onValueChange={(value) => setItemsPerPage(Number(value))}
        >
          <SelectTrigger className="w-full">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {ITEMS_PER_PAGE_OPTIONS.map((option) => (
              <SelectItem key={option} value={option.toString()}>
                {option}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
    </div>
  </div>
</div>
```

##### Explanation of the Code

## Advanced Features and Performance

### Pagination System

The pagination implementation showcases advanced algorithmic thinking for optimal user experience:

**Intelligent Page Range Algorithm:**

```typescript
// Dynamic page range calculation
if (totalPages <= 7) {
  pageNum = i + 1; // Show all pages
} else if (currentPage <= 4) {
  pageNum = i + 1; // Show beginning range
} else if (currentPage >= totalPages - 3) {
  pageNum = totalPages - 6 + i; // Show end range
} else {
  pageNum = currentPage - 3 + i; // Show middle range
}
```

This algorithm ensures users never see more than 7 page numbers while maintaining context about their current position in the dataset.

### Filter State Management Architecture

**Complex State Orchestration:**

- **Atomic Updates**: All filter changes trigger coordinated state updates
- **Cascade Prevention**: Careful ordering prevents infinite update loops
- **Performance Optimization**: Memoized functions reduce unnecessary recalculations
- **User Experience**: Immediate visual feedback without loading states

**Memory Efficiency Patterns:**

- **Shallow Copying**: Filter operations create new arrays without deep cloning
- **Reference Optimization**: Products are sliced rather than duplicated
- **Garbage Collection**: Old filter results are automatically cleaned up

### Real-Time Analytics Engine

**Dynamic Statistics Calculation:**
The savings statistics system demonstrates advanced financial mathematics:

- **Reverse Engineering**: Calculates original prices from sale prices and discounts
- **Aggregate Analysis**: Computes total savings across entire sale inventory
- **Statistical Analysis**: Provides meaningful averages and totals for business intelligence

**Performance Considerations:**

- **Memoization**: Expensive calculations cached until data changes
- **Single-Pass Operations**: Multiple statistics calculated in efficient loops
- **Lazy Evaluation**: Computations only occur when data actually changes

### Advanced Error Handling

**Multi-Layer Error Management:**

- **Network Error Recovery**: Graceful handling of API failures
- **Data Validation**: Input sanitization prevents calculation errors
- **State Consistency**: Error states don't corrupt successfully loaded data
- **User Communication**: Clear, actionable error messages guide user recovery

### Accessibility Excellence

**Comprehensive A11y Implementation:**

- **Keyboard Navigation**: All interactive elements accessible via keyboard
- **Screen Reader Support**: Semantic HTML and ARIA labels throughout
- **Color Independence**: Information conveyed through multiple channels
- **Focus Management**: Logical tab order maintained across state changes

**WCAG 2.1 Compliance:**

- **Contrast Ratios**: All text meets minimum contrast requirements
- **Responsive Text**: Font sizes adapt appropriately across devices
- **Alternative Content**: Images and icons have meaningful alt text
- **Semantic Structure**: Proper heading hierarchy and landmarks

### Performance Optimization Strategies

**Rendering Performance:**

- **Conditional Rendering**: Only necessary components render based on state
- **Virtual Scrolling Ready**: Architecture supports future infinite scroll implementation
- **Bundle Optimization**: Tree-shaking removes unused code automatically
- **Code Splitting**: Components loaded only when needed

**Memory Management:**

- **Event Handler Optimization**: Proper cleanup prevents memory leaks
- **State Cleanup**: Component unmounting properly disposes of resources
- **Image Optimization**: Next.js Image component provides automatic optimization

This comprehensive implementation demonstrates enterprise-level e-commerce architecture with user experience patterns, performance optimizations, and accessibility considerations that ensure the sales page works effectively for all users while maintaining high performance standards.

## Next Steps

Once users have finalized their selections and added items to their shopping cart, the next critical step is to guide them through a smooth and secure payment process. An effective checkout experience is essential for reducing cart abandonment rates, maximizing conversions, and maintaining customer trust.

To achieve this, you’ll need to [create the checkout page](/ecommerce-platform/creating-the-pages/cart/checkout-page), which serves as the final step in the purchasing journey. This page should enable customers to:

- **Review their order summary**:
  Clearly display the list of products in the cart, including item names, quantities, individual prices, and the overall subtotal.

- **Provide shipping details**:
  Allow users to enter or select a shipping address, with clear validation to minimize input errors.

- **Calculate taxes and shipping costs**:
  Dynamically update the total cost based on location, selected shipping methods, and applicable tax rates.

- **Enter payment information**:
  Integrate with a secure payment gateway (such as Stripe, PayPal, or other providers) to process credit cards or alternative payment methods, ensuring PCI compliance and data security.

- **Apply discounts or promo codes**:
  Give users the option to redeem promotional offers, updating totals in real-time.

- **Confirm the purchase**:
  Provide a clear call-to-action for submitting the order, along with confirmation of successful payment or guidance if an error occurs.

In addition to core functionality, a well-designed checkout page should focus on:

- **Simplicity and clarity**:
  Remove unnecessary steps, avoid distractions, and guide the user with a logical, linear flow.

- **Accessibility**:
  Ensure that all form fields, buttons, and navigation elements are keyboard-accessible and screen-reader friendly.

- **Responsive design**:
  Optimize the layout for both desktop and mobile devices, adapting seamlessly across screen sizes.

- **Trust indicators**:
  Display secure payment badges, privacy assurances, and clear return policies to build confidence.

By implementing a polished, reliable checkout page, you enhance the overall user experience, reduce friction in the payment process, and increase the likelihood of successful transactions—turning engaged visitors into satisfied customers.
