import BackToTop from "@/components/BackToTop";

# Validation Utility Functions

## Table of Contents

## Introduction

Validation utility functions are essential for ensuring that user input meets specific criteria before being processed or stored. These functions help maintain data integrity, enhance user experience, and prevent errors in your e-commerce platform. By implementing robust validation logic, you can ensure that users provide valid information, such as addresses and credit card details, which is crucial for successful transactions and overall platform reliability.

##### NOTE

<blockquote>
A couple of these utility functions are quite long and will be chunked up into multiple code blocks to ensure readability. Each section will have its own explanation below to help you understand the purpose and functionality of each part.

Take note of the line numbers in the code blocks, as they will help you navigate through the code and understand how each part fits together.

</blockquote>

## The `import` Statements

```typescript
// src/lib/utils/validate.ts
import {
  POSTAL_CODE_PATTERNS,
  VALID_COUNTRIES,
  VALID_STATES,
} from "../constants/validate/address";
import {
  AddressValidationError,
  AddressValidationResult,
  ValidatedAddress,
} from "../interfaces/address";
```

## Validating Address Fields from Form inputs

We will be defining the address validation utility functions for our e-commerce platform. This will help us ensure that addresses are valid and formatted correctly before being processed or stored.

```typescript startLineNumber=12
// src/lib/utils/validate.ts

/**
 * Real-time field validation for form inputs
 */
export function validateAddressField(
  field: keyof ValidatedAddress,
  value: string,
  address?: Partial<ValidatedAddress>
): string | null {
  const trimmedValue = value.trim();

  switch (field) {
    case "address":
      if (!trimmedValue) return "Street address is required";
      if (trimmedValue.length < 5)
        return "Street address must be at least 5 characters long";
      if (trimmedValue.length > 100)
        return "Street address must not exceed 100 characters";
      if (/^\d+$/.test(trimmedValue))
        return "Street address must contain more than just numbers";
      if (!/^[a-zA-Z0-9\s\-'.,#\/]+$/.test(trimmedValue))
        return "Street address contains invalid characters";
      break;

    case "city":
      if (!trimmedValue) return "City is required";
      if (trimmedValue.length < 2)
        return "City must be at least 2 characters long";
      if (trimmedValue.length > 50) return "City must not exceed 50 characters";
      if (!/^[a-zA-Z\s\-'\.]+$/.test(trimmedValue))
        return "City can only contain letters, spaces, hyphens, apostrophes, and periods";
      break;

    case "state":
      if (!trimmedValue) return "State/Province is required";
      if (trimmedValue.length < 2)
        return "State/Province must be at least 2 characters long";
      if (trimmedValue.length > 50)
        return "State/Province must not exceed 50 characters";
      if (address?.country) {
        const validStates =
          VALID_STATES[
            address.country.toUpperCase() as keyof typeof VALID_STATES
          ];
        if (validStates && !validStates.includes(trimmedValue.toUpperCase())) {
          return `Invalid state/province code for ${address.country.toUpperCase()}`;
        }
      }
      break;

    case "postalCode":
      if (!trimmedValue) return "Postal/ZIP code is required";
      if (trimmedValue.length < 3)
        return "Postal/ZIP code must be at least 3 characters long";
      if (trimmedValue.length > 10)
        return "Postal/ZIP code must not exceed 10 characters";
      if (address?.country) {
        const pattern =
          POSTAL_CODE_PATTERNS[
            address.country.toUpperCase() as keyof typeof POSTAL_CODE_PATTERNS
          ];
        if (pattern && !pattern.test(trimmedValue)) {
          return `Invalid postal code format for ${address.country.toUpperCase()}`;
        }
      }
      break;

    case "country":
      if (!trimmedValue) return "Country is required";
      if (trimmedValue.length !== 2)
        return "Country must be a valid 2-letter code (e.g., US, CA, GB)";
      if (!isValidCountry(trimmedValue)) return "Invalid country code";
      break;

    default:
      return null;
  }

  return null;
}
```

##### Explanation of the Code

- The `validateAddressField` function performs real-time validation of individual address fields based on the provided field name and value. It checks for required fields, length constraints, character validity, and country-specific rules.
- The function uses a switch statement to handle different address fields (`address`, `city`, `state`, `postalCode`, and `country`).
- For each field, it applies specific validation rules:
  - **Street Address**: Checks for non-empty value, minimum length, maximum length, and valid characters.
  - **City**: Validates that the city name is non-empty, has a minimum and maximum length, and contains only valid characters.
  - **State/Province**: Ensures the state/province is valid for the specified country, checking against a predefined list of valid states.
  - **Postal/ZIP Code**: Validates the postal code format based on the country, ensuring it matches the expected pattern.
  - **Country**: Checks that the country code is a valid 2-letter code and exists in the list of valid countries.

<BackToTop />

## Validating Full Address Objects

```typescript startLineNumber=92
// src/lib/utils/validate.ts

/**
 * Comprehensive address validation with enhanced features
 */
export function validateAddressEnhanced(
  address: Partial<ValidatedAddress>
): AddressValidationResult {
  const errors: AddressValidationError[] = [];

  // Required field validation
  if (!address.address?.trim()) {
    errors.push({ field: "address", message: "Street address is required" });
  } else {
    const trimmedAddress = address.address.trim();
    if (trimmedAddress.length < 5) {
      errors.push({
        field: "address",
        message: "Street address must be at least 5 characters long",
      });
    } else if (trimmedAddress.length > 100) {
      errors.push({
        field: "address",
        message: "Street address must not exceed 100 characters",
      });
    }
    // Check for suspicious patterns (all numbers, suspicious characters)
    if (/^\d+$/.test(trimmedAddress)) {
      errors.push({
        field: "address",
        message: "Street address must contain more than just numbers",
      });
    }
    if (!/^[a-zA-Z0-9\s\-'.,#\/]+$/.test(trimmedAddress)) {
      errors.push({
        field: "address",
        message: "Street address contains invalid characters",
      });
    }
  }
```

##### Explanation of the Code

If you recall our `AddressValidationResult` interface, it contains an array of `AddressValidationError` objects. Each error object has a `field` and a `message`. This allows us to return multiple validation errors for different fields in a single function call.

- The `validateAddressEnhanced` function performs comprehensive validation of an address object, checking for required fields, suspicious patterns, and country-specific rules.
- It initializes an empty array `errors` to collect validation errors.
- The function checks if the `address` field is provided and trims any whitespace. It validates the length, checks for suspicious patterns (like all numbers), and ensures valid characters are used.
- If any validation fails, it pushes an error object into the `errors` array with the appropriate field and message.

```typescript startLineNumber=131
if (!address.city?.trim()) {
  errors.push({ field: "city", message: "City is required" });
} else {
  const trimmedCity = address.city.trim();
  if (trimmedCity.length < 2) {
    errors.push({
      field: "city",
      message: "City must be at least 2 characters long",
    });
  } else if (trimmedCity.length > 50) {
    errors.push({
      field: "city",
      message: "City must not exceed 50 characters",
    });
  } else if (!/^[a-zA-Z\s\-'\.]+$/.test(trimmedCity)) {
    errors.push({
      field: "city",
      message:
        "City can only contain letters, spaces, hyphens, apostrophes, and periods",
    });
  }
}
```

- The function checks if the `city` field is provided and trims any whitespace. It validates the length, checks for valid characters, and ensures the city name is not too short or too long. If any validation fails, it adds an error object to the `errors` array.

```typescript startLineNumber=154
if (!address.state?.trim()) {
  errors.push({ field: "state", message: "State/Province is required" });
} else {
  const trimmedState = address.state.trim();
  if (trimmedState.length < 2) {
    errors.push({
      field: "state",
      message: "State/Province must be at least 2 characters long",
    });
  } else if (trimmedState.length > 50) {
    errors.push({
      field: "state",
      message: "State/Province must not exceed 50 characters",
    });
  }
}
```

- The function checks if the `state` field is provided and trims any whitespace. It validates the length and ensures the state/province name is not too short or too long. If any validation fails, it adds an error object to the `errors` array.

```typescript startLineNumber=171
if (!address.postalCode?.trim()) {
  errors.push({
    field: "postalCode",
    message: "Postal/ZIP code is required",
  });
} else {
  const trimmedPostalCode = address.postalCode.trim();
  if (trimmedPostalCode.length < 3) {
    errors.push({
      field: "postalCode",
      message: "Postal/ZIP code must be at least 3 characters long",
    });
  } else if (trimmedPostalCode.length > 10) {
    errors.push({
      field: "postalCode",
      message: "Postal/ZIP code must not exceed 10 characters",
    });
  }
}
```

- The function checks if the `postalCode` field is provided and trims any whitespace. It validates the length and ensures the postal/ZIP code is not too short or too long. If any validation fails, it adds an error object to the `errors` array.

```typescript startLineNumber=191
if (!address.country?.trim()) {
  errors.push({ field: "country", message: "Country is required" });
} else {
  const trimmedCountry = address.country.trim().toUpperCase();
  if (trimmedCountry.length !== 2) {
    errors.push({
      field: "country",
      message: "Country must be a valid 2-letter code (e.g., US, CA, GB)",
    });
  } else if (!isValidCountry(trimmedCountry)) {
    errors.push({ field: "country", message: "Invalid country code" });
  }
}
```

- The function checks if the `country` field is provided and trims any whitespace. It validates that the country code is a valid 2-letter code and exists in the list of valid countries. If any validation fails, it adds an error object to the `errors` array.

```typescript startLineNumber=205
// Country-specific validation
if (address.country && address.postalCode) {
  const countryCode = address.country.toUpperCase();
  const pattern =
    POSTAL_CODE_PATTERNS[countryCode as keyof typeof POSTAL_CODE_PATTERNS];

  if (pattern && !pattern.test(address.postalCode.trim())) {
    errors.push({
      field: "postalCode",
      message: `Invalid postal code format for ${countryCode}`,
    });
  }
}
```

- The function checks if both `country` and `postalCode` fields are provided. It retrieves the postal code pattern for the specified country and validates the postal code against this pattern. If the postal code does not match the expected format, it adds an error object to the `errors` array.

```typescript startLineNumber=219
// State validation for specific countries
if (address.country && address.state) {
  const countryCode = address.country.toUpperCase();
  const validStates = VALID_STATES[countryCode as keyof typeof VALID_STATES];

  if (validStates && !validStates.includes(address.state.toUpperCase())) {
    errors.push({
      field: "state",
      message: `Invalid state/province code for ${countryCode}`,
    });
  }
}
```

- The function checks if both `country` and `state` fields are provided. It retrieves the list of valid states for the specified country and validates the state against this list. If the state is not valid for the specified country, it adds an error object to the `errors` array.

```typescript startLineNumber=232
  return {
    isValid: errors.length === 0,
    errors,
  };
}
```

- Finally, the function returns an `AddressValidationResult` object containing a boolean `isValid` indicating whether the address is valid and an array of `errors` if any validation errors were found. If there are no errors, `isValid` will be `true`, and the `errors` array will be empty.

<BackToTop />

## Validating Address Objects with Comprehensive Checks

```typescript startLineNumber=238
/**
 * Validates an address object with comprehensive checks
 */
export function validateAddress(
  address: Partial<ValidatedAddress>
): AddressValidationResult {
  const errors: AddressValidationError[] = [];

  // Required field validation
  if (!address.address?.trim()) {
    errors.push({ field: "address", message: "Street address is required" });
  } else if (address.address.trim().length < 5) {
    errors.push({
      field: "address",
      message: "Street address must be at least 5 characters long",
    });
  } else if (address.address.trim().length > 100) {
    errors.push({
      field: "address",
      message: "Street address must not exceed 100 characters",
    });
  }

  if (!address.city?.trim()) {
    errors.push({ field: "city", message: "City is required" });
  } else if (address.city.trim().length < 2) {
    errors.push({
      field: "city",
      message: "City must be at least 2 characters long",
    });
  } else if (address.city.trim().length > 50) {
    errors.push({
      field: "city",
      message: "City must not exceed 50 characters",
    });
  } else if (!/^[a-zA-Z\s\-'\.]+$/.test(address.city.trim())) {
    errors.push({
      field: "city",
      message:
        "City can only contain letters, spaces, hyphens, apostrophes, and periods",
    });
  }

  if (!address.state?.trim()) {
    errors.push({ field: "state", message: "State/Province is required" });
  } else if (address.state.trim().length < 2) {
    errors.push({
      field: "state",
      message: "State/Province must be at least 2 characters long",
    });
  } else if (address.state.trim().length > 50) {
    errors.push({
      field: "state",
      message: "State/Province must not exceed 50 characters",
    });
  }

  if (!address.postalCode?.trim()) {
    errors.push({
      field: "postalCode",
      message: "Postal/ZIP code is required",
    });
  } else if (address.postalCode.trim().length < 3) {
    errors.push({
      field: "postalCode",
      message: "Postal/ZIP code must be at least 3 characters long",
    });
  } else if (address.postalCode.trim().length > 10) {
    errors.push({
      field: "postalCode",
      message: "Postal/ZIP code must not exceed 10 characters",
    });
  }

  if (!address.country?.trim()) {
    errors.push({ field: "country", message: "Country is required" });
  } else if (address.country.trim().length !== 2) {
    errors.push({
      field: "country",
      message: "Country must be a valid 2-letter code (e.g., US, CA, GB)",
    });
  }

  // Country-specific validation
  if (address.country && address.postalCode) {
    const countryCode = address.country.toUpperCase();
    const pattern =
      POSTAL_CODE_PATTERNS[countryCode as keyof typeof POSTAL_CODE_PATTERNS];

    if (pattern && !pattern.test(address.postalCode.trim())) {
      errors.push({
        field: "postalCode",
        message: `Invalid postal code format for ${countryCode}`,
      });
    }
  }

  // State validation for specific countries
  if (address.country && address.state) {
    const countryCode = address.country.toUpperCase();
    const validStates = VALID_STATES[countryCode as keyof typeof VALID_STATES];

    if (validStates && !validStates.includes(address.state.toUpperCase())) {
      errors.push({
        field: "state",
        message: `Invalid state/province code for ${countryCode}`,
      });
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}
```

##### Explanation of the Code

- The `validateAddress` function performs comprehensive validation of an address object, checking for required fields, suspicious patterns, and country-specific rules.
- It initializes an empty array `errors` to collect validation errors.
- The function checks if the `address`, `city`, `state`, `postalCode`, and `country` fields are provided and trims any whitespace. It validates the length, checks for valid characters, and ensures the address components are not too short or too long. If any validation fails, it adds an error object to the `errors` array.
- The function checks if both `country` and `postalCode` fields are provided. It retrieves the postal code pattern for the specified country and validates the postal code against this pattern. If the postal code does not match the expected format, it adds an error object to the `errors` array.
- The function checks if both `country` and `state` fields are provided. It retrieves the list of valid states for the specified country and validates the state against this list. If the state is not valid for the specified country, it adds an error object to the `errors` array.
- Finally, the function returns an `AddressValidationResult` object containing a boolean `isValid` indicating whether the address is valid and an array of `errors` if any validation errors were found. If there are no errors, `isValid` will be `true`, and the `errors` array will be empty.

<BackToTop />

## Handling Addresses

```typescript startLineNumber=354
/**
 * Validates and normalizes an address
 */
export function validateAndNormalizeAddress(
  address: Partial<ValidatedAddress>
): {
  isValid: boolean;
  errors: AddressValidationError[];
  normalizedAddress?: ValidatedAddress;
} {
  const validation = validateAddress(address);

  if (!validation.isValid) {
    return validation;
  }

  // Normalize the address
  const normalizedAddress: ValidatedAddress = {
    address: address.address!.trim(),
    city: address.city!.trim().replace(/\b\w/g, (l) => l.toUpperCase()), // Title case
    state: address.state!.trim().toUpperCase(),
    postalCode: address.postalCode!.trim().toUpperCase(),
    country: address.country!.trim().toUpperCase(),
  };

  return {
    isValid: true,
    errors: [],
    normalizedAddress,
  };
}
```

##### Explanation of the Code

- The `validateAndNormalizeAddress` function first validates the provided address using the `validateAddress` function.
- If the address is not valid, it returns the validation result with errors.
- If the address is valid, it normalizes the address by trimming whitespace, converting the city to title case, and converting the state, postal code, and country to uppercase.
- Finally, it returns an object containing `isValid`, an empty `errors` array, and the normalized address.

## Quick Address Validation

```typescript startLineNumber=386
/**
 * Quick validation for address fields
 */
export function isValidPostalCode(
  postalCode: string,
  country: string
): boolean {
  const pattern =
    POSTAL_CODE_PATTERNS[
      country.toUpperCase() as keyof typeof POSTAL_CODE_PATTERNS
    ];
  return pattern
    ? pattern.test(postalCode.trim())
    : postalCode.trim().length >= 3;
}
```

##### Explanation of the Code

- The `isValidPostalCode` function performs a quick validation of a postal code against the postal code patterns defined for different countries.
- It retrieves the pattern for the specified country and checks if the postal code matches the pattern. If no pattern is defined for the country, it checks if the postal code is at least 3 characters long.
- The function returns `true` if the postal code is valid and `false` otherwise.

## Retrieving Valid States

```typescript startLineNumber=402
/**
 * Get valid states for a country
 */
export function getValidStates(country: string): string[] | null {
  return (
    VALID_STATES[country.toUpperCase() as keyof typeof VALID_STATES] || null
  );
}
```

##### Explanation of the Code

- The `getValidStates` function retrieves the list of valid states for a specified country.
- It checks the `VALID_STATES` constant for the provided country code (converted to uppercase) and returns the corresponding list of valid states.
- If no valid states are found for the country, it returns `null`.

## Checking Valid States

```typescript startLineNumber=411
/**
 * Check if a state is valid for a country
 */
export function isValidState(state: string, country: string): boolean {
  const validStates = getValidStates(country);
  return validStates ? validStates.includes(state.toUpperCase()) : true;
}
```

##### Explanation of the Code

- The `isValidState` function checks if a given state is valid for a specified country.
- It retrieves the list of valid states for the country using the `getValidStates` function.
- If valid states are found, it checks if the provided state (converted to uppercase) is included in the list of valid states.
- If no valid states are found for the country, it returns `true`, allowing any state to be considered valid in that case.

## Checking Valid Countries

```typescript startLineNumber=419
/**
 * Check if a country code is valid
 */
export function isValidCountry(country: string): boolean {
  return VALID_COUNTRIES.includes(country.toUpperCase());
}
```

##### Explanation of the Code

- The `isValidCountry` function checks if a given country code is valid by verifying its presence in the `VALID_COUNTRIES` constant.
- It converts the provided country code to uppercase and checks if it exists in the list of valid countries.
- The function returns `true` if the country code is valid and `false` otherwise.

## Retrieving Valid Countries

```typescript startLineNumber=426
/**
 * Get all valid country codes
 */
export function getValidCountries(): string[] {
  return [...VALID_COUNTRIES];
}
```

##### Explanation of the Code

- The `getValidCountries` function retrieves all valid country codes from the `VALID_COUNTRIES` constant.
- It returns a new array containing all the valid country codes, allowing you to use them in dropdowns or other UI components where users can select a country.

## Next Steps

Now that we have implemented the validation utility functions for addresses, we can ensure that user input is clean and consistent across our e-commerce platform. These functions will help us maintain data integrity and enhance the user experience by providing real-time feedback on address fields.

Let's head on over to the next section and implement the [payment utility functions](ecommerce-platform/utility-functions-and-validation-constants/payment-utility-functions). This will help us ensure that payment information is valid and formatted correctly before being processed or stored.

<BackToTop />
