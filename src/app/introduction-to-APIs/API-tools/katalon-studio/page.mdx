import BackToTop from "@/components/BackToTop";
import Button from "@/components/Button";
import { FaChevronRight } from "react-icons/fa";

# Katalon Studio

## Table of Contents

## Introduction

[Katalon Studio](https://katalon.com/download-studio-free) is a comprehensive test automation platform that revolutionizes how teams approach quality assurance across web, mobile, API, and desktop applications. Built on proven open-source foundations like Selenium and Appium, Katalon Studio provides an intelligent, unified testing environment that scales from individual testers to enterprise-level operations.

What sets Katalon Studio apart is its hybrid approach to test automation—combining intuitive low-code/no-code test creation with full scripting capabilities in Groovy. This flexibility makes it accessible to manual testers transitioning to automation while providing the depth experienced SDETs need for complex testing scenarios. The platform's AI-powered StudioAssist feature further accelerates test creation by suggesting automation steps and generating code snippets.

Katalon Studio excels in API testing with native support for REST, SOAP, and GraphQL protocols. Teams can import existing API definitions from Swagger, Postman, or WSDL files, eliminating the need to recreate tests from scratch. The platform's robust schema validation, parameterization capabilities, and built-in assertion library ensure comprehensive API coverage.

The integration ecosystem is extensive, with seamless connections to popular CI/CD tools (Jenkins, GitLab, Azure DevOps), test management systems, and cloud platforms. Katalon TestOps provides centralized test orchestration, analytics, and reporting, while Katalon TestCloud offers on-demand test execution across multiple browser and mobile environments without infrastructure maintenance.

With over 104,000 community members and adoption by industry leaders like Petronas, NVIDIA, and IBM, Katalon Studio has proven its value in accelerating software delivery while maintaining high quality standards. The platform serves organizations of all sizes, from startups seeking cost-effective automation to enterprises requiring advanced security, compliance, and scalability features.

#### Key Features

| Feature                                | Description                                                                           |
| -------------------------------------- | ------------------------------------------------------------------------------------- |
| **Unified testing platform**           | Test web, mobile, desktop, and API applications in a single integrated platform       |
| **AI-powered StudioAssist**            | Intelligent test generation and code suggestions to accelerate automation             |
| **Multi-protocol API support**         | Native support for REST, SOAP, GraphQL with OpenAPI/Swagger/WSDL import capabilities  |
| **Hybrid project architecture**        | Seamlessly combine API, web, and mobile testing with shared data and test objects     |
| **Schema validation**                  | Validate API responses against JSON Schema and XML Schema with built-in keywords      |
| **Low-code and full-code flexibility** | Record & playback, keyword-driven testing, and full Groovy scripting capabilities     |
| **Data-driven testing**                | Parameterize tests with CSV, Excel, databases, and external data sources              |
| **Self-healing test objects**          | Automatically adapt to UI changes using AI-powered object identification (Enterprise) |
| **Comprehensive reporting**            | Built-in HTML, PDF, JUnit reports with execution analytics and trend analysis         |
| **CI/CD integration**                  | Native plugins for Jenkins, GitLab, Azure DevOps, GitHub Actions, and CLI support     |
| **TestCloud execution**                | On-demand test execution across 3000+ browser/OS/device combinations                  |
| **TestOps orchestration**              | Centralized test management, scheduling, and analytics with team collaboration        |
| **Visual testing**                     | Image comparison and visual regression testing with AI-powered analysis               |
| **Cross-platform IDE**                 | Available on Windows, macOS, and Linux with consistent feature sets                   |
| **Extensive integration ecosystem**    | 200+ integrations with testing tools, ALM systems, and development platforms          |

## Getting Started

Katalon Studio offers multiple deployment options to fit different team needs and organizational requirements. The free version provides robust API testing capabilities ideal for individual developers and small teams, while enterprise plans add advanced features like AI-powered testing, cloud execution, and enhanced security.

### Understanding Katalon's Product Ecosystem

Katalon Studio is part of a comprehensive testing ecosystem:

- **Katalon Studio**: Core IDE for test authoring and local execution
- **Katalon Runtime Engine (KRE)**: CLI-based execution engine for CI/CD integration
- **Katalon TestCloud**: Cloud-based test execution across multiple environments
- **Katalon TestOps**: Test management, analytics, and collaboration platform
- **TrueTest**: AI-powered test generation that converts manual actions to automated scripts

### System Requirements

| Component            | Windows                         | macOS                           | Linux                           |
| -------------------- | ------------------------------- | ------------------------------- | ------------------------------- |
| **Operating System** | Windows 10+ (64-bit)            | macOS 10.14+                    | Ubuntu 18.04+, CentOS 7+        |
| **Memory (RAM)**     | 8 GB minimum, 16 GB recommended | 8 GB minimum, 16 GB recommended | 8 GB minimum, 16 GB recommended |
| **Storage**          | 2 GB available space            | 2 GB available space            | 2 GB available space            |
| **Java**             | OpenJDK 8, 11, or 17            | OpenJDK 8, 11, or 17            | OpenJDK 8, 11, or 17            |
| **Browser Support**  | Chrome, Firefox, Edge, IE11     | Chrome, Firefox, Safari         | Chrome, Firefox                 |

### Choosing the Right Plan

Katalon Studio's pricing structure is designed to scale with your testing needs, from individual contributors to enterprise teams requiring advanced features and compliance.

| Feature Comparison                   | Free (Forever) | Create ($84/month) | Expand ($168/month) | Scale (Custom) |
| ------------------------------------ | -------------- | ------------------ | ------------------- | -------------- |
| **Test Authoring**                   |                |                    |                     |                |
| Low-code & full-code testing         |              |                  |                   |              |
| Web, mobile, desktop, API testing    |              |                  |                   |              |
| Custom keywords & BDD support        |              |                  |                   |              |
| Object repository management         |              |                  |                   |              |
| **Advanced Features**                |                |                    |                     |                |
| StudioAssist (AI-powered testing)    |              |                  |                   |              |
| Self-healing test objects            |              |                  |                   |              |
| Advanced reporting & analytics       |              |                  |                   |              |
| Test packaged apps                   |              |                  |                   |              |
| **Execution & Deployment**           |                |                    |                     |                |
| Local test execution                 |              |                  |                   |              |
| Runtime Engine (CLI execution)       |              |                  |                   |              |
| TestCloud (cloud execution)          |              |                  |                   |              |
| Advanced web testing                 |              |                  |                   |              |
| **Enterprise & Support**             |                |                    |                     |                |
| Community support                    |              |                  |                   |              |
| 24/5 professional support            |              |                  |                   |              |
| Dedicated support agent              |              |                  |                   |              |
| User/license management              |              |                  |                   |              |
| Private cloud/on-premises deployment |              |                  |                   |              |
| SSO & advanced security              |              |                  |                   |              |

#### Free Plan Capabilities

The free version includes:

- Complete API testing suite (REST, SOAP, GraphQL)
- Web and mobile test automation
- Data-driven testing with external data sources
- Basic reporting and test execution
- Community support and documentation
- Access to Katalon Academy training courses

#### When to Upgrade

Consider upgrading when you need:

- **Create Plan**: AI assistance, advanced reporting, professional support
- **Expand Plan**: Cloud execution, CI/CD integration, team collaboration
- **Scale Plan**: Enterprise security, compliance, dedicated support

### Installation and Setup

Getting started with Katalon Studio is straightforward and requires minimal configuration:

#### Step-by-Step Installation

1. **Download Katalon Studio**
   - Visit [katalon.com/download](https://katalon.com/download-studio-free)
   - Choose your operating system (Windows, macOS, or Linux)
   - Select the appropriate version (Free or Enterprise trial)

2. **Install Java (if needed)**

   ```bash
   # Check if Java is installed
   java -version

   # Install OpenJDK on Ubuntu/Debian
   sudo apt update
   sudo apt install openjdk-11-jdk

   # Install on macOS using Homebrew
   brew install openjdk@11

   # Install on Windows
   # Download from https://adoptium.net/ and run installer
   ```

3. **Run the Installer**
   - **Windows**: Run the `.exe` installer with administrator privileges
   - **macOS**: Mount the `.dmg` file and drag Katalon Studio to Applications
   - **Linux**: Extract the `.tar.gz` and run the executable

4. **Initial Configuration**

   ```bash
   # Set JAVA_HOME environment variable (if needed)
   export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64

   # Add to ~/.bashrc or ~/.zshrc for persistence
   echo 'export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64' >> ~/.bashrc
   ```

5. **Launch and Activate**
   - Start Katalon Studio
   - Create a Katalon account (for licensing and community access)
   - Choose workspace location
   - Configure proxy settings if behind corporate firewall

#### Post-Installation Setup

##### Browser Configuration

```groovy
// Configure Chrome options in Project Settings
ChromeOptions options = new ChromeOptions()
options.addArguments("--disable-web-security")
options.addArguments("--disable-features=VizDisplayCompositor")
options.addArguments("--headless") // For headless execution
```

##### API Testing Setup

- Configure SSL certificates for HTTPS endpoints
- Set up authentication tokens and API keys
- Configure proxy settings for corporate environments

### Pricing

Katalon Studio follows a user-based pricing model with plans designed to scale from individual contributors to enterprise teams:

| Plan       | Annual Price (per user) | Monthly Price (per user) | Best For                         |
| ---------- | ----------------------- | ------------------------ | -------------------------------- |
| **Free**   | $0                      | $0                       | Individual developers, learning  |
| **Create** | $1,008 ($84/month)      | $109                     | Small teams, getting started     |
| **Expand** | $2,016 ($168/month)     | $218                     | Growing teams, CI/CD integration |
| **Scale**  | Custom pricing          | Custom pricing           | Enterprise, compliance needs     |

_All paid plans include 20% savings with annual billing. Monthly plans available at listed rates._

#### Additional Products (Optional Add-ons)

| Product            | Annual Price (per session) | Purpose                           |
| ------------------ | -------------------------- | --------------------------------- |
| **Runtime Engine** | $1,749 ($182 monthly)      | CLI execution for CI/CD pipelines |
| **TestCloud**      | $1,749-$1,899              | Cloud test execution environments |
| **TrueTest**       | Contact sales              | AI-powered test generation        |
| **TestOps**        | Contact sales              | Advanced test management platform |

#### Volume Discounts and Enterprise Options

- **Volume discounts**: Available for teams with 10+ users
- **Multi-year agreements**: Additional savings for 2-3 year commitments
- **AWS Marketplace**: Purchase through AWS for simplified procurement
- **Enterprise sales**: Custom solutions with dedicated support for large organizations

<BackToTop />

## Using Katalon Studio

Katalon Studio provides multiple approaches to API testing, from visual test creation to advanced scripting. The platform's flexibility allows teams to choose the methodology that best fits their skill level and project requirements.

### Creating Your First API Project

1. **Start a New Project**
   - Launch Katalon Studio
   - Click **File** → **New** → **Project**
   - Choose **API/Web Service** as the project type
   - Set project location and name
   - Select template (Generic, Web Service, or Hybrid)

2. **Project Structure Overview**
   ```
   MyAPIProject/
     Object Repository/          # API endpoints and test objects
         RESTful/               # REST API objects
         SOAP/                  # SOAP service objects
         GraphQL/               # GraphQL query objects
     Test Cases/                # Individual test scenarios
     Test Suites/               # Grouped test executions
     Test Suite Collections/    # Batch test execution
     Data Files/                # Test data sources
     Profiles/                  # Environment configurations
     Reports/                   # Execution results
   ```

### API Test Object Creation

#### Creating REST API Objects

1. **Using the Visual Editor**
   - Right-click **Object Repository** → **New** → **Web Service Request**
   - Select **RESTful** as the request type
   - Configure the endpoint details:

   ```http
   Method: GET
   URL: https://jsonplaceholder.typicode.com/users/{id}

   Headers:
   Content-Type: application/json
   Authorization: Bearer ${token}

   Path Parameters:
   id = 1

   Query Parameters:
   include = posts,comments
   ```

2. **Advanced Request Configuration**

   ```groovy
   // Custom headers with variables
   request.headers.put('X-API-Key', GlobalVariable.apiKey)
   request.headers.put('User-Agent', 'Katalon-Studio/8.6.0')

   // Request body for POST/PUT operations
   def requestBody = '''
   {
     "name": "${name}",
     "email": "${email}",
     "address": {
       "street": "${address.street}",
       "city": "${address.city}"
     }
   }
   '''
   ```

   <BackToTop />

#### SOAP Service Objects

1. **Import from WSDL**
   - Click **Import WSDL** in the Web Service Request dialog
   - Enter WSDL URL: `http://webservices.oorsprong.org/websamples.countryinfo/CountryInfoService.wso?WSDL`
   - Katalon automatically generates service objects and methods

2. **Configure SOAP Request**
   ```xml
   <!-- SOAP Envelope -->
   <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
     <soap:Body>
       <tns:CountryName xmlns:tns="http://www.oorsprong.org/websamples.countryinfo">
         <tns:sCountryISOCode>US</tns:sCountryISOCode>
       </tns:CountryName>
     </soap:Body>
   </soap:Envelope>
   ```

#### GraphQL Query Objects

```graphql
# GraphQL Query Example
query GetUser($id: ID!, $includeProfile: Boolean = false) {
  user(id: $id) {
    id
    name
    email
    profile @include(if: $includeProfile) {
      bio
      avatar
    }
  }
}

# Variables
{
  "id": "123",
  "includeProfile": true
}
```

<BackToTop />

### Organizing Test Cases

Organizing your test cases in Katalon Studio is essential for maintaining a clean and manageable project structure. You can create folders to group related test cases, making it easier to navigate and execute tests.

- Right-click on the **Test Cases** folder in the **Test Explorer**
- Select <Button variant="tertiary" className="mx-1">New Folder</Button>
- Enter a name for the folder (e.g., "API Tests")
- Drag and drop test cases into the newly created folder to organize them logically

#### Using Test Suite Collections

Test Suite Collections in Katalon Studio allow you to group multiple test suites and run them together. This is useful for executing a set of related tests, such as regression tests or smoke tests.

- Right-click on the **Test Suite Collections** folder in the **Test Explorer**
- Select <Button variant="tertiary" className="mx-1">New Test Suite Collection</Button>
- Enter a name for the collection (e.g., "API Regression Tests")
- Add existing test suites to the collection by dragging and dropping them into the collection
- You can also configure execution settings, such as parallel execution or environment variables, for the test suite collection
- To run the test suite collection, right-click on it and select <Button variant="tertiary" className="mx-1">Run</Button>
- Katalon Studio will execute all the test suites in the collection and provide a summary of the results in the **Log Viewer**

#### Managing Test Cases and Test Suites

Katalon Studio provides a user-friendly interface for managing test cases and test suites. You can easily create, edit, and delete test cases, as well as organize them into test suites for better management.

- To edit a test case, double-click on it in the **Test Explorer** to open the test case editor
- You can modify the test steps, assertions, and data bindings as needed
- To delete a test case, right-click on it in the **Test Explorer** and select <Button variant="tertiary" className="mx-1">Delete</Button>
- To create a new test suite, right-click on the **Test Suites** folder in the **Test Explorer**
- Select <Button variant="tertiary" className="mx-1">New Test Suite</Button>
- Enter a name for the test suite and click <Button variant="tertiary" className="mx-1">Ok</Button>
- In the test suite editor, you can add test cases by dragging and dropping them from the **Test Explorer**
- You can also configure the execution settings for the test suite, such as parallel execution or environment variables
- To run a test suite, right-click on it in the **Test Explorer** and select <Button variant="tertiary" className="mx-1">Run</Button>
- Katalon Studio will execute all the test cases in the suite and provide a summary of the results in the **Log Viewer**

#### Using Test Objects

Test objects in Katalon Studio represent the API endpoints you want to test. You can create test objects for each endpoint, specifying the HTTP method, URL, headers, and body content.

- Right-click on the **Object Repository** folder in the **Test Explorer**
- Select <Button variant="tertiary" className="mx-1">New</Button>
- Choose <Button variant="tertiary" className="mx-1">Test Object</Button>
- Enter a name for the test object (e.g., "Get User")
- In the test object editor, specify the HTTP method (GET, POST, PUT, DELETE, etc.), URL, headers, and body content
- You can also add parameters to the test object to make it reusable for different scenarios
- Save the test object, and it will be available in the **Object Repository** for use in your test cases
- To use the test object in a test case, drag and drop it from the **Object Repository** into the test case editor
  <BackToTop />

### Using Groovy Scripts

Katalon Studio supports Groovy scripting, allowing you to write custom scripts for advanced test scenarios. You can use Groovy to manipulate data, perform complex assertions, or integrate with external libraries.

- In the test case editor, click on the **Script** tab to switch to the Groovy script editor
- Write your Groovy code to perform the desired actions, such as sending API requests, parsing responses, or validating data
- You can use Katalon Studio's built-in keywords and methods to interact with the API and perform assertions
- For example, you can use `WS.sendRequest()` to send an API request and `WS.verifyResponseStatusCode()` to validate the response status code

#### Using Data-Driven Testing

Data-driven testing in Katalon Studio allows you to run the same test case with multiple sets of input data. This is useful for testing different scenarios without duplicating test cases.

- Create a data file (CSV, Excel, or database) containing the input data
- In the test case editor, click on the **Data Binding** tab
- Select the data file and map the columns to the variables in your test case
- Use the Data Binding feature to parameterize your test case with data from external sources (e.g., CSV, Excel)

```groovy
// Example of using data-driven testing with a CSV file
import com.kms.katalon.core.testdata.TestDataFactory as TestDataFactory
TestData data = TestDataFactory.findTestData('Data Files/YourDataFile')
for (int i = 1; i <= data.getRowNumbers(); i++) {
    String name = data.getValue('Name', i)
    String email = data.getValue('Email', i)

    // Use the variables in your API request
    WS.sendRequest(findTestObject('API/YourTestObject', [('name') : name, ('email') : email]))
}
```

<BackToTop />

### Generating Reports

Katalon Studio provides built-in reporting capabilities to help you analyze test results and track the quality of your API endpoints. You can generate detailed reports that include execution history, logs, and assertions.

- After running your test cases, navigate to the **Reports** tab
- Select the report type (e.g., HTML, PDF, JUnit)
- Click on the <Button variant="tertiary" className="mx-1">Generate</Button> button to create the report
- Review the report to see the execution results, including passed and failed assertions, response times, and any errors encountered during testing
- You can also export the report to share with your team or stakeholders

### CI/CD Integration and Automation

#### Katalon Runtime Engine (KRE) Setup

```bash
# Download and install KRE
wget https://github.com/katalon-studio/katalon-studio/releases/latest/download/katalon-runtime-engine-linux.tar.gz
tar -xzf katalon-runtime-engine-linux.tar.gz

# Set execution permissions
chmod +x katalon-runtime-engine/katalonc

# Environment setup
export PATH=$PATH:/path/to/katalon-runtime-engine
export KATALON_LICENSE_KEY="your-license-key"
```

#### Jenkins Integration

```groovy
// Jenkinsfile for Katalon test execution
pipeline {
    agent any

    environment {
        KATALON_PROJECT = '/var/lib/jenkins/workspace/api-tests'
        KATALON_REPORTS = '/var/lib/jenkins/workspace/reports'
        API_BASE_URL = credentials('api-base-url')
        API_TOKEN = credentials('api-token')
    }

    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', url: 'https://github.com/company/api-tests.git'
            }
        }

        stage('Setup Environment') {
            steps {
                script {
                    // Set global variables for test execution
                    sh """
                        echo "api.baseUrl=${API_BASE_URL}" > Profiles/CI.properties
                        echo "auth.token=${API_TOKEN}" >> Profiles/CI.properties
                    """
                }
            }
        }

        stage('Execute API Tests') {
            steps {
                script {
                    sh """
                        katalonc -noSplash -runMode=console \\
                            -projectPath="${KATALON_PROJECT}" \\
                            -retry=1 \\
                            -testSuiteCollectionPath="Test Suites/API Test Suite Collection" \\
                            -executionProfile="CI" \\
                            -browserType="Chrome (headless)" \\
                            -reportFolder="${KATALON_REPORTS}" \\
                            --config \\
                            -proxy.auth.option=NO_PROXY \\
                            -proxy.system.option=NO_PROXY \\
                            -webui.autoUpdateDrivers=true
                    """
                }
            }
        }

        stage('Process Results') {
            steps {
                // Publish test results
                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    reportDir: "${KATALON_REPORTS}",
                    reportFiles: 'Reports/*/execution.html',
                    reportName: 'Katalon Test Report'
                ])

                // Archive artifacts
                archiveArtifacts artifacts: "${KATALON_REPORTS}/**/*", fingerprint: true

                // Send notifications based on results
                script {
                    if (currentBuild.currentResult == 'SUCCESS') {
                        slackSend(
                            channel: '#qa-automation',
                            color: 'good',
                            message: " API Tests Passed - Build #${env.BUILD_NUMBER}"
                        )
                    } else {
                        slackSend(
                            channel: '#qa-automation',
                            color: 'danger',
                            message: " API Tests Failed - Build #${env.BUILD_NUMBER}"
                        )
                    }
                }
            }
        }
    }

    post {
        always {
            // Cleanup workspace
            cleanWs()
        }
        failure {
            // Send failure notifications
            emailext (
                subject: "API Test Failure - Build ${env.BUILD_NUMBER}",
                body: "API tests failed. Check the build logs for details.",
                to: "${env.CHANGE_AUTHOR_EMAIL}"
            )
        }
    }
}
```

<BackToTop />

#### GitHub Actions Integration

```yaml
# .github/workflows/api-tests.yml
name: API Test Automation

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: "0 2 * * *" # Daily at 2 AM

jobs:
  api-tests:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        environment: [dev, staging]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          java-version: "11"
          distribution: "temurin"

      - name: Download Katalon Runtime Engine
        run: |
          wget -q https://github.com/katalon-studio/katalon-studio/releases/latest/download/katalon-runtime-engine-linux.tar.gz
          tar -xzf katalon-runtime-engine-linux.tar.gz
          chmod +x katalon-runtime-engine/katalonc

      - name: Configure test environment
        run: |
          echo "api.baseUrl=${{ secrets[format('API_BASE_URL_{0}', matrix.environment)] }}" > Profiles/${{ matrix.environment }}.properties
          echo "auth.token=${{ secrets[format('API_TOKEN_{0}', matrix.environment)] }}" >> Profiles/${{ matrix.environment }}.properties

      - name: Execute Katalon tests
        run: |
          ./katalon-runtime-engine/katalonc -noSplash -runMode=console \
            -projectPath="$GITHUB_WORKSPACE" \
            -retry=2 \
            -testSuiteCollectionPath="Test Suites/API Regression Tests" \
            -executionProfile="${{ matrix.environment }}" \
            -reportFolder="Reports" \
            --config \
            -webui.autoUpdateDrivers=true

      - name: Upload test reports
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: katalon-reports-${{ matrix.environment }}
          path: Reports/

      - name: Publish test results
        uses: EnricoMi/publish-unit-test-result-action@v2
        if: always()
        with:
          files: Reports/**/JUnit_Report.xml
          check_name: "API Test Results (${{ matrix.environment }})"

      - name: Notify Slack on failure
        if: failure()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: qa-automation
          SLACK_COLOR: danger
          SLACK_MESSAGE: "API tests failed in ${{ matrix.environment }} environment"
```

<BackToTop />

#### Azure DevOps Integration

```yaml
# azure-pipelines.yml
trigger:
  branches:
    include:
      - main
      - develop

pool:
  vmImage: "ubuntu-latest"

variables:
  - group: api-test-variables
  - name: KATALON_PROJECT_PATH
    value: "$(System.DefaultWorkingDirectory)"

stages:
  - stage: APITesting
    displayName: "API Test Execution"
    jobs:
      - job: ExecuteTests
        displayName: "Execute API Tests"
        steps:
          - task: JavaToolInstaller@0
            displayName: "Install Java 11"
            inputs:
              versionSpec: "11"
              jdkArchitectureOption: "x64"
              jdkSourceOption: "PreInstalled"

          - task: Bash@3
            displayName: "Download Katalon Runtime Engine"
            inputs:
              targetType: "inline"
              script: |
                wget -q https://github.com/katalon-studio/katalon-studio/releases/latest/download/katalon-runtime-engine-linux.tar.gz
                tar -xzf katalon-runtime-engine-linux.tar.gz
                chmod +x katalon-runtime-engine/katalonc

          - task: PowerShell@2
            displayName: "Setup Test Environment"
            inputs:
              targetType: "inline"
              script: |
                $profileContent = @"
                api.baseUrl=$(API_BASE_URL)
                auth.token=$(API_TOKEN)
                database.url=$(DB_CONNECTION_STRING)
                "@
                $profileContent | Out-File -FilePath "Profiles/AzureDevOps.properties" -Encoding UTF8

          - task: Bash@3
            displayName: "Execute Katalon Tests"
            inputs:
              targetType: "inline"
              script: |
                ./katalon-runtime-engine/katalonc -noSplash -runMode=console \
                  -projectPath="$(KATALON_PROJECT_PATH)" \
                  -retry=1 \
                  -testSuiteCollectionPath="Test Suites/API Test Suite Collection" \
                  -executionProfile="AzureDevOps" \
                  -reportFolder="$(Agent.TempDirectory)/KatalonReports" \
                  --config \
                  -webui.autoUpdateDrivers=true

          - task: PublishTestResults@2
            displayName: "Publish Test Results"
            condition: always()
            inputs:
              testResultsFormat: "JUnit"
              testResultsFiles: "$(Agent.TempDirectory)/KatalonReports/**/JUnit_Report.xml"
              testRunTitle: "API Test Results"
              mergeTestResults: true

          - task: PublishHtmlReport@1
            displayName: "Publish HTML Report"
            condition: always()
            inputs:
              reportDir: "$(Agent.TempDirectory)/KatalonReports"
              tabName: "Katalon Test Report"
```

<BackToTop />

### Reporting and Analytics

#### Custom Report Generation

```groovy
import java.text.SimpleDateFormat
import groovy.json.JsonBuilder

class CustomReportGenerator {

    static void generateAPITestReport(def testResults, String outputPath) {
        def reportData = [
            testRun: [
                id: UUID.randomUUID().toString(),
                timestamp: new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'").format(new Date()),
                environment: GlobalVariable.testEnvironment,
                totalTests: testResults.size(),
                passedTests: testResults.count { it.status == 'PASSED' },
                failedTests: testResults.count { it.status == 'FAILED' },
                skippedTests: testResults.count { it.status == 'SKIPPED' }
            ],
            testCases: testResults.collect { test ->
                [
                    name: test.name,
                    status: test.status,
                    duration: test.duration,
                    endpoint: test.endpoint,
                    method: test.method,
                    statusCode: test.statusCode,
                    responseTime: test.responseTime,
                    assertions: test.assertions.collect { assertion ->
                        [
                            type: assertion.type,
                            expected: assertion.expected,
                            actual: assertion.actual,
                            passed: assertion.passed,
                            message: assertion.message
                        ]
                    },
                    errorMessage: test.errorMessage
                ]
            }
        ]

        // Generate JSON report
        def jsonReport = new JsonBuilder(reportData).toPrettyString()
        new File("${outputPath}/api-test-report.json").text = jsonReport

        // Generate HTML report
        generateHTMLReport(reportData, outputPath)

        // Send to external systems
        sendToTestManagement(reportData)
        sendToMetrics(reportData)
    }

    static void generateHTMLReport(def reportData, String outputPath) {
        def htmlContent = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>API Test Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background: #f4f4f4; padding: 20px; border-radius: 5px; }
                .summary { display: flex; gap: 20px; margin: 20px 0; }
                .metric { background: #e9ecef; padding: 15px; border-radius: 5px; text-align: center; }
                .passed { background: #d4edda; color: #155724; }
                .failed { background: #f8d7da; color: #721c24; }
                .test-case { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
                .test-passed { border-left: 4px solid #28a745; }
                .test-failed { border-left: 4px solid #dc3545; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>API Test Report</h1>
                <p>Environment: ${reportData.testRun.environment}</p>
                <p>Executed: ${reportData.testRun.timestamp}</p>
            </div>

            <div class="summary">
                <div class="metric">
                    <h3>${reportData.testRun.totalTests}</h3>
                    <p>Total Tests</p>
                </div>
                <div class="metric passed">
                    <h3>${reportData.testRun.passedTests}</h3>
                    <p>Passed</p>
                </div>
                <div class="metric failed">
                    <h3>${reportData.testRun.failedTests}</h3>
                    <p>Failed</p>
                </div>
            </div>

            <h2>Test Results</h2>
            ${reportData.testCases.collect { test -> generateTestCaseHTML(test) }.join('')}
        </body>
        </html>
        """

        new File("${outputPath}/api-test-report.html").text = htmlContent
    }

    static String generateTestCaseHTML(def testCase) {
        def statusClass = testCase.status == 'PASSED' ? 'test-passed' : 'test-failed'
        return """
        <div class="test-case ${statusClass}">
            <h3>${testCase.name}</h3>
            <p><strong>Endpoint:</strong> ${testCase.method} ${testCase.endpoint}</p>
            <p><strong>Status:</strong> ${testCase.status}</p>
            <p><strong>Response Time:</strong> ${testCase.responseTime}ms</p>
            <p><strong>Status Code:</strong> ${testCase.statusCode}</p>
            ${testCase.errorMessage ? "<p><strong>Error:</strong> ${testCase.errorMessage}</p>" : ""}
        </div>
        """
    }
}
```

<BackToTop />

#### Integration with External Reporting Tools

```groovy
// TestRail integration
class TestRailIntegration {

    static void updateTestResults(def testResults) {
        def testRailAPI = new TestRailAPI(
            url: GlobalVariable.testRailURL,
            user: GlobalVariable.testRailUser,
            apiKey: GlobalVariable.testRailAPIKey
        )

        testResults.each { test ->
            def status = test.status == 'PASSED' ? 1 : 5 // TestRail status IDs

            testRailAPI.addResult(test.testRailCaseId, [
                status_id: status,
                comment: test.errorMessage ?: "Test executed successfully",
                elapsed: "${test.duration}s",
                custom_response_time: test.responseTime
            ])
        }
    }
}

// Jira integration for defect creation
class JiraIntegration {

    static void createDefectsForFailures(def failedTests) {
        def jiraAPI = new JiraAPI(
            url: GlobalVariable.jiraURL,
            username: GlobalVariable.jiraUser,
            password: GlobalVariable.jiraPassword
        )

        failedTests.each { test ->
            def issueData = [
                fields: [
                    project: [key: 'API'],
                    summary: "API Test Failure: ${test.name}",
                    description: """
                    Test Case: ${test.name}
                    Endpoint: ${test.method} ${test.endpoint}
                    Expected: ${test.expected}
                    Actual: ${test.actual}
                    Error: ${test.errorMessage}
                    Environment: ${GlobalVariable.testEnvironment}
                    """,
                    issuetype: [name: 'Bug'],
                    priority: [name: 'High'],
                    labels: ['api-test-failure', 'automation']
                ]
            ]

            jiraAPI.createIssue(issueData)
        }
    }
}
```

<BackToTop />

## Best Practices for API Testing with Katalon Studio

### Project Organization and Structure

#### Recommended Project Layout

```
API Test Project/
  Object Repository/
      Authentication/           # Auth-related endpoints
          Login.rs
          Logout.rs
          RefreshToken.rs
      Users/                   # User management APIs
          CreateUser.rs
          GetUser.rs
          UpdateUser.rs
          DeleteUser.rs
      Orders/                  # E-commerce APIs
          CreateOrder.rs
          GetOrderHistory.rs
          CancelOrder.rs
  Test Cases/
      Authentication/          # Auth test scenarios
      UserManagement/         # User CRUD operations
      OrderWorkflow/          # End-to-end order flows
      ErrorHandling/          # Negative test cases
  Test Suites/
      Smoke Tests/            # Quick validation tests
      Regression Tests/       # Comprehensive test coverage
      Performance Tests/      # Load and stress tests
  Data Files/
      UserTestData.xlsx       # User-related test data
      ProductCatalog.csv      # Product information
      Environments.xlsx       # Environment configurations
  Keywords/
      API/                    # Custom API keywords
      Database/               # Database utilities
      Utilities/              # Helper functions
  Profiles/                   # Environment profiles
      DEV.properties
      STAGING.properties
      PROD.properties
```

#### Naming Conventions

```groovy
// Test Object Naming
// Format: [HttpMethod][ResourceName][Action]
// Examples:
- POST_Users_Create
- GET_Users_GetById
- PUT_Users_Update
- DELETE_Users_Remove

// Test Case Naming
// Format: [TestType]_[Feature]_[Scenario]_[ExpectedResult]
// Examples:
- API_UserRegistration_ValidData_Success
- API_UserLogin_InvalidCredentials_Unauthorized
- API_OrderCreation_MissingRequiredField_BadRequest

// Test Suite Naming
// Format: [TestLevel]_[Feature]_[TestType]
// Examples:
- Smoke_UserManagement_API
- Regression_OrderWorkflow_EndToEnd
- Performance_ProductCatalog_LoadTest
```

<BackToTop />

### Test Design Patterns and Strategies

#### Page Object Model for APIs

```groovy
// API Page Object Pattern
class UserAPI {
    static String baseEndpoint = "${GlobalVariable.apiBaseUrl}/api/v1/users"

    static def create(Map userData) {
        def request = findTestObject('API/Users/Create')
        request.setRequestBody(userData)
        return WS.sendRequest(request)
    }

    static def getById(String userId) {
        return WS.sendRequest(findTestObject('API/Users/GetById', [
            ('userId'): userId
        ]))
    }

    static def update(String userId, Map updateData) {
        return WS.sendRequest(findTestObject('API/Users/Update', [
            ('userId'): userId,
            ('requestBody'): updateData
        ]))
    }

    static def delete(String userId) {
        return WS.sendRequest(findTestObject('API/Users/Delete', [
            ('userId'): userId
        ]))
    }

    static def search(Map searchCriteria) {
        def queryParams = searchCriteria.collect { k, v -> "${k}=${v}" }.join('&')
        return WS.sendRequest(findTestObject('API/Users/Search', [
            ('queryParams'): queryParams
        ]))
    }
}

// Usage in test cases
def newUser = [name: 'John Doe', email: 'john@example.com']
def createResponse = UserAPI.create(newUser)
def userId = new JsonSlurper().parseText(createResponse.getResponseBodyContent()).id
def getResponse = UserAPI.getById(userId)
```

<BackToTop />

#### Builder Pattern for Test Data

```groovy
class UserBuilder {
    private Map userData = [:]

    static UserBuilder create() {
        return new UserBuilder()
    }

    UserBuilder withName(String name) {
        userData.name = name
        return this
    }

    UserBuilder withEmail(String email) {
        userData.email = email
        return this
    }

    UserBuilder withAddress(String street, String city, String zipcode) {
        userData.address = [
            street: street,
            city: city,
            zipcode: zipcode
        ]
        return this
    }

    UserBuilder withRole(String role) {
        userData.role = role
        return this
    }

    UserBuilder withRandomData() {
        userData.name = Faker.instance().name().fullName()
        userData.email = Faker.instance().internet().emailAddress()
        userData.phone = Faker.instance().phoneNumber().phoneNumber()
        return this
    }

    Map build() {
        return userData.clone()
    }
}

// Usage
def adminUser = UserBuilder.create()
    .withName('Admin User')
    .withEmail('admin@company.com')
    .withRole('administrator')
    .build()

def randomUser = UserBuilder.create()
    .withRandomData()
    .withRole('user')
    .build()
```

<BackToTop />

### Security and Performance Testing

#### Security Testing Patterns

```groovy
class SecurityTestPatterns {

    static List<String> sqlInjectionPayloads = [
        "' OR '1'='1",
        "'; DROP TABLE users; --",
        "' UNION SELECT * FROM users --",
        "admin'--",
        "admin'/*",
        "' OR 1=1#",
        "') OR ('1'='1"
    ]

    static void testSQLInjection(String endpoint, String parameter) {
        sqlInjectionPayloads.each { payload ->
            try {
                def response = WS.sendRequest(findTestObject(endpoint, [
                    (parameter): payload
                ]))

                // Check for SQL injection indicators
                def responseBody = response.getResponseBodyContent().toLowerCase()

                if (responseBody.contains('sql') ||
                    responseBody.contains('syntax error') ||
                    responseBody.contains('mysql') ||
                    responseBody.contains('postgresql')) {

                    throw new AssertionError("Potential SQL injection vulnerability detected with payload: ${payload}")
                }

            } catch (Exception e) {
                println "Testing payload: ${payload} - Result: ${e.message}"
            }
        }
    }

    static void testAuthenticationBypass() {
        def bypassPayloads = [
            ['Authorization': ''],
            ['Authorization': 'Bearer invalid_token'],
            ['Authorization': 'Bearer ' + 'a' * 1000], // Long token
            ['X-Forwarded-For': '127.0.0.1'],
            ['X-Real-IP': '127.0.0.1']
        ]

        bypassPayloads.each { headers ->
            def response = WS.sendRequest(findTestObject('API/Protected/Resource', [
                ('customHeaders'): headers
            ]))

            // Should return 401/403, not 200
            if (WS.getResponseStatusCode(response) == 200) {
                throw new AssertionError("Authentication bypass possible with headers: ${headers}")
            }
        }
    }
}
```

<BackToTop />

#### Performance Testing

```groovy
import java.util.concurrent.*
import java.util.concurrent.atomic.AtomicInteger

class APIPerformanceTest {

    static void loadTest(String testName, Closure testLogic, int userCount, int duration) {
        def executor = Executors.newFixedThreadPool(userCount)
        def successCount = new AtomicInteger(0)
        def failureCount = new AtomicInteger(0)
        def responseTimes = Collections.synchronizedList([])

        def startTime = System.currentTimeMillis()
        def endTime = startTime + (duration * 1000)

        println "Starting load test: ${testName}"
        println "Users: ${userCount}, Duration: ${duration}s"

        for (int i = 0; i < userCount; i++) {
            executor.submit {
                while (System.currentTimeMillis() < endTime) {
                    def requestStart = System.currentTimeMillis()
                    try {
                        testLogic.call()
                        def responseTime = System.currentTimeMillis() - requestStart
                        responseTimes.add(responseTime)
                        successCount.incrementAndGet()
                    } catch (Exception e) {
                        failureCount.incrementAndGet()
                        println "Request failed: ${e.message}"
                    }

                    Thread.sleep(100) // Think time
                }
            }
        }

        executor.shutdown()
        executor.awaitTermination(duration + 10, TimeUnit.SECONDS)

        // Calculate statistics
        def totalRequests = successCount.get() + failureCount.get()
        def avgResponseTime = responseTimes.sum() / responseTimes.size()
        def minResponseTime = responseTimes.min()
        def maxResponseTime = responseTimes.max()
        def throughput = totalRequests / duration

        println "\n=== Load Test Results ==="
        println "Total Requests: ${totalRequests}"
        println "Successful: ${successCount.get()}"
        println "Failed: ${failureCount.get()}"
        println "Success Rate: ${(successCount.get() / totalRequests * 100).round(2)}%"
        println "Average Response Time: ${avgResponseTime.round(2)}ms"
        println "Min Response Time: ${minResponseTime}ms"
        println "Max Response Time: ${maxResponseTime}ms"
        println "Throughput: ${throughput.round(2)} requests/second"
    }
}

// Usage
APIPerformanceTest.loadTest("User API Load Test", {
    def response = UserAPI.getById('123')
    WS.verifyResponseStatusCode(response, 200)
}, 10, 60) // 10 users for 60 seconds
```

<BackToTop />

### Maintenance and Quality Guidelines

#### Code Review Checklist

- **Test Object Management**
  -  Are test objects properly named and organized?
  -  Are endpoints parameterized for reusability?
  -  Are authentication headers properly configured?

- **Test Data Management**
  -  Is test data externalized and environment-specific?
  -  Are sensitive data properly secured?
  -  Is test data cleanup implemented?

- **Assertion Quality**
  -  Are assertions comprehensive and meaningful?
  -  Is response schema validation implemented?
  -  Are error scenarios properly tested?

- **Maintainability**
  -  Are custom keywords documented?
  -  Is test code DRY (Don't Repeat Yourself)?
  -  Are magic numbers and strings avoided?

#### Continuous Improvement Practices

```groovy
// Regular test health checks
class TestHealthMonitor {

    static void analyzeTestStability() {
        def testResults = getRecentTestResults(30) // Last 30 days

        testResults.groupBy { it.testName }.each { testName, results ->
            def failureRate = results.count { it.status == 'FAILED' } / results.size()
            def avgResponseTime = results.collect { it.responseTime }.sum() / results.size()

            if (failureRate > 0.1) { // More than 10% failure rate
                println "⚠️  Flaky test detected: ${testName} (${failureRate * 100}% failure rate)"
            }

            if (avgResponseTime > 5000) { // Slower than 5 seconds
                println "🐌 Slow test detected: ${testName} (${avgResponseTime}ms avg)"
            }
        }
    }

    static void generateCoverageReport() {
        def endpoints = getAllAPIEndpoints()
        def testedEndpoints = getTestedEndpoints()

        def coverage = (testedEndpoints.size() / endpoints.size()) * 100
        println "API Test Coverage: ${coverage.round(2)}%"

        def untestedEndpoints = endpoints - testedEndpoints
        if (untestedEndpoints) {
            println "Untested endpoints:"
            untestedEndpoints.each { println "  - ${it}" }
        }
    }
}
```

<BackToTop />
