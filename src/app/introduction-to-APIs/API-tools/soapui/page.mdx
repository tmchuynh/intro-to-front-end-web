import BackToTop from "@/components/BackToTop";
import Button from "@/components/Button";
import { FaChevronRight } from "react-icons/fa";

# SoapUI

## Table of Contents

## Introduction

[SoapUI](https://www.soapui.org/) is a powerful tool for testing SOAP and REST APIs. It provides a user-friendly interface for creating and executing API requests, making it easier to validate API functionality and performance.

#### Key Features

| Feature                 | Description                                                                        |
| ----------------------- | ---------------------------------------------------------------------------------- |
| **Request Creation**    | Easily create and send SOAP and REST requests with customizable parameters.        |
| **Assertions**          | Validate API responses with assertions to ensure they meet expected criteria.      |
| **Data-Driven Testing** | Use data sources to run tests with multiple sets of data, enhancing test coverage. |
| **Mock Services**       | Create mock services to simulate API behavior for testing purposes.                |
| **Security Testing**    | Perform security tests to identify vulnerabilities in your APIs.                   |
| **Load Testing**        | Simulate high traffic to test API performance under load.                          |
| **Reporting**           | Generate detailed reports on test results and API performance.                     |
| **Integration**         | Integrate with CI/CD pipelines for automated testing.                              |
| **Cross-Platform**      | Available on Windows, macOS, and Linux.                                            |
| **Community Support**   | Active community and extensive documentation for troubleshooting and learning.     |

## Getting Started

SoapUI is available in both open-source and commercial versions, called [ReadyAPI](<(https://www.soapui.org/downloads/download-readyapi-trial/)>). You can download the open-source version from the [SoapUI website](https://www.soapui.org/downloads/soapui-open-source/).

### Is Open Source Right for You?

SoapUI's open-source version is suitable for individual developers and small teams who need basic API testing capabilities. If you require advanced features like enterprise-level support, security testing, or load testing, consider the commercial version, SoapUI Pro.

| Feature Comparison      | Open Source | SoapUI Pro |
| ----------------------- | ----------- | ---------- |
| **Request Creation**    | ‚úÖ          | ‚úÖ         |
| **Assertions**          | ‚úÖ          | ‚úÖ         |
| **Data-Driven Testing** | ‚úÖ          | ‚úÖ         |
| **Mock Services**       | ‚úÖ          | ‚úÖ         |
| **Security Testing**    | ‚ùå          | ‚úÖ         |
| **Load Testing**        | ‚ùå          | ‚úÖ         |
| **Reporting**           | Basic       | Advanced   |
| **Integration**         | ‚úÖ          | ‚úÖ         |
| **Cross-Platform**      | ‚úÖ          | ‚úÖ         |
| **Community Support**   | ‚úÖ          | ‚úÖ         |
| **REST**                | ‚úÖ          | ‚úÖ         |
| **SOAP**                | ‚úÖ          | ‚úÖ         |
| **GraphQL**             | ‚ùå          | ‚úÖ         |
| **Apache Kafka**        | ‚ùå          | ‚úÖ         |
| **gRPC**                | ‚ùå          | ‚úÖ         |

### ReadyAPI Pricing

| Module                    | Fixed Price (annually/per license) | Floating Price (annually/per license) |
| ------------------------- | ---------------------------------- | ------------------------------------- |
| API Test Module           | $990                               | $5,700                                |
| API Performance Module    | $6,840                             | $12,740                               |
| API Virtualization Module | $1,310                             | $5,680                                |

#### Available Add-Ons

| Add-On     | Price      |
| ---------- | ---------- |
| VirtServer | From $3090 |

## Using SoapUI

### Creating a Request

#### Creating a REST Request

1. **Open SoapUI** and create a new project by clicking "File" <FaChevronRight className="inline"/>"New SOAP Project" or "New REST Project"
2. **Right-click** on the project and select "New REST Request"
3. **Enter the endpoint URL** (e.g., `https://jsonplaceholder.typicode.com/posts`)
4. **Select the HTTP method** (GET, POST, PUT, DELETE, etc.)
5. **Configure request details** as needed

##### Example: Creating a GET Request

```
Method: GET
URL: https://jsonplaceholder.typicode.com/posts/1
Headers:
  Content-Type: application/json
  Accept: application/json
```

##### Example: Creating a POST Request

```
Method: POST
URL: https://jsonplaceholder.typicode.com/posts
Headers:
  Content-Type: application/json
Body:
{
  "title": "My New Post",
  "body": "This is the content of my post",
  "userId": 1
}
```

#### Creating a SOAP Request

1. **Create a new SOAP project** and provide the WSDL URL
2. **Example WSDL**: `http://webservices.oorsprong.org/websamples.countryinfo/CountryInfoService.wso?WSDL`
3. **SoapUI will automatically** generate the request structure based on the WSDL
4. **Fill in the required parameters** in the generated XML structure

**Example SOAP Request Structure**:

```xml
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope" xmlns:web="http://www.oorsprong.org/websamples.countryinfo">
   <soap:Header/>
   <soap:Body>
      <web:CountryName>
         <web:sCountryISOCode>US</web:sCountryISOCode>
      </web:CountryName>
   </soap:Body>
</soap:Envelope>
```

#### Organizing Requests

- **Use folders** to organize requests within the project
- **Right-click** on the project and select "New Folder" to create a new folder
- **Drag and drop** requests into appropriate folders for better organization

**Example Project Structure**:

```
üìÅ E-commerce API Project
  üìÅ Authentication
      Login Request
      Logout Request
  üìÅ Products
      Get All Products
      Get Product by ID
      Create Product
      Update Product
  üìÅ Orders
      Place Order
      Get Order Status
      Cancel Order
```

### Sending Requests

- Click the <Button variant="primary" className="mx-1">Send</Button> button to send the request
- View the response in the response panel, which displays status codes, headers, and body content
- Use the "Raw" tab to view the raw request and response data

**Example Response Analysis**:

```
Status Code: 200 OK
Response Time: 245ms
Content-Type: application/json

Response Body:
{
  "id": 1,
  "title": "sunt aut facere repellat provident occaecati excepturi",
  "body": "quia et suscipit suscipit recusandae...",
  "userId": 1
}
```

**Response Tabs Explained**:

- **JSON**: Formatted JSON response with syntax highlighting
- **XML**: Formatted XML response with collapsible nodes
- **HTML**: Rendered HTML content (for web pages)
- **Raw**: Unformatted response as received
- **Headers**: Response headers including content-type, cache-control, etc.

### Adding Parameters and Headers

#### Adding Headers

- Use the "Headers" tab to add custom headers to your request
- Common headers include `Authorization`, `Content-Type`, `Accept`, etc.

**Example Headers**:

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json
Accept: application/json
User-Agent: SoapUI/5.7.0
X-API-Key: your-api-key-here
```

#### Adding Query Parameters

- Use the "Parameters" tab to add query parameters for GET requests
- Parameters are automatically appended to the URL

**Example Query Parameters**:

```
URL: https://api.example.com/users
Parameters:
  page: 1
  limit: 10
  sort: name
  filter: active

Resulting URL: https://api.example.com/users?page=1&limit=10&sort=name&filter=active
```

#### Adding Request Body

- Use the "Body" tab to add request body content in various formats

**JSON Body Example**:

```json
{
  "user": {
    "name": "John Doe",
    "email": "john.doe@example.com",
    "age": 30,
    "preferences": {
      "newsletter": true,
      "notifications": false
    }
  }
}
```

**XML Body Example**:

```xml
<user>
  <name>John Doe</name>
  <email>john.doe@example.com</email>
  <age>30</age>
  <preferences>
    <newsletter>true</newsletter>
    <notifications>false</notifications>
  </preferences>
</user>
```

**Form Data Example**:

```
username: johndoe
password: secretPassword123
remember_me: true
```

### Running Tests

- Click the <Button variant="tertiary" className="mx-1">Run</Button> button to execute the test
- View the response in the response panel, which displays status codes, headers, and body content
- Monitor test execution progress in the test log

**Example Test Execution Flow**:

1. **Pre-request setup**: Initialize variables, set authentication tokens
2. **Request execution**: Send HTTP request to the target endpoint
3. **Response validation**: Check status codes, response time, content
4. **Post-request cleanup**: Log results, update test data

**Test Results Dashboard**:

```
‚úÖ Test Case: User Registration
     ‚úÖ Request sent successfully (200ms)
     ‚úÖ Status code is 201 Created
     ‚úÖ Response contains user ID
     ‚úÖ Email validation passed

‚ùå Test Case: Invalid Login
     ‚úÖ Request sent successfully (150ms)
     ‚ùå Expected status code 401, got 500
     ‚ö†Ô∏è  Response time exceeded 200ms threshold
```

#### Data-Driven Testing

Data-driven testing allows you to run the same test with multiple sets of input data, making your tests more comprehensive and efficient.

**Setting Up Data Sources**:

1. **Right-click** on the project and select "New DataSource"
2. **Choose data source type**: File (CSV, Excel), Database, or Grid
3. **Configure data mapping** to connect data fields to request parameters

**CSV Data Source Example**:

```csv
username,email,expectedStatus
john_doe,john@example.com,201
jane_smith,jane@example.com,201
invalid_user,,400
duplicate@email.com,duplicate@email.com,409
```

**Using Data in Requests**:

```json
{
  "username": "${DataSource#username}",
  "email": "${DataSource#email}",
  "password": "defaultPassword123"
}
```

**Excel Data Source Structure**:
| TestCase | Username | Password | ExpectedResult |
|----------|----------|----------|----------------|
| Valid Login | admin | admin123 | 200 |
| Invalid Password | admin | wrongpass | 401 |
| Missing Username | | admin123 | 400 |
| SQL Injection | admin'; DROP TABLE users; -- | admin123 | 400 |

**Database Data Source Example**:

```sql
SELECT
    user_id,
    username,
    email,
    account_status
FROM test_users
WHERE is_test_data = true
```

### Security Testing

Security testing helps identify vulnerabilities in your APIs before they reach production. SoapUI Pro includes comprehensive security scanning capabilities.

#### Security Test Types

##### 1. SQL Injection Testing

```
Description: Tests for SQL injection vulnerabilities
Example Payloads:
  - ' OR '1'='1
  - '; DROP TABLE users; --
  - UNION SELECT * FROM users
Target Parameters: All input fields and query parameters
```

##### 2. XSS (Cross-Site Scripting) Testing

```
Description: Tests for XSS vulnerabilities in web APIs
Example Payloads:
  - <script>alert('XSS')</script>
  - javascript:alert('XSS')
  - <img src=x onerror=alert('XSS')>
Target: String input fields, especially those displayed in UI
```

##### 3. XML Bomb Testing

```
Description: Tests for XML parsing vulnerabilities
Example Payload:
<?xml version="1.0"?>
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
]>
<lolz>&lol3;</lolz>
```

##### 4. Malformed XML Testing

```
Description: Tests API resilience to malformed XML
Example Payloads:
  - Unclosed tags: <user><name>John</user>
  - Invalid characters: <user>John & Jane</user>
  - Missing namespaces: <soap:Body>content</soap:Body>
```

#### Security Test Configuration

**Setting Up Security Tests**:

1. **Right-click** on the project and select "Security Tests"
2. **Choose test types** based on your API's input methods
3. **Configure scan parameters** including payload lists and target fields
4. **Run the security scan** and analyze results

**Security Test Report Example**:

```
üî¥ HIGH RISK: SQL Injection vulnerability found
   Endpoint: POST /api/users/login
   Parameter: username
   Payload: admin' OR '1'='1' --
   Response: 200 OK with admin user data
   Recommendation: Use parameterized queries

üü° MEDIUM RISK: Information disclosure
   Endpoint: GET /api/internal/debug
   Issue: Exposes internal system information
   Response: Database connection strings visible
   Recommendation: Remove debug endpoint from production

üü¢ LOW RISK: Missing security headers
   Endpoint: All endpoints
   Issue: X-Content-Type-Options header missing
   Recommendation: Add security headers
```

### Load Testing

Load testing simulates real-world traffic patterns to evaluate API performance under various conditions and identify bottlenecks before production deployment.

#### Creating Load Tests

**Setting Up Load Tests**:

1. **Create a load test** by right-clicking on the project and selecting "New Load Test"
2. **Configure test parameters** including virtual users, test duration, and ramp-up strategy
3. **Define test scenarios** with different user behavior patterns
4. **Run the load test** and monitor real-time performance metrics

#### Load Test Configuration Examples

**Basic Load Test Setup**:

```
Test Name: User Registration Load Test
Target Endpoint: POST /api/users/register
Virtual Users: 100
Test Duration: 5 minutes
Ramp-up Time: 30 seconds
Think Time: 1-3 seconds between requests
```

**Advanced Load Test Scenarios**:

##### Scenario 1: Steady Load

```
Description: Constant user load over time
Configuration:
  - Users: 50 concurrent users
  - Duration: 10 minutes
  - Requests per second: ~16-17
  - Use case: Normal business hours traffic
```

##### Scenario 2: Spike Testing

```
Description: Sudden increase in user load
Configuration:
  - Start: 10 users
  - Spike to: 200 users (in 30 seconds)
  - Maintain: 5 minutes
  - Use case: Flash sale or viral content
```

##### Scenario 3: Soak Testing

```
Description: Extended duration testing
Configuration:
  - Users: 30 concurrent users
  - Duration: 2 hours
  - Use case: Memory leak detection, long-term stability
```

#### Load Test Results Analysis

**Performance Metrics Dashboard**:

```
üìä Load Test Results Summary
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    Test Duration: 5:00 minutes
    Total Requests: 15,247
    Successful Requests: 15,089 (98.96%)
    Failed Requests: 158 (1.04%)
    Average Response Time: 245ms
    95th Percentile: 890ms
    Throughput: 50.8 req/sec
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

```

**Response Time Distribution**:

```
Response Time Ranges:
  0-100ms:     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë 60% (9,148 requests)
  100-500ms:   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 35% (5,336 requests)
  500-1000ms:  ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  4% (610 requests)
  >1000ms:     ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  1% (153 requests)
```

**Error Analysis**:

```
Error Types:
  Timeout (>2000ms): 89 requests (0.58%)
  HTTP 500 errors: 45 requests (0.29%)
  Connection refused: 24 requests (0.16%)
  HTTP 429 (Rate limit): 0 requests (0.00%)
```

#### Performance Benchmarking

**Load Test Comparison Table**:
| Metric | Baseline | Current Test | Change |
|--------|----------|--------------|--------|
| Avg Response Time | 180ms | 245ms | +36% üî¥ |
| 95th Percentile | 750ms | 890ms | +19% üü° |
| Throughput | 55 req/s | 51 req/s | -7% üü° |
| Error Rate | 0.5% | 1.04% | +108% üî¥ |
| Peak Memory | 512MB | 678MB | +32% üü° |

**Load Testing Best Practices**:

```
‚úÖ Start with baseline performance tests
‚úÖ Test with realistic data volumes
‚úÖ Include authentication in load tests
‚úÖ Monitor server resources during tests
‚úÖ Test different user scenarios
‚úÖ Gradually increase load to find breaking points
‚úÖ Test failover and recovery scenarios
```

### Assertions

Assertions are validation rules that automatically verify if your API responses meet expected criteria. They're essential for automated testing and continuous integration.

#### Adding Assertions

- Use the "Assertions" tab to add assertions to your requests
- Right-click on the request and select "Add Assertion"
- Choose the appropriate assertion type based on what you want to validate

#### Common Assertion Types

##### 1. Response SLA (Response Time)

```
Description: Validates that the response time is within acceptable limits
Configuration: Maximum response time: 500ms
Result: ‚úÖ Response time: 245ms (PASS)
```

##### 2. Contains Assertion

```
Description: Checks if response contains specific text
Configuration: Response must contain: "success"
Sample Response: {"status": "success", "data": {...}}
Result: ‚úÖ Contains "success" (PASS)
```

##### 3. JSONPath Match

```
Description: Validates JSON response structure and values
JSONPath: $.user.id
Expected Value: 12345
Sample Response: {"user": {"id": 12345, "name": "John"}}
Result: ‚úÖ JSONPath match (PASS)
```

##### 4. XPath Match (for XML responses)

```
Description: Validates XML response structure and values
XPath: //user/@id
Expected Value: 12345
Sample Response: <user id="12345"><name>John</name></user>
Result: ‚úÖ XPath match (PASS)
```

##### 5. HTTP Status Code

```
Description: Validates the HTTP response status code
Expected Codes: 200, 201, 204
Actual Code: 200
Result: ‚úÖ Status code valid (PASS)
```

##### 6. Response Header

```
Description: Validates response headers
Header Name: Content-Type
Expected Value: application/json
Actual Value: application/json; charset=utf-8
Result: ‚úÖ Header contains expected value (PASS)
```

#### Advanced Assertion Examples

**Schema Compliance Assertion**:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "id": { "type": "integer" },
    "name": { "type": "string" },
    "email": { "type": "string", "format": "email" }
  },
  "required": ["id", "name", "email"]
}
```

**Script Assertion Example**:

```groovy
// Custom Groovy script for complex validation
def response = messageExchange.response.responseContent
def jsonSlurper = new groovy.json.JsonSlurper()
def jsonResponse = jsonSlurper.parseText(response)

// Validate email format
def emailPattern = /^[A-Za-z0-9+_.-]+@([A-Za-z0-9.-]+\.[A-Za-z]{2,})$/
assert jsonResponse.email ==~ emailPattern

// Validate ID is positive integer
assert jsonResponse.id > 0

// Log validation results
log.info("Email validation: PASSED")
log.info("ID validation: PASSED")
```

### Validating Responses

- Use assertions to validate the response. Right-click on the request and select "Add Assertion."
- Choose the type of assertion (e.g., "Response SLA," "XPath Match," etc.).
- Configure the assertion parameters and click "OK" to apply it.

### Mocking Services

Mock services simulate API behavior without requiring the actual backend implementation. This is invaluable for parallel development and testing scenarios.

#### Creating Mock Services

**Step-by-Step Process**:

1. **Right-click** on the project and select "New Mock Service"
2. **Configure the mock service** settings including port and path
3. **Define response templates** for different request scenarios
4. **Start the mock service** to begin serving requests

#### Mock Service Examples

**REST Mock Service Configuration**:

```
Service Name: User Management Mock
Port: 8088
Path: /api/v1
Base URL: http://localhost:8088/api/v1
```

**Mock Response Examples**:

**`GET /users/{id}` - Success Response**:

```json
{
  "id": "${id}",
  "name": "Mock User",
  "email": "mockuser@example.com",
  "created_at": "2023-01-01T00:00:00Z",
  "status": "active"
}
```

**`GET /users/{id}` - Not Found Response**:

```json
{
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "User with ID ${id} not found",
    "timestamp": "2023-01-01T00:00:00Z"
  }
}
```

**`POST /users` - Create User Response**:

```json
{
  "id": 12345,
  "name": "${name}",
  "email": "${email}",
  "created_at": "2023-01-01T00:00:00Z",
  "status": "active"
}
```

#### Dynamic Mock Responses

**Using Groovy Scripts for Dynamic Responses**:

```groovy
// Dynamic response based on request parameters
def request = mockRequest.getHttpRequest()
def userId = request.getPath().tokenize('/').last()

if (userId.isNumber() && userId.toInteger() > 0) {
    // Return valid user
    return """
    {
        "id": ${userId},
        "name": "User ${userId}",
        "email": "user${userId}@example.com",
        "status": "active"
    }
    """
} else {
    // Return error response
    mockResponse.setResponseHttpStatus(404)
    return """
    {
        "error": "User not found",
        "code": "USER_NOT_FOUND"
    }
    """
}
```

#### Mock Service Use Cases

##### 1. Frontend Development

```
Scenario: Frontend team needs to develop user interface before backend is ready
Mock Setup: Create mock endpoints for all required API calls
Benefits: Parallel development, faster iterations, early testing
```

##### 2. Third-Party API Simulation

```
Scenario: Testing integration with external payment processor
Mock Setup: Simulate various payment scenarios (success, failure, timeout)
Benefits: Controlled testing environment, no real transactions
```

##### 3. Error Scenario Testing

```
Scenario: Testing application behavior during API failures
Mock Setup: Configure mocks to return various error responses
Benefits: Comprehensive error handling validation
```

### Generating Reports

- Use the reporting features to generate detailed reports on test results and API performance.
- Right-click on the project and select "Generate Report."
- Choose the report type (e.g., "Test Summary," "Performance Report," etc.)
- Configure the report settings and click "Generate" to create the report.

### Integrating with CI/CD

SoapUI integrates seamlessly with CI/CD pipelines, enabling automated API testing as part of your deployment workflow.

#### Command Line Interface (CLI)

**Basic Command Structure**:

```bash
# Run all tests in a project
testrunner.sh -f /path/to/reports /path/to/project.xml

# Run specific test suite
testrunner.sh -s "TestSuite Name" -f /path/to/reports /path/to/project.xml

# Run with specific endpoint
testrunner.sh -e "https://staging-api.example.com" /path/to/project.xml
```

#### CI/CD Integration Examples

**Jenkins Pipeline Example**:

```groovy
pipeline {
    agent any
    stages {
        stage('API Testing') {
            steps {
                script {
                    // Run SoapUI tests
                    sh '''
                        cd /opt/soapui/bin
                        ./testrunner.sh -f ${WORKSPACE}/test-reports \
                        -e ${API_ENDPOINT} \
                        ${WORKSPACE}/api-tests/project.xml
                    '''
                }
            }
            post {
                always {
                    // Publish test results
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'test-reports',
                        reportFiles: '*.html',
                        reportName: 'SoapUI Test Report'
                    ])
                }
            }
        }
    }
}
```

**GitHub Actions Workflow**:

```yaml
name: API Tests
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  api-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup SoapUI
        run: |
          wget https://dl.eviware.com/soapuios/5.7.0/SoapUI-5.7.0-linux-bin.tar.gz
          tar -xzf SoapUI-5.7.0-linux-bin.tar.gz

      - name: Run API Tests
        run: |
          ./SoapUI-5.7.0/bin/testrunner.sh \
          -f test-reports \
          -e ${{ secrets.API_ENDPOINT }} \
          ./tests/api-project.xml

      - name: Upload Test Results
        uses: actions/upload-artifact@v3
        with:
          name: test-reports
          path: test-reports/
```

**GitLab CI Example**:

```yaml
stages:
  - test

api_tests:
  stage: test
  image: openjdk:8-jdk
  before_script:
    - apt-get update && apt-get install -y wget
    - wget https://dl.eviware.com/soapuios/5.7.0/SoapUI-5.7.0-linux-bin.tar.gz
    - tar -xzf SoapUI-5.7.0-linux-bin.tar.gz
  script:
    - ./SoapUI-5.7.0/bin/testrunner.sh
      -f test-reports
      -e $API_ENDPOINT
      ./tests/api-project.xml
  artifacts:
    reports:
      junit: test-reports/*.xml
    paths:
      - test-reports/
  only:
    - main
    - develop
```

**Azure DevOps Pipeline**:

```yaml
trigger:
  - main
  - develop

pool:
  vmImage: "ubuntu-latest"

variables:
  API_ENDPOINT: "https://api.staging.example.com"

steps:
  - task: Bash@3
    displayName: "Install SoapUI"
    inputs:
      targetType: "inline"
      script: |
        wget https://dl.eviware.com/soapuios/5.7.0/SoapUI-5.7.0-linux-bin.tar.gz
        tar -xzf SoapUI-5.7.0-linux-bin.tar.gz

  - task: Bash@3
    displayName: "Run API Tests"
    inputs:
      targetType: "inline"
      script: |
        ./SoapUI-5.7.0/bin/testrunner.sh \
        -f $(Agent.TempDirectory)/test-reports \
        -e $(API_ENDPOINT) \
        ./tests/api-project.xml

  - task: PublishTestResults@2
    displayName: "Publish Test Results"
    inputs:
      testResultsFormat: "JUnit"
      testResultsFiles: "$(Agent.TempDirectory)/test-reports/*.xml"
      mergeTestResults: true
```

#### Advanced CLI Options

**Comprehensive Command Examples**:

```bash
# Run tests with custom properties
testrunner.sh \
  -e "https://api.production.com" \
  -Pusername=testuser \
  -Ppassword=testpass \
  -Penvironment=production \
  /path/to/project.xml

# Generate different report formats
testrunner.sh \
  -f /reports \
  -F JUnit \
  -R "Detailed Report" \
  /path/to/project.xml

# Run with timeout and retry settings
testrunner.sh \
  -t 60000 \
  -M \
  -x "TestCase 1,TestCase 2" \
  /path/to/project.xml
```

**CLI Options Explained**:
| Option | Description | Example |
|--------|-------------|---------|
| `-e` | Endpoint override | `-e https://staging.api.com` |
| `-f` | Report folder | `-f ./reports` |
| `-s` | Test suite | `-s "Smoke Tests"` |
| `-c` | Test case | `-c "Login Test"` |
| `-P` | Project property | `-Pusername=admin` |
| `-F` | Report format | `-F JUnit` |
| `-R` | Report name | `-R "API Test Report"` |
| `-t` | Request timeout | `-t 30000` |
| `-x` | Exclude tests | `-x "Slow Test"` |

## Real-World Examples

### E-commerce API Testing Project

**Project Structure**:

```
üìÅ E-commerce API Tests
  üìÅ Authentication
      User Login
      Admin Login
      OAuth Token Refresh
      Password Reset
  üìÅ Product Management
      Get Product Catalog
      Search Products
      Add New Product (Admin)
      Update Product (Admin)
      Delete Product (Admin)
  üìÅ Shopping Cart
      Add Item to Cart
      Update Cart Quantity
      Remove Item from Cart
      Clear Cart
  üìÅ Order Processing
      Place Order
      Get Order Status
      Cancel Order
      Process Refund
  üìÅ Payment Gateway
      Process Payment
      Validate Card
      Handle Payment Failure
```

**Complete Test Scenario Example**:

```
Test Case: Complete Purchase Flow
   Step 1: User Authentication
         POST /api/auth/login
         Assert: Status code 200
         Assert: Response contains auth_token
         Store: auth_token for subsequent requests

‚îú‚îÄ Step 2: Browse Products
         GET /api/products?category=electronics
         Assert: Status code 200
         Assert: Products array not empty
         Store: product_id from first item

‚îú‚îÄ Step 3: Add to Cart
         POST /api/cart/items
         Headers: Authorization: Bearer ${auth_token}
         Body: {"product_id": ${product_id}, "quantity": 2}
         Assert: Status code 201
         Assert: Cart total updated

‚îú‚îÄ Step 4: Checkout Process
         POST /api/orders
         Assert: Status code 201
         Assert: Order ID generated
         Store: order_id

‚îî‚îÄ Step 5: Payment Processing
         POST /api/payments
         Body: {"order_id": ${order_id}, "payment_method": "card"}
         Assert: Status code 200
         Assert: Payment status is "completed"
```

### Banking API Security Testing

**Security Test Suite**:

```
üîí Banking API Security Tests
  Authentication Bypass Tests
        JWT Token Manipulation
        Session Fixation
        Privilege Escalation
  Input Validation Tests
        SQL Injection in account lookup
        XSS in transaction descriptions
        Command Injection in file uploads
  Business Logic Tests
        Negative balance transfers
        Duplicate transaction processing
        Account access violations
  Rate Limiting Tests
        Login attempt brute force
        API endpoint flooding
        Transaction rate limits
```

**Sample Security Test Configuration**:

```xml
<securityTest>
  <name>Account Transfer Security Test</name>
  <targetEndpoint>POST /api/transfers</targetEndpoint>
  <payloads>
    <sqlInjection>
      <payload>' OR '1'='1' --</payload>
      <payload>'; DROP TABLE accounts; --</payload>
    </sqlInjection>
    <businessLogic>
      <payload>{"from_account": "12345", "to_account": "12345", "amount": 1000000}</payload>
      <payload>{"from_account": "12345", "to_account": "67890", "amount": -500}</payload>
    </businessLogic>
  </payloads>
</securityTest>
```

## Best Practices

### Test Organization

##### 1. Project Structure Best Practices

```
‚úÖ Use descriptive folder names
‚úÖ Group related endpoints together
‚úÖ Separate positive and negative test cases
‚úÖ Use consistent naming conventions
‚úÖ Document test purpose and expected outcomes
```

##### 2. Request Design Patterns

```
‚úÖ Use environment variables for URLs
‚úÖ Implement proper authentication handling
‚úÖ Include realistic test data
‚úÖ Handle dynamic data with property transfers
‚úÖ Add appropriate timeouts and retry logic
```

### Data Management

**Test Data Strategy**:

```
üìä Test Data Types
  Static Data: Unchanging reference data (currencies, countries)
  Dynamic Data: Generated during test execution (user IDs, timestamps)
  Realistic Data: Production-like data volumes and complexity
  Edge Case Data: Boundary values, invalid formats, special characters
```

**Data Source Examples**:

```csv
# users_testdata.csv
user_type,username,email,expected_status,test_scenario
valid_user,john_doe,john@example.com,200,Successful login
invalid_email,bad_user,invalid-email,400,Invalid email format
missing_password,user123,,400,Missing required field
sql_injection,"admin'; DROP TABLE users; --",admin@test.com,400,Security test
long_username,very_long_username_that_exceeds_limit,long@test.com,400,Field length validation
```

### Error Handling

**Comprehensive Error Testing**:

```
üö® Error Scenarios to Test
  Network Errors
      Timeout scenarios
      Connection refused
      DNS resolution failures
  HTTP Status Codes
      4xx Client errors (400, 401, 403, 404, 422)
      5xx Server errors (500, 502, 503, 504)
      Custom application error codes
  Response Format Errors
      Malformed JSON/XML
      Missing required fields
      Unexpected data types
  Business Logic Errors
      Insufficient permissions
      Resource conflicts
      Invalid state transitions
```

### Performance Testing Guidelines

**Load Test Planning Matrix**:
| Test Type | Users | Duration | Ramp-up | Purpose |
|-----------|-------|----------|---------|---------|
| Smoke Test | 1-5 | 2 min | 0 sec | Basic functionality |
| Load Test | 10-100 | 10 min | 2 min | Normal capacity |
| Stress Test | 100-500 | 15 min | 5 min | Breaking point |
| Spike Test | 10‚Üí200‚Üí10 | 10 min | 30 sec | Sudden load changes |
| Volume Test | 50 | 60 min | 5 min | Large data processing |
| Endurance Test | 20 | 2 hours | 5 min | Memory leaks, stability |

### Maintenance and Documentation

**Documentation Standards**:

```
üìù Test Documentation Checklist
‚úÖ Test purpose and scope clearly defined
‚úÖ Prerequisites and setup requirements
‚úÖ Step-by-step execution instructions
‚úÖ Expected results and success criteria
‚úÖ Known issues and workarounds
‚úÖ Last updated date and version
‚úÖ Test data requirements and sources
‚úÖ Environment configuration details
```

**Version Control Best Practices**:

```
üîÑ SoapUI Project Management
  Store projects in version control (Git)
  Use meaningful commit messages
  Tag releases with version numbers
  Maintain separate branches for environments
  Document breaking changes in CHANGELOG
  Review and approve test changes
  Backup test data and configurations
```

<BackToTop />
