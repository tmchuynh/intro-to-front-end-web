import BackToTop from "@/components/BackToTop";

# Authentication

## Table of Contents

## Understanding Tokens and Authentication

Authentication is a crucial aspect of working with APIs, ensuring that only authorized users can access certain resources. In this section, we will explore the concept of tokens and how they are used for authentication.

In the world of web applications, authentication is like the bouncer at an exclusive clubâ€”crucial for verifying who gets in and who stays out. Tokens are the VIP passes that let users prove their identity without having to flash their sensitive information every time they want to enter.

Tokens are small pieces of data that represent the user's identity and permissions. They are typically generated by the server when a user logs in and are sent back to the client. The client then includes this token in subsequent requests to access protected resources.
Tokens can be in various formats, such as JSON Web Tokens (JWT), OAuth tokens, or API keys. Each type has its own use cases and security considerations.

### Common Token Formats

- **JSON Web Tokens (JWT)**: A compact, URL-safe means of representing claims to be transferred between two parties
- **OAuth Tokens**: Used in OAuth for granting limited access to user resources
- **API Keys**: Simple tokens used to authenticate API requests

### Example of Token Authentication

```javascript
import axios from "axios";
const authenticateUser = async (username, password) => {
  try {
    const response = await axios.post("/api/login", { username, password });
    const token = response.data.token;

    // Store the token in local storage or a cookie
    localStorage.setItem("authToken", token);
  } catch (error) {
    console.error("Authentication failed:", error);
  }
};
```

In this example, we send a POST request to the server with the user's credentials. If the authentication is successful, the server responds with a token, which we then store in local storage for future requests.

<BackToTop />

### Basic Authentication

Basic authentication is a simple method for verifying users, where credentials (username and password) are sent with each HTTP request in Base64 encoding.

```javascript
// JavaScript example using Basic Authentication
const username = "user@example.com";
const password = "securePassword";
const credentials = btoa(`${username}:${password}`);

fetch("https://api.example.com/protected", {
  method: "GET",
  headers: {
    Authorization: `Basic ${credentials}`,
    "Content-Type": "application/json",
  },
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

**NOTE**

> Basic Authentication has significant security drawbacks. Base64 encoding is not encryption; it merely disguises the credentials, making them easily reversible. Always use HTTPS with Basic Authentication to encrypt the entire HTTP request.

### Token-Based Authentication

Token-based authentication is a more secure and flexible method where the server issues a token after successful login. This token is then used for subsequent requests, allowing the server to verify the user's identity without needing to send credentials repeatedly.

```javascript
// JavaScript example using Token-Based Authentication
const authenticateUser = async (username, password) => {
  try {
    const response = await fetch("https://api.example.com/login", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ username, password }),
    });

    if (!response.ok) {
      throw new Error("Authentication failed");
    }

    const data = await response.json();
    const token = data.token;

    // Store the token in local storage or a cookie
    localStorage.setItem("authToken", token);
  } catch (error) {
    console.error("Error:", error);
  }
};
```

#### Best Practices for Token-Based Authentication

1. **Security Measures**

   - Always use HTTPS for token transmission
   - Implement token expiration
   - Use secure storage methods

2. **Storage Solutions**

   - Web Applications: Use secure, HTTP-only cookies
   - Mobile Applications: Use platform-specific secure storage

3. **Implementation Guidelines**

   - Implement refresh tokens
   - Protect against CSRF attacks
   - Always validate tokens server-side

<BackToTop />
## Bearer Tokens

Bearer tokens act like VIP passes in web authentication, particularly in the OAuth framework. When users log in, the server issues a bearer token that must be included in the Authorization header of HTTP requests.

```javascript
// JavaScript example using Bearer Token
const token = "your_jwt_token";

fetch("https://api.example.com/protected", {
  method: "GET",
  headers: {
    Authorization: `Bearer ${token}`,
    "Content-Type": "application/json",
  },
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

Bearer tokens are typically used in APIs to authenticate requests. They are sent in the HTTP headers and allow the server to verify the user's identity without needing to send credentials repeatedly.

In this example, we include the bearer token in the Authorization header of the request to access a protected resource.

## Session-Based Authentication

Session-based authentication manages user sessions by creating a unique session identifier stored in a cookie. This allows the server to recognize the user on subsequent requests.

```javascript
// Assuming the session ID is stored in a cookie by the server
fetch("https://api.example.com/user", {
  method: "GET",
  credentials: "include", // Include cookies in the request
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

Session-based authentication is a traditional method where the server creates a session for the user after they log in. The session ID is stored in a cookie, which is sent with each request to identify the user.
This method is commonly used in web applications where the server maintains the session state. The server can then retrieve user information based on the session ID stored in the cookie.

In this example, we make a GET request to a protected resource, including the session cookie in the request. The server uses the session ID to authenticate the user and return the appropriate data.

<BackToTop />

## Implementing Authentication in Next.js

Next.js provides several ways to implement authentication in your applications. You can use built-in features
like API routes, middleware, and third-party libraries to handle authentication
seamlessly.

Using API Routes for Authentication API routes in Next.js allow you to create serverless functions that can handle authentication logic. You can create a login route that verifies user credentials and returns a token.

```javascript
// pages/api/login.js
import { NextResponse } from "next/server";
export default async function handler(req, res) {
  if (req.method === "POST") {
    const { username, password } = req.body;

    // Validate user credentials (this is just a placeholder)
    if (username === "user" && password === "password") {
      const token = "your_generated_token"; // Generate a token here
      return res.status(200).json({ token });
    } else {
      return res.status(401).json({ error: "Invalid credentials" });
    }
  } else {
    return res.status(405).json({ error: "Method not allowed" });
  }
}
```

In this example, we create an API route that handles POST requests for user login. If the credentials are valid, it returns a token; otherwise, it responds with an error.

### Using Middleware for Authentication

Next.js middleware allows you to run code before a request is completed, making it ideal for authentication checks. You can create middleware that checks for a valid token before allowing access to certain routes.

```javascript
// middleware.js
import { NextResponse } from "next/server";
export function middleware(req) {
  const token = req.cookies.authToken;

  if (!token) {
    return NextResponse.redirect("/login"); // Redirect to login if no token
  }

  // Optionally, verify the token here

  return NextResponse.next(); // Proceed to the requested route
}
```

In this middleware example, we check for the presence of an authentication token in the request cookies. If the token is missing, we redirect the user to the login page; otherwise, we allow the request to proceed.

<BackToTop />
