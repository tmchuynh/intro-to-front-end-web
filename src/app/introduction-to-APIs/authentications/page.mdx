import BackToTop from "@/components/BackToTop";

# API Authentication Guide

## Table of Contents

## Introduction to Authentication

Authentication is a crucial aspect of working with APIs, ensuring that only authorized users can access certain resources. Think of authentication as the digital equivalent of showing your ID at a secure building—it verifies who you are and determines what you're allowed to access.

In modern web applications, authentication serves multiple purposes:

- **Identity Verification**: Confirming that users are who they claim to be
- **Access Control**: Determining what resources a user can access
- **Security**: Protecting sensitive data from unauthorized access
- **Audit Trail**: Tracking who accessed what and when

### Why Authentication Matters

Without proper authentication, your API would be like a house with no locks—anyone could walk in and access sensitive information. Authentication helps protect:

- User personal data
- Business-critical information
- System resources
- API rate limits and usage quotas

### Authentication vs Authorization

It's important to understand the difference:

- **Authentication**: "Who are you?" (Verifying identity)
- **Authorization**: "What can you do?" (Granting permissions)

<BackToTop />

## Types of Authentication

Let's explore the various authentication methods available for API security, each with its own use cases and security considerations.

### Basic Authentication

Basic authentication is the simplest form of HTTP authentication, where credentials (username and password) are sent with each request encoded in Base64.

#### How Basic Authentication Works

1. Client combines username and password with a colon: `username:password`
2. Encodes the string using Base64 encoding
3. Sends the encoded string in the Authorization header

```javascript
// JavaScript example using Basic Authentication
const username = "user@example.com";
const password = "securePassword";
const credentials = btoa(`${username}:${password}`);

fetch("https://api.example.com/protected", {
  method: "GET",
  headers: {
    Authorization: `Basic ${credentials}`,
    "Content-Type": "application/json",
  },
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

| Advantages                            | Disadvantages                               |
| ------------------------------------- | ------------------------------------------- |
| Simple to implement                   | Credentials sent with every request         |
| Supported by all HTTP clients         | Base64 is encoding, not encryption          |
| No additional infrastructure required | No built-in token expiration                |
| Easy to test with tools like Postman  | Vulnerable to replay attacks if not secured |

##### WARNING

> Basic Authentication has significant security drawbacks. Base64 encoding is not encryption; it merely disguises the credentials, making them easily reversible. Always use HTTPS with Basic Authentication to encrypt the entire HTTP request.

<BackToTop />

### Token-Based Authentication

Token-based authentication is a more secure and flexible method where the server issues a token after successful login. This token acts as a temporary key that proves the user's identity without exposing their actual credentials.

#### How Token-Based Authentication Works

1. User submits credentials (username/password)
2. Server validates credentials
3. Server generates and returns a token
4. Client stores the token
5. Client includes token in subsequent requests
6. Server validates token for each request

<BackToTop />

#### Common Token Formats

- **JSON Web Tokens (JWT)**: Self-contained tokens with encoded user information
- **Random Tokens**: Opaque strings stored in a database
- **Refresh Tokens**: Long-lived tokens used to obtain new access tokens

```javascript
// JavaScript example using Token-Based Authentication
const authenticateUser = async (username, password) => {
  try {
    const response = await fetch("https://api.example.com/login", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ username, password }),
    });

    if (!response.ok) {
      throw new Error("Authentication failed");
    }

    const data = await response.json();
    const { token, refreshToken, expiresIn } = data;

    // Store tokens securely
    sessionStorage.setItem("authToken", token);
    localStorage.setItem("refreshToken", refreshToken);

    // Set token expiration
    const expirationTime = Date.now() + expiresIn * 1000;
    sessionStorage.setItem("tokenExpiration", expirationTime);

    return { token, refreshToken };
  } catch (error) {
    console.error("Authentication error:", error);
    throw error;
  }
};

// Function to make authenticated requests
const makeAuthenticatedRequest = async (url, options = {}) => {
  const token = sessionStorage.getItem("authToken");
  const expiration = sessionStorage.getItem("tokenExpiration");

  // Check if token is expired
  if (Date.now() > parseInt(expiration)) {
    await refreshAuthToken();
  }

  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      Authorization: `Bearer ${token}`,
    },
  });
};
```

#### Token Storage Strategies

##### Client-Side Storage Options

1. **Session Storage**: Temporary storage, cleared when tab closes
2. **Local Storage**: Persistent storage, survives browser restarts
3. **HTTP-Only Cookies**: Secure storage, not accessible via JavaScript
4. **Memory Storage**: Most secure but lost on page refresh

```javascript
// Secure token storage utility
class TokenManager {
  static setTokens(accessToken, refreshToken) {
    // Store access token in session storage (temporary)
    sessionStorage.setItem("accessToken", accessToken);

    // Store refresh token in HTTP-only cookie (more secure)
    document.cookie = `refreshToken=${refreshToken}; HttpOnly; Secure; SameSite=Strict`;
  }

  static getAccessToken() {
    return sessionStorage.getItem("accessToken");
  }

  static clearTokens() {
    sessionStorage.removeItem("accessToken");
    document.cookie =
      "refreshToken=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
  }
}
```

<BackToTop />

#### Token Refresh Implementation

```javascript
// Automatic token refresh utility
const refreshAuthToken = async () => {
  try {
    const refreshToken = localStorage.getItem("refreshToken");

    if (!refreshToken) {
      throw new Error("No refresh token available");
    }

    const response = await fetch("https://api.example.com/refresh", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ refreshToken }),
    });

    if (!response.ok) {
      throw new Error("Token refresh failed");
    }

    const { token, expiresIn } = await response.json();

    // Update stored token
    sessionStorage.setItem("authToken", token);
    const expirationTime = Date.now() + expiresIn * 1000;
    sessionStorage.setItem("tokenExpiration", expirationTime);

    return token;
  } catch (error) {
    console.error("Token refresh error:", error);
    // Redirect to login page
    window.location.href = "/login";
    throw error;
  }
};
```

#### Best Practices for Token-Based Authentication

1. **Security Measures**

   - Always use HTTPS for token transmission
   - Implement token expiration (typically 15-60 minutes)
   - Use secure storage methods
   - Implement proper logout functionality
   - Validate tokens on every request

2. **Storage Solutions**

   - **Web Applications**: Use secure, HTTP-only cookies for refresh tokens
   - **Single Page Applications**: Use session storage for access tokens
   - **Mobile Applications**: Use platform-specific secure storage (Keychain, Keystore)

3. **Implementation Guidelines**
   - Implement refresh tokens for seamless user experience
   - Protect against CSRF attacks with proper headers
   - Always validate tokens server-side
   - Use short-lived access tokens with longer-lived refresh tokens
   - Implement proper error handling for expired tokens

<BackToTop />

## Bearer Tokens

Bearer tokens are a specific type of access token used in the OAuth 2.0 framework and other authentication systems. The term "bearer" means that whoever possesses the token can use it to access resources—no additional proof of identity is required.

### Understanding Bearer Token Format

Bearer tokens are included in the `Authorization` header of HTTP requests with the format:

```
Authorization: Bearer <token>
```

#### Types of Bearer Tokens

1. **JWT (JSON Web Tokens)**

   - Self-contained with encoded user information
   - Can be verified without database lookup
   - Include expiration times and claims

2. **Opaque Tokens**
   - Random strings with no embedded information
   - Require server-side validation
   - More secure against information leakage

```javascript
// JWT Bearer Token example
const jwtToken =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";

// Making authenticated request with Bearer token
fetch("https://api.example.com/protected", {
  method: "GET",
  headers: {
    Authorization: `Bearer ${jwtToken}`,
    "Content-Type": "application/json",
  },
})
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => console.log("Protected data:", data))
  .catch((error) => console.error("Error:", error));
```

| Advantages                            | Disadvantages                                           |
| ------------------------------------- | ------------------------------------------------------- |
| Stateless and scalable                | Token theft can lead to unauthorized access             |
| Can include user information          | No way to invalidate individual tokens (with JWTs)      |
| Supports fine-grained access control  | Must be protected in transit and storage                |
| Can be used across multiple servers   | Vulnerable to XSS attacks if stored in localStorage     |
| Supports token expiration and refresh | Requires careful implementation to avoid security risks |
| Easy to implement with libraries      | Requires additional infrastructure for token management |

##### WARNING

> Bearer tokens must be handled with care. If a token is compromised, an attacker can access protected resources without needing to know the user's credentials. Always use HTTPS to protect tokens in transit and consider using short-lived tokens with refresh mechanisms.

<BackToTop />

```javascript
// Secure Bearer Token implementation
class BearerTokenAuth {
  constructor() {
    this.token = null;
    this.refreshToken = null;
  }

  async login(username, password) {
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      });

      if (!response.ok) {
        throw new Error("Login failed");
      }

      const { accessToken, refreshToken } = await response.json();

      this.setTokens(accessToken, refreshToken);
      return { success: true };
    } catch (error) {
      console.error("Login error:", error);
      return { success: false, error: error.message };
    }
  }

  setTokens(accessToken, refreshToken) {
    this.token = accessToken;
    this.refreshToken = refreshToken;

    // Store refresh token in HTTP-only cookie
    // Access token kept in memory for security
  }

  async makeRequest(url, options = {}) {
    if (!this.token) {
      throw new Error("No access token available");
    }

    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${this.token}`,
      },
    });

    if (response.status === 401) {
      // Token might be expired, try to refresh
      const refreshed = await this.refreshAccessToken();
      if (refreshed) {
        // Retry the original request
        return this.makeRequest(url, options);
      } else {
        throw new Error("Authentication failed");
      }
    }

    return response;
  }

  async refreshAccessToken() {
    try {
      const response = await fetch("/api/auth/refresh", {
        method: "POST",
        credentials: "include", // Include HTTP-only cookies
      });

      if (!response.ok) {
        throw new Error("Token refresh failed");
      }

      const { accessToken } = await response.json();
      this.token = accessToken;
      return true;
    } catch (error) {
      console.error("Token refresh error:", error);
      this.logout();
      return false;
    }
  }

  logout() {
    this.token = null;
    this.refreshToken = null;
    // Clear HTTP-only cookie
    fetch("/api/auth/logout", { method: "POST", credentials: "include" });
  }
}
```

<BackToTop />

## Session-Based Authentication

Session-based authentication is a traditional stateful authentication method where the server maintains session information. When a user logs in, the server creates a session and stores session data (typically in memory, database, or cache), then sends a session identifier to the client via a cookie.

### How Session-Based Authentication Works

1. User submits login credentials
2. Server validates credentials
3. Server creates a session and stores session data
4. Server sends session ID to client via cookie
5. Client automatically sends session cookie with subsequent requests
6. Server validates session ID and retrieves session data
7. Server grants or denies access based on session information

#### Session Implementation Example

```javascript
// Client-side: Session-based authentication
const loginWithSession = async (username, password) => {
  try {
    const response = await fetch("https://api.example.com/login", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ username, password }),
      credentials: "include", // Important: Include cookies
    });

    if (!response.ok) {
      throw new Error("Login failed");
    }

    const data = await response.json();
    console.log("Login successful:", data.message);

    // Session cookie is automatically stored by the browser
    return { success: true, user: data.user };
  } catch (error) {
    console.error("Login error:", error);
    return { success: false, error: error.message };
  }
};

// Making authenticated requests with session
const fetchUserData = async () => {
  try {
    const response = await fetch("https://api.example.com/user", {
      method: "GET",
      credentials: "include", // Include session cookie
    });

    if (!response.ok) {
      if (response.status === 401) {
        // Session expired, redirect to login
        window.location.href = "/login";
        return;
      }
      throw new Error("Failed to fetch user data");
    }

    const userData = await response.json();
    return userData;
  } catch (error) {
    console.error("Error fetching user data:", error);
    throw error;
  }
};

// Logout function
const logout = async () => {
  try {
    await fetch("https://api.example.com/logout", {
      method: "POST",
      credentials: "include",
    });

    // Redirect to login page
    window.location.href = "/login";
  } catch (error) {
    console.error("Logout error:", error);
  }
};
```

<BackToTop />

#### Session vs Token Comparison

| Aspect          | Session-Based            | Token-Based       |
| --------------- | ------------------------ | ----------------- |
| **State**       | Stateful                 | Stateless         |
| **Storage**     | Server-side              | Client-side       |
| **Scalability** | Limited                  | High              |
| **Security**    | Server-controlled        | Client-controlled |
| **Complexity**  | Simple                   | Moderate          |
| **Performance** | Database lookup required | No server storage |
| **Expiration**  | Server-defined           | Client-defined    |

### Session Security Considerations

Session-based authentication has its own set of security considerations that must be addressed to ensure the integrity and
confidentiality of user sessions.

| Aspect                                | Considerations                                                                                            |
| ------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| **Session Hijacking**                 | Use secure cookies, set `HttpOnly` and `Secure` flags, implement session timeouts                         |
| **Session Fixation**                  | Regenerate session ID on login, invalidate old sessions                                                   |
| **Cross-Site Request Forgery (CSRF)** | Use anti-CSRF tokens, set `SameSite` cookie attribute                                                     |
| **Cross-Site Scripting (XSS)**        | Sanitize user input, use `Content-Security-Policy` headers, set `HttpOnly` cookies                        |
| **Session Expiration**                | Implement session timeouts, allow users to log out and invalidate sessions                                |
| **Session Storage**                   | Use secure storage mechanisms (e.g., Redis, database), avoid storing sensitive data in session            |
| **Session Revocation**                | Provide a way to revoke sessions (e.g., logout, admin controls), maintain a blacklist of revoked sessions |
| **Session Management**                | Monitor session activity, log session creation and termination, implement rate limiting                   |

| Advantages                                          | Disadvantages                            |
| --------------------------------------------------- | ---------------------------------------- |
| Server has full control over sessions               | Requires server-side storage             |
| Can revoke sessions immediately                     | Difficult to scale horizontally          |
| Session data is not exposed to client               | Not suitable for stateless architectures |
| Built-in CSRF protection with proper implementation | Session fixation vulnerabilities         |

```javascript
// Secure session configuration example (Express.js)
const session = require("express-session");
const MongoStore = require("connect-mongo");

app.use(
  session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({
      mongoUrl: process.env.MONGODB_URI,
    }),
    cookie: {
      secure: process.env.NODE_ENV === "production", // HTTPS only in production
      httpOnly: true, // Prevent XSS
      maxAge: 1000 * 60 * 60 * 24, // 24 hours
      sameSite: "strict", // CSRF protection
    },
  })
);
```

<BackToTop />

## OAuth 2.0

OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on third-party services like Google, Facebook, or GitHub. It's widely used for "Login with..." functionality.

### OAuth 2.0 Flow Types

#### 1. Authorization Code Flow (Most Secure)

Best for server-side applications that can securely store client secrets.

```javascript
// Step 1: Redirect user to authorization server
const authorizeUser = () => {
  const clientId = "your_client_id";
  const redirectUri = encodeURIComponent("https://yourapp.com/callback");
  const scope = encodeURIComponent("read:user user:email");
  const state = generateRandomState(); // CSRF protection

  // Store state in session for verification
  sessionStorage.setItem("oauth_state", state);

  const authUrl =
    `https://github.com/login/oauth/authorize?` +
    `client_id=${clientId}&` +
    `redirect_uri=${redirectUri}&` +
    `scope=${scope}&` +
    `state=${state}&` +
    `response_type=code`;

  window.location.href = authUrl;
};

// Step 2: Handle callback and exchange code for token
const handleOAuthCallback = async () => {
  const urlParams = new URLSearchParams(window.location.search);
  const code = urlParams.get("code");
  const state = urlParams.get("state");
  const storedState = sessionStorage.getItem("oauth_state");

  // Verify state to prevent CSRF attacks
  if (state !== storedState) {
    throw new Error("Invalid state parameter");
  }

  try {
    // Exchange authorization code for access token
    const response = await fetch("/api/oauth/token", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ code }),
    });

    if (!response.ok) {
      throw new Error("Token exchange failed");
    }

    const { access_token, refresh_token } = await response.json();

    // Store tokens securely
    sessionStorage.setItem("access_token", access_token);
    localStorage.setItem("refresh_token", refresh_token);

    // Redirect to application
    window.location.href = "/dashboard";
  } catch (error) {
    console.error("OAuth callback error:", error);
    window.location.href = "/login?error=oauth_failed";
  }
};
```

<BackToTop />

#### 2. Implicit Flow (Deprecated for Security Reasons)

Previously used for client-side applications, now deprecated in favor of Authorization Code Flow with PKCE.

#### 3. Authorization Code Flow with PKCE

Secure flow for public clients (SPAs, mobile apps) that cannot store client secrets.

```javascript
// PKCE (Proof Key for Code Exchange) implementation
class PKCEAuth {
  constructor(clientId, redirectUri, authEndpoint, tokenEndpoint) {
    this.clientId = clientId;
    this.redirectUri = redirectUri;
    this.authEndpoint = authEndpoint;
    this.tokenEndpoint = tokenEndpoint;
  }

  // Generate PKCE code verifier and challenge
  generatePKCE() {
    const codeVerifier = this.generateRandomString(128);
    const codeChallenge = this.base64URLEncode(this.sha256(codeVerifier));

    return { codeVerifier, codeChallenge };
  }

  generateRandomString(length) {
    const possible =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    let text = "";
    for (let i = 0; i < length; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }

  async sha256(plain) {
    const encoder = new TextEncoder();
    const data = encoder.encode(plain);
    return window.crypto.subtle.digest("SHA-256", data);
  }

  base64URLEncode(buffer) {
    const bytes = new Uint8Array(buffer);
    const str = String.fromCharCode(...bytes);
    return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }

  async startAuth() {
    const { codeVerifier, codeChallenge } = this.generatePKCE();
    const state = this.generateRandomString(32);

    // Store PKCE parameters
    sessionStorage.setItem("pkce_code_verifier", codeVerifier);
    sessionStorage.setItem("oauth_state", state);

    const authUrl = new URL(this.authEndpoint);
    authUrl.searchParams.set("client_id", this.clientId);
    authUrl.searchParams.set("response_type", "code");
    authUrl.searchParams.set("redirect_uri", this.redirectUri);
    authUrl.searchParams.set("code_challenge", codeChallenge);
    authUrl.searchParams.set("code_challenge_method", "S256");
    authUrl.searchParams.set("state", state);
    authUrl.searchParams.set("scope", "openid profile email");

    window.location.href = authUrl.toString();
  }

  async handleCallback() {
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get("code");
    const state = urlParams.get("state");
    const storedState = sessionStorage.getItem("oauth_state");
    const codeVerifier = sessionStorage.getItem("pkce_code_verifier");

    if (state !== storedState) {
      throw new Error("Invalid state parameter");
    }

    try {
      const response = await fetch(this.tokenEndpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          grant_type: "authorization_code",
          client_id: this.clientId,
          code: code,
          redirect_uri: this.redirectUri,
          code_verifier: codeVerifier,
        }),
      });

      if (!response.ok) {
        throw new Error("Token exchange failed");
      }

      const tokens = await response.json();
      return tokens;
    } finally {
      // Clean up stored parameters
      sessionStorage.removeItem("pkce_code_verifier");
      sessionStorage.removeItem("oauth_state");
    }
  }
}

// Usage example
const auth = new PKCEAuth(
  "your_client_id",
  "https://yourapp.com/callback",
  "https://accounts.google.com/oauth2/v2/auth",
  "https://oauth2.googleapis.com/token"
);

// Start authentication
document.getElementById("login-btn").onclick = () => auth.startAuth();

// Handle callback (on callback page)
if (window.location.pathname === "/callback") {
  auth
    .handleCallback()
    .then((tokens) => {
      console.log("Authentication successful:", tokens);
      // Store tokens and redirect to app
    })
    .catch((error) => {
      console.error("Authentication failed:", error);
    });
}
```

<BackToTop />

## API Keys

API keys are simple authentication tokens used to identify and authenticate applications or users when making API requests. They're commonly used for service-to-service authentication and rate limiting.

### Types of API Keys

1. **Public API Keys**: Safe to expose in client-side code
2. **Private API Keys**: Must be kept secret on the server
3. **Scoped API Keys**: Limited to specific permissions or resources

#### API Key Implementation

```javascript
// Simple API key authentication
const API_KEY = process.env.REACT_APP_API_KEY; // For public APIs only

const fetchWeatherData = async (city) => {
  try {
    const response = await fetch(
      `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${API_KEY}`
    );

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const weatherData = await response.json();
    return weatherData;
  } catch (error) {
    console.error("Weather API error:", error);
    throw error;
  }
};

// Server-side API key usage (Node.js/Express)
const express = require("express");
const app = express();

// Middleware to validate API key
const validateApiKey = (req, res, next) => {
  const apiKey = req.headers["x-api-key"] || req.query.api_key;

  if (!apiKey) {
    return res.status(401).json({ error: "API key required" });
  }

  // Validate API key (check against database or environment)
  if (apiKey !== process.env.VALID_API_KEY) {
    return res.status(403).json({ error: "Invalid API key" });
  }

  next();
};

// Protected route using API key
app.get("/api/data", validateApiKey, (req, res) => {
  res.json({ message: "Access granted", data: "sensitive information" });
});
```

<BackToTop />

#### API Key Security Best Practices

1. **Never expose private API keys in client-side code**
2. **Use environment variables for key storage**
3. **Implement key rotation policies**
4. **Monitor and log API key usage**
5. **Use different keys for different environments**
6. **Implement rate limiting per key**

```javascript
// Secure API key management utility
class ApiKeyManager {
  constructor() {
    this.keys = new Map();
    this.rateLimits = new Map();
  }

  validateKey(key, endpoint) {
    const keyData = this.keys.get(key);

    if (!keyData) {
      return { valid: false, reason: "Invalid API key" };
    }

    if (keyData.expired && keyData.expiresAt < Date.now()) {
      return { valid: false, reason: "API key expired" };
    }

    if (
      keyData.allowedEndpoints &&
      !keyData.allowedEndpoints.includes(endpoint)
    ) {
      return { valid: false, reason: "Endpoint not allowed for this key" };
    }

    // Check rate limits
    if (this.isRateLimited(key)) {
      return { valid: false, reason: "Rate limit exceeded" };
    }

    return { valid: true, keyData };
  }

  isRateLimited(key) {
    const now = Date.now();
    const windowMs = 60 * 1000; // 1 minute window
    const limit = 100; // 100 requests per minute

    if (!this.rateLimits.has(key)) {
      this.rateLimits.set(key, { count: 1, resetTime: now + windowMs });
      return false;
    }

    const rateLimitData = this.rateLimits.get(key);

    if (now > rateLimitData.resetTime) {
      // Reset the window
      this.rateLimits.set(key, { count: 1, resetTime: now + windowMs });
      return false;
    }

    if (rateLimitData.count >= limit) {
      return true;
    }

    rateLimitData.count++;
    return false;
  }

  registerKey(key, options = {}) {
    this.keys.set(key, {
      createdAt: Date.now(),
      expiresAt: options.expiresAt,
      allowedEndpoints: options.allowedEndpoints,
      permissions: options.permissions || [],
      userId: options.userId,
    });
  }

  revokeKey(key) {
    this.keys.delete(key);
    this.rateLimits.delete(key);
  }
}
```

<BackToTop />

## Security Best Practices

### 1. Transport Security

- **Always use HTTPS** to encrypt data in transit.
- **HSTS (HTTP Strict Transport Security)**: Enforce HTTPS by setting the `Strict-Transport-Security` header.
- **Content Security Policy (CSP)**: Mitigate XSS attacks by defining which resources can be loaded.
- **Secure Cookies**: Use `HttpOnly`, `Secure`, and `SameSite` attributes for cookies.
- **CORS (Cross-Origin Resource Sharing)**: Properly configure CORS to control which domains can access your API.

```javascript
// Enforce HTTPS in production
const enforceHTTPS = (req, res, next) => {
  if (process.env.NODE_ENV === "production" && !req.secure) {
    return res.redirect(301, `https://${req.headers.host}${req.url}`);
  }
  next();
};
```

<BackToTop />

### 2. Token Security

- **Use short-lived access tokens** with refresh tokens for long-term access.
- **Implement token revocation**: Maintain a blacklist of revoked tokens.
- **Validate tokens on every request**: Ensure tokens are not expired and belong to an active user.
- **Use strong signing algorithms** (e.g., RS256 for JWTs).
- **Store tokens securely**: Use HTTP-only cookies or secure storage mechanisms.
- **Implement CSRF protection** for session-based authentication.
- **Rate limit token requests** to prevent abuse.

```javascript
// Secure token validation
const validateToken = async (token) => {
  try {
    // Verify token signature and expiration
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // Check if token is blacklisted
    const isBlacklisted = await checkTokenBlacklist(decoded.jti);
    if (isBlacklisted) {
      throw new Error("Token has been revoked");
    }

    // Verify user still exists and is active
    const user = await User.findById(decoded.sub);
    if (!user || !user.isActive) {
      throw new Error("User not found or inactive");
    }

    return { valid: true, user };
  } catch (error) {
    return { valid: false, error: error.message };
  }
};
```

<BackToTop />

### 3. CSRF Protection

- **Use anti-CSRF tokens**: Generate a unique token for each session and include it in forms and AJAX requests.
- **Set the `SameSite` attribute** on cookies to prevent CSRF attacks.
- **Implement CORS policies** to restrict cross-origin requests.
- **Use custom headers** for AJAX requests to differentiate between same-origin and cross-origin requests.
- **Validate the `Origin` and `Referer` headers** on sensitive requests to ensure they come from your domain.

```javascript
// CSRF protection for session-based auth
const csrf = require("csurf");
const csrfProtection = csrf({ cookie: true });

app.use("/api", csrfProtection);

// Client-side CSRF token handling
const getCsrfToken = async () => {
  const response = await fetch("/api/csrf-token");
  const { csrfToken } = await response.json();
  return csrfToken;
};

const makeProtectedRequest = async (url, data) => {
  const csrfToken = await getCsrfToken();

  return fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-CSRF-Token": csrfToken,
    },
    body: JSON.stringify(data),
    credentials: "include",
  });
};
```

### 4. Rate Limiting

- **Implement rate limiting** to prevent abuse and brute-force attacks.
- **Limit requests per IP address** or user account.
- **Use libraries like `express-rate-limit`** for easy implementation in Node.js applications.
- **Monitor and log rate-limited requests** to detect potential attacks.
- **Adjust rate limits based on user roles** (e.g., higher limits for authenticated users).
- **Implement exponential backoff** for repeated requests to reduce server load.

```javascript
// Rate limiting implementation
const rateLimit = require("express-rate-limit");

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Limit each IP to 5 requests per windowMs
  message: "Too many login attempts, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
});

app.use("/api/auth/login", authLimiter);
```

<BackToTop />

## Common Authentication Flows

### 1. Login Flow

The example below demonstrates a typical login flow using a client-side API call. It includes input validation, error handling, token-based request logic, and post-authentication behavior such as storing user information and redirecting to a protected route. While this is a basic implementation, it provides a clear foundation for integrating more advanced authentication mechanisms such as OAuth, OpenID Connect, or multi-factor authentication.

```javascript
// Complete login flow with error handling
const AuthService = {
  async login(email, password) {
    const validationErrors = this.validateLoginInput(email, password);
    if (validationErrors.length > 0) {
      throw new Error(validationErrors.join(", "));
    }

    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, password }),
        credentials: "include",
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Login failed");
      }

      // Handle successful login
      this.handleSuccessfulLogin(data);

      return { success: true, user: data.user };
    } catch (error) {
      console.error("Login error:", error);
      throw error;
    }
  },

  validateLoginInput(email, password) {
    const errors = [];

    if (!email) errors.push("Email is required");
    if (!password) errors.push("Password is required");

    if (email && !/\S+@\S+\.\S+/.test(email)) {
      errors.push("Email format is invalid");
    }

    if (password && password.length < 6) {
      errors.push("Password must be at least 6 characters");
    }

    return errors;
  },

  handleSuccessfulLogin(data) {
    // Store user data if needed
    if (data.user) {
      localStorage.setItem("user", JSON.stringify(data.user));
    }

    // Emit login event for other parts of the app
    window.dispatchEvent(
      new CustomEvent("userLoggedIn", {
        detail: data.user,
      })
    );

    // Redirect to intended page or dashboard
    const redirectUrl =
      sessionStorage.getItem("redirectAfterLogin") || "/dashboard";
    sessionStorage.removeItem("redirectAfterLogin");
    window.location.href = redirectUrl;
  },
};
```

<BackToTop />

### 2. Registration Flow

The example below illustrates a user registration flow that includes input validation, error handling, and a successful registration response. It ensures that user data is validated before making the API call and provides feedback to the user in case of errors.

```javascript
// User registration with validation
const RegistrationService = {
  async register(userData) {
    const validationErrors = this.validateRegistrationData(userData);
    if (validationErrors.length > 0) {
      throw new Error(validationErrors.join(", "));
    }

    try {
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(userData),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Registration failed");
      }

      return { success: true, message: data.message };
    } catch (error) {
      console.error("Registration error:", error);
      throw error;
    }
  },

  validateRegistrationData({
    email,
    password,
    confirmPassword,
    firstName,
    lastName,
  }) {
    const errors = [];

    if (!firstName) errors.push("First name is required");
    if (!lastName) errors.push("Last name is required");
    if (!email) errors.push("Email is required");
    if (!password) errors.push("Password is required");
    if (!confirmPassword) errors.push("Password confirmation is required");

    if (email && !/\S+@\S+\.\S+/.test(email)) {
      errors.push("Email format is invalid");
    }

    if (password && password.length < 8) {
      errors.push("Password must be at least 8 characters");
    }

    if (password && !/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(password)) {
      errors.push(
        "Password must contain at least one uppercase letter, one lowercase letter, and one number"
      );
    }

    if (password !== confirmPassword) {
      errors.push("Passwords do not match");
    }

    return errors;
  },
};
```

<BackToTop />

### 3. Password Reset Flow

The example below demonstrates a password reset flow that includes requesting a password reset, validating the reset token, and updating the password. It ensures that the new password meets security requirements and provides feedback to the user in case of errors.

```javascript
// Password reset implementation
const PasswordResetService = {
  async requestPasswordReset(email) {
    try {
      const response = await fetch("/api/auth/password-reset/request", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Password reset request failed");
      }

      return { success: true, message: data.message };
    } catch (error) {
      console.error("Password reset request error:", error);
      throw error;
    }
  },

  async resetPassword(token, newPassword, confirmPassword) {
    if (newPassword !== confirmPassword) {
      throw new Error("Passwords do not match");
    }

    if (newPassword.length < 8) {
      throw new Error("Password must be at least 8 characters");
    }

    try {
      const response = await fetch("/api/auth/password-reset/confirm", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ token, newPassword }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Password reset failed");
      }

      return { success: true, message: data.message };
    } catch (error) {
      console.error("Password reset error:", error);
      throw error;
    }
  },
};
```

<BackToTop />

## Authentication Error Handling

This section provides a comprehensive error handling utility for authentication-related errors. It includes a custom error class, predefined error codes, and a handler that processes errors based on their type. This approach allows for consistent error handling across the application, making it easier to manage authentication-related issues.

### Common Authentication Errors

The example below defines a custom error class for authentication errors, along with a set of predefined error codes. The `AuthErrorHandler` provides methods to handle different types of authentication errors, such as invalid credentials, token expiration, and insufficient permissions. This structure allows for clear and consistent error handling throughout the application.

```javascript
// Comprehensive error handling utility
class AuthError extends Error {
  constructor(message, code, statusCode = 400) {
    super(message);
    this.name = "AuthError";
    this.code = code;
    this.statusCode = statusCode;
  }
}

const AuthErrorCodes = {
  INVALID_CREDENTIALS: "INVALID_CREDENTIALS",
  TOKEN_EXPIRED: "TOKEN_EXPIRED",
  TOKEN_INVALID: "TOKEN_INVALID",
  USER_NOT_FOUND: "USER_NOT_FOUND",
  ACCOUNT_LOCKED: "ACCOUNT_LOCKED",
  EMAIL_NOT_VERIFIED: "EMAIL_NOT_VERIFIED",
  INSUFFICIENT_PERMISSIONS: "INSUFFICIENT_PERMISSIONS",
  RATE_LIMIT_EXCEEDED: "RATE_LIMIT_EXCEEDED",
  NETWORK_ERROR: "NETWORK_ERROR",
};

const AuthErrorHandler = {
  handleError(error) {
    console.error("Authentication error:", error);

    switch (error.code) {
      case AuthErrorCodes.INVALID_CREDENTIALS:
        return {
          message: "Invalid email or password. Please try again.",
          action: "retry",
        };

      case AuthErrorCodes.TOKEN_EXPIRED:
        return {
          message: "Your session has expired. Please log in again.",
          action: "redirect_to_login",
        };

      case AuthErrorCodes.ACCOUNT_LOCKED:
        return {
          message:
            "Your account has been temporarily locked due to multiple failed login attempts.",
          action: "contact_support",
        };

      case AuthErrorCodes.EMAIL_NOT_VERIFIED:
        return {
          message: "Please verify your email address before logging in.",
          action: "resend_verification",
        };

      case AuthErrorCodes.RATE_LIMIT_EXCEEDED:
        return {
          message: "Too many login attempts. Please try again later.",
          action: "wait_and_retry",
        };

      case AuthErrorCodes.NETWORK_ERROR:
        return {
          message: "Network error. Please check your connection and try again.",
          action: "retry",
        };

      default:
        return {
          message: "An unexpected error occurred. Please try again.",
          action: "retry",
        };
    }
  },

  // Client-side error handler
  async handleAuthRequest(requestFn) {
    try {
      return await requestFn();
    } catch (error) {
      if (error.name === "TypeError" && error.message.includes("fetch")) {
        throw new AuthError(
          "Network error occurred",
          AuthErrorCodes.NETWORK_ERROR,
          0
        );
      }

      if (error.response) {
        const { status, data } = error.response;

        switch (status) {
          case 401:
            throw new AuthError(
              data.error || "Authentication failed",
              AuthErrorCodes.INVALID_CREDENTIALS,
              401
            );
          case 403:
            throw new AuthError(
              "Insufficient permissions",
              AuthErrorCodes.INSUFFICIENT_PERMISSIONS,
              403
            );
          case 429:
            throw new AuthError(
              "Rate limit exceeded",
              AuthErrorCodes.RATE_LIMIT_EXCEEDED,
              429
            );
          default:
            throw error;
        }
      }

      throw error;
    }
  },
};

// Usage in React component
const LoginForm = () => {
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (email, password) => {
    setIsLoading(true);
    setError(null);

    try {
      await AuthErrorHandler.handleAuthRequest(async () => {
        return await AuthService.login(email, password);
      });

      // Handle successful login
    } catch (authError) {
      const errorInfo = AuthErrorHandler.handleError(authError);
      setError(errorInfo);

      // Handle specific actions
      switch (errorInfo.action) {
        case "redirect_to_login":
          window.location.href = "/login";
          break;
        case "resend_verification":
          // Show resend verification button
          break;
        // Handle other actions...
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && <div className="error-message">{error.message}</div>}
      {/* Form fields */}
    </form>
  );
};
```

<BackToTop />

## Testing Authentication

Testing authentication logic is crucial to ensure that your authentication flows work as expected and handle errors gracefully. It involves both unit tests for individual functions and integration tests for the complete authentication flow.

### Unit Testing Authentication Logic

Unit tests focus on individual functions or methods, ensuring they behave correctly under various conditions. The example below demonstrates how to test the `AuthService` class, which handles login, token management, and input validation.

```javascript
// authService.test.js
import { describe, it, expect, beforeEach, jest } from "@jest/globals";
import AuthService from "../authService";

// Mock fetch
global.fetch = jest.fn();

describe("AuthService", () => {
  beforeEach(() => {
    fetch.mockClear();
    localStorage.clear();
    sessionStorage.clear();
  });

  describe("login", () => {
    it("should successfully log in with valid credentials", async () => {
      const mockResponse = {
        ok: true,
        json: async () => ({
          success: true,
          user: { id: 1, email: "test@example.com" },
          token: "mock-token",
        }),
      };

      fetch.mockResolvedValueOnce(mockResponse);

      const result = await AuthService.login("test@example.com", "password");

      expect(fetch).toHaveBeenCalledWith("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          email: "test@example.com",
          password: "password",
        }),
        credentials: "include",
      });

      expect(result.success).toBe(true);
      expect(result.user.email).toBe("test@example.com");
    });

    it("should handle login failure", async () => {
      const mockResponse = {
        ok: false,
        status: 401,
        json: async () => ({
          error: "Invalid credentials",
        }),
      };

      fetch.mockResolvedValueOnce(mockResponse);

      await expect(
        AuthService.login("test@example.com", "wrong-password")
      ).rejects.toThrow("Invalid credentials");
    });

    it("should validate email format", async () => {
      await expect(
        AuthService.login("invalid-email", "password")
      ).rejects.toThrow("Email format is invalid");
    });

    it("should validate password length", async () => {
      await expect(
        AuthService.login("test@example.com", "123")
      ).rejects.toThrow("Password must be at least 6 characters");
    });
  });

  describe("token management", () => {
    it("should store token in localStorage", () => {
      const token = "mock-token";
      AuthService.storeToken(token);

      expect(localStorage.getItem("authToken")).toBe(token);
    });

    it("should remove token on logout", () => {
      localStorage.setItem("authToken", "mock-token");
      AuthService.logout();

      expect(localStorage.getItem("authToken")).toBeNull();
    });

    it("should validate token format", () => {
      expect(AuthService.isValidTokenFormat("valid.jwt.token")).toBe(true);
      expect(AuthService.isValidTokenFormat("invalid-token")).toBe(false);
      expect(AuthService.isValidTokenFormat("")).toBe(false);
      expect(AuthService.isValidTokenFormat(null)).toBe(false);
    });
  });
});
```

<BackToTop />

### Integration Testing

Integration tests verify that different parts of the application work together as expected. The example below demonstrates how to test the complete login flow using a mock server to simulate API responses.

```javascript
// auth.integration.test.js
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { rest } from "msw";
import { setupServer } from "msw/node";
import LoginForm from "../components/LoginForm";
import { AuthProvider } from "../contexts/AuthContext";

// Mock API server
const server = setupServer(
  rest.post("/api/auth/login", (req, res, ctx) => {
    const { email, password } = req.body;

    if (email === "test@example.com" && password === "password") {
      return res(
        ctx.json({
          success: true,
          user: { id: 1, email: "test@example.com", name: "Test User" },
          token: "mock-jwt-token",
        })
      );
    }

    return res(ctx.status(401), ctx.json({ error: "Invalid credentials" }));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

const renderWithAuth = (component) => {
  return render(<AuthProvider>{component}</AuthProvider>);
};

describe("Login Integration", () => {
  it("should complete login flow successfully", async () => {
    const user = userEvent.setup();

    renderWithAuth(<LoginForm />);

    // Fill in the form
    const emailInput = screen.getByLabelText(/email/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole("button", { name: /login/i });

    await user.type(emailInput, "test@example.com");
    await user.type(passwordInput, "password");
    await user.click(submitButton);

    // Wait for successful login
    await waitFor(() => {
      expect(screen.getByText(/welcome/i)).toBeInTheDocument();
    });
  });

  it("should display error for invalid credentials", async () => {
    const user = userEvent.setup();

    renderWithAuth(<LoginForm />);

    const emailInput = screen.getByLabelText(/email/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole("button", { name: /login/i });

    await user.type(emailInput, "test@example.com");
    await user.type(passwordInput, "wrong-password");
    await user.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText(/invalid credentials/i)).toBeInTheDocument();
    });
  });
});
```

<BackToTop />

### End-to-End Testing

End-to-end (E2E) tests simulate real user interactions with the application, ensuring that the entire authentication flow works as expected. The example below demonstrates how to test the complete authentication flow using Playwright or Cypress.

```javascript
// auth.e2e.test.js (using Playwright or Cypress)
import { test, expect } from "@playwright/test";

test.describe("Authentication E2E", () => {
  test("complete user authentication flow", async ({ page }) => {
    // Navigate to login page
    await page.goto("/login");

    // Fill login form
    await page.fill('[data-testid="email-input"]', "test@example.com");
    await page.fill('[data-testid="password-input"]', "password");

    // Submit form
    await page.click('[data-testid="login-button"]');

    // Verify redirect to dashboard
    await expect(page).toHaveURL("/dashboard");

    // Verify user is logged in
    await expect(page.locator('[data-testid="user-menu"]')).toBeVisible();

    // Test protected route access
    await page.goto("/profile");
    await expect(page.locator('[data-testid="profile-form"]')).toBeVisible();

    // Test logout
    await page.click('[data-testid="logout-button"]');
    await expect(page).toHaveURL("/login");

    // Verify protected route redirects to login
    await page.goto("/profile");
    await expect(page).toHaveURL("/login");
  });

  test("handles token expiration", async ({ page }) => {
    // Login
    await page.goto("/login");
    await page.fill('[data-testid="email-input"]', "test@example.com");
    await page.fill('[data-testid="password-input"]', "password");
    await page.click('[data-testid="login-button"]');

    // Mock token expiration
    await page.evaluate(() => {
      localStorage.setItem("authToken", "expired-token");
    });

    // Try to access protected route
    await page.goto("/dashboard");

    // Should redirect to login
    await expect(page).toHaveURL("/login");
    await expect(
      page.locator('[data-testid="session-expired-message"]')
    ).toBeVisible();
  });
});
```

<BackToTop />
