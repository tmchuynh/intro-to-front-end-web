import BackToTop from "@/components/BackToTop";

# CSS Selectors

## Table of Contents

## Overview of CSS Selectors

CSS selectors are fundamental components of CSS that allow developers to target HTML elements for styling. They provide a way to apply styles based on element types, classes, IDs, attributes, and more. Understanding selectors is crucial for effective web design and development.

## Types of CSS Selectors

CSS offers a variety of selectors to target elements in different ways. Here are some of the most commonly used selectors:
| Selector Type | Syntax | Description |
| -------------- | ------ | ----------- |
| Universal Selector | `*` | Selects all elements in the document. |
| Type Selector | `element` | Selects all elements of a specific type (e.g, `div`, `p`, `h1`). |
| Class Selector | `.class-name` | Selects all elements with a specific class. Classes are reusable and can be applied to multiple elements. |
| ID Selector | `#id-name` | Selects a single element with a specific ID. IDs must be unique within a document. |
| Attribute Selector | `[attribute]` || Selects elements with a specific attribute. |
| Attribute Value Selector | `[attribute="value"]` | Selects elements with a specific attribute value. |
| Descendant Selector | `parent child` | Selects all child elements of a specific parent element. |
| Child Selector | `parent > child` | Selects direct child elements of a specific parent element. |
| Adjacent Sibling Selector | `element1 + element2` | Selects the first element that is immediately preceded by another element. |
| General Sibling Selector | `element1 ~ element2` | Selects all elements that are siblings of a specific element, regardless of their position. |
| Pseudo-class Selector | `:pseudo-class` | Selects elements based on their state or position (e.g., `:hover`, `:first-child`, `:last-child`). |
| Pseudo-element Selector | `::pseudo-element` | Selects a specific part of an element (e.g, `::before`, `::after`, `::first-letter`). |

<BackToTop />

## Using CSS Selectors

### Selecting Elements by Attributes

- `[attribute]` selector is used to select elements with a specified attribute
- `[attribute*="value"]` selector is used to select elements whose attribute value contains a specified value.
- `[attribute^="value"]` selector is used to select elements with the specified attribute, whose value starts with the specified value.
- `[attribute="value"]` selector is used to select elements with a specified attribute and value.
- `[attribute|="value"]` selector is used to select elements with the specified attribute, whose value can be exactly the specified value, or the specified value followed by a hyphen (-)
- `[attribute~="value"]` selector is used to select elements with an attribute value containing a specified word.
- `[attribute$="value"]` selector is used to select elements whose attribute value ends with a specified value.

```css
/* Selects all <input> elements with type="text" */
input[type="text"] {
  border: 1px solid #ccc;
}

/* Selects all <a> elements with an href containing "example" */
a[href*="example"] {
  font-size: 2em;
}

/* Selects all <img> elements with a specific src attribute */
img[src="logo.png"] {
  width: 100px;
}
```

### Combining Selectors

Selectors can be combined to create more specific rules. For example:

```css
/* Selects all <p> elements inside a <div> with class "container" */
.container p {
  color: blue;
}
```

### Selecting Elements by Relationships

**Combinators** in CSS help define _relationships_ between HTML elements and control where styles are applied based on the elements' positions or their relationships within the document.

- Descendant combinator (space): Targets elements that match the second selector, but only if they are nested within elements matched by the first selector.

  ```css
  /* Selects all <p> elements inside any <div> */
  div p {
    color: blue;
  }
  ```

- Child combinator (`>`): Selects elements that are direct children of a specified parent.

  ```css
  /* Selects only direct <li> children of <ul> */
  ul > li {
    list-style-type: square;
  }
  ```

- Next-sibling combinator (`+`): Targets elements that come right after the first element provided.

  ```css
  /* Selects the first <p> immediately after any <h1> */
  h1 + p {
    margin-top: 0;
  }
  ```

- Subsequent-sibling combinator (`~`): Selects all sibling elements that follow a specified element.

  ```css
  /* Selects all <p> elements that are siblings of any <h1> */
  h1 ~ p {
    color: gray;
  }
  ```

### Selecting Elements by HTML Classes and IDs

In CSS, you can select elements based on their **classes** and **IDs** to apply specific styles.
**Classes** are used to group multiple elements together, allowing you to apply the same styles to all elements with that class. Classes are defined in HTML using the `class` attribute and can be reused across different elements.
**IDs** are unique identifiers for a single element on a page, allowing you to apply styles to that specific element. IDs are defined in HTML using the `id` attribute and should be unique within a document.

```css
/* Selects all elements with the class "highlight" */
.highlight {
  background-color: yellow;
}
/* Selects the element with the ID "main-title" */
#main-title {
  font-size: 2em;
  color: blue;
}
```

In this example, all elements with the class `highlight` will have a yellow background, while the element with the ID `main-title` will have a larger font size and blue color.

#### Is ID Stronger Than Class CSS?

Yes, **ID selectors** are stronger than **class selectors** in CSS. Think of it as the heavyweight champion of specificity. When the browser decides which styles to apply, it follows a system called **specificity**. In this system, IDs have more priority than classes, so if an ID and a class are both targeting the same element, the ID will always win.

Next time you’re coding, remember: if you want to highlight something specific, use an ID. But when you’re styling a group of elements, classes are your go-to for keeping things consistent!

### Selecting HTML Elements by Type

In CSS, you can select HTML elements by their type (also known as element selectors). This allows you to apply styles to all instances of a specific HTML element across your web page.
Each CSS rule starts with a **selector**, which tells the browser which HTML element(s) to style. When you use an HTML element as a selector in CSS, the style applies to every instance of that element across the page.

For example, if you style all `<h1>` elements to be red, every heading will turn red. Likewise, if you apply a green style to `<p>` elements, every paragraph will turn green, affecting all occurrences of those elements throughout the document.

```css
/* Selects all <h1> elements */
h1 {
  color: red;
}
/* Selects all <p> elements */
p {
  color: green;
}
```

### CSS Unions

CSS **unions** refer to the ability to combine multiple selectors in a single CSS rule. This is done by separating the selectors with a comma. When you use a union, the styles apply to all the elements that match any of the selectors in the group.

```css
h1,
h2,
h3 {
  color: blue;
  font-family: Arial, sans-serif;
}
```

This example applies the same styles to all `<h1>`, `<h2>`, and `<h3>` elements, making it easy to maintain consistent styling across different heading levels.

### Selecting HTML Elements’ State

In web design, an element's state refers to its current appearance, which changes based on user interactions – like the "mood" of the element. For example, when a user hovers over a button, its state shifts to show it's ready to be clicked.

To define these states in CSS, we use **pseudo-classes**, which are added to selectors with a colon (`:`). For instance, the `:hover` pseudo-class triggers when a user places their cursor over an element.

```css
button {
  background-color: blue;
  color: white;
}

/* Changes to green on mouse hover */
button:hover {
  background-color: green;
}
```

##### NOTE

> There are several types of pseudo-classes in CSS, which are used to apply styles based on the state of an element or its relationship to other elements. Below is a brief overview of some common types. Please note that this list does not encompass all pseudo-classes or all variations within each type.

<BackToTop />

### Pseudo-classes Overview

| Pseudo-class Type    | Description                                                                                                                                                                                                                                                                                                                                     |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Dynamic              | These apply styles based on user interaction, such as `:hover`, `:active`, and `:focus`. They change the appearance of elements when users interact with them, like hovering over a button or focusing on an input field.                                                                                                                       |
| Structural           | These target elements based on their position in the document structure, such as `:first-child`, `:last-child`, and `:nth-child()`. They allow you to style elements based on their order or relationship to other elements, like styling the first item in a list differently from the others.                                                 |
| State-based          | These apply styles based on the state of an element, such as `:checked` for checkboxes or radio buttons, and `:disabled` for disabled form elements. They help style elements based on their current state, like changing the appearance of a checkbox when it is checked or a button when it is disabled.                                      |
| Resource State       | These apply styles based on the state of a resource, such as `:paused`, `:playing`, and `:ended` for media elements like audio or video. They allow you to style media elements based on their playback state, like changing the appearance of a play button when the media is paused or playing.                                               |
| Link                 | These are used to style links based on their state, such as `:link`, `:visited`, `:active`, and `:focus`. They allow you to differentiate between unvisited links, visited links, and links that are currently being interacted with. For example, you can style unvisited links in blue, visited links in purple, and active links in red.     |
| For Forms            | These target form elements based on their state, such as `:valid`, `:invalid`, and `:required`. They help style form inputs based on whether they are valid, invalid, or required. For instance, you can change the border color of an input field to green when it is valid and red when it is invalid.                                        |
| For User Interaction | These apply styles based on user interaction with elements, such as `:hover`, `:active`, and `:focus`. They allow you to change the appearance of elements when users interact with them, like changing the background color of a button when it is hovered over or focused on.                                                                 |
| For Content          | These target elements based on their content, such as `:empty`, which selects elements that have no children, and `:not()`, which selects elements that do not match a specified selector. They help style elements based on their content or lack thereof, like hiding empty paragraphs or styling elements that do not have a specific class. |
| For Media Queries    | These apply styles based on media conditions, such as `:media()` which allows you to style elements based on the media type or features. They help create responsive designs by applying different styles based on the device or screen size, like changing the layout of a page for mobile devices versus desktop.                             |
| For Custom States    | These allow you to define custom states for elements, such as `:checked` for checkboxes or radio buttons, and `:disabled` for disabled form elements. They help style elements based on their custom states, like changing the appearance of a checkbox when it is checked or a button when it is disabled.                                     |
| For Accessibility    | These apply styles to improve accessibility, such as `:focus-visible`, which styles elements that are focused and should be visible to users. They help enhance the user experience for people using keyboard navigation or assistive technologies, like highlighting focused elements for better visibility.                                   |
| For Animation        | These apply styles to elements that are being animated, such as `:animated`, which selects elements that are currently being animated. They help style elements during animations, like changing the opacity of an element while it is fading in or out.                                                                                        |

<BackToTop />

<br />

##### NOTE

> **An+B notation** in CSS is used to select elements based on their position among siblings in functional pseudo-classes.
> It allows you to target elements based on their order, such as the first, last, or every nth element. This notation is particularly useful for styling lists or groups of elements where you want to apply styles to specific items based on their position.
>
> - **A**: Multiplier for the interval between elements.
> - **n**: Variable representing a count (0, 1, 2, ...).
> - **B**: Offset to adjust the start point.
>
> Examples:
>
> - `:nth-child(2n)`: Selects every second element (2, 4, 6, ...).
> - `:nth-child(2n+1)`: Selects every second element starting from the first (1, 3, 5, ...).
> - `:nth-child(3n+2)`: Selects elements in the pattern 2, 5, 8, ..., with an offset of 2.

#### Example of Link Effects

To demonstrate how pseudo-classes can be used to style links, consider the following example. This code snippet shows how to style links with different effects based on their state, such as visited and unvisited links. The `:visited` pseudo-class is used to change the color and style of links that have already been clicked, while the `:hover` pseudo-class is used to change the appearance of links when the user hovers over them. This enhances user experience by providing visual feedback on link interactions.

```css
a {
  color: blue;
  font-weight: bold;
  text-decoration: none;
}
a:visited {
  color: white;
  font-weight: bold;
  text-decoration: double underline;
}
```

## Understanding CSS Specificity and the Cascade

**Cascading** is a fundamental principle in CSS that dictates how styles are applied to HTML elements when multiple rules could affect the same element. Understanding how the cascade works is crucial for effectively managing styles in a web document.

### The Cascade

The cascade refers to the order in which CSS rules are applied to elements. When multiple rules match the same element, the browser determines which styles to apply based on three main factors:

1. **Importance**: Inline styles (styles applied directly to an element using the `style` attribute) have the highest priority, followed by styles marked as `!important`. Regular stylesheets have the lowest priority.
2. **Specificity**: More specific selectors take precedence over less specific ones. For example, an ID selector (`#id`) is more specific than a class selector (`.class`), and a class selector is more specific than a type selector (`element`).
3. **Source Order**: If two rules have the same specificity and importance, the one that appears later in the stylesheet takes precedence. This means that styles defined later in the CSS file will override earlier styles if they have the same specificity.

### Source Order

The source order refers to the sequence in which styles are defined in your stylesheet or HTML document.

**Later Styles Override Earlier Ones**: If two rules apply to the same element and have the same specificity, the rule that appears later in the CSS will take precedence. This behavior allows developers to create more specific styles without needing to increase specificity unnecessarily.

```css
h1 {
  color: blue;
}

/* This will override the previous blue color */
h1 {
  color: green;
}
```

##### NOTE

> The order of your CSS styles plays a crucial role in how they're applied. Styles that appear later in the stylesheet will override earlier ones if they target the same element and have the same specificity. While this allows for flexible adjustments without increasing specificity, it can also lead to unintentional overrides. To avoid confusion and unexpected behavior, keep your stylesheets well-organized, and document any intentional overrides to maintain clarity and consistency in your design.

### Specificity

Specificity in CSS is key to determining which styles are applied when multiple rules target the same element. It assigns a numerical value to a selector based on how specific it is in targeting an element. The higher the specificity, the more likely that selector will override others, ensuring its styles take precedence over any conflicting rules. Selector specificity determines which styles are applied when multiple rules match the same element. Specificity is calculated based on the types of selectors used:

- Inline styles (highest specificity)
- ID selectors
- Class selectors, attribute selectors, and pseudo-classes
- Type selectors and pseudo-elements (lowest specificity)
  Understanding specificity helps avoid conflicts and ensures the intended styles are applied.

### Specificity Calculation

Specificity is calculated based on the types of selectors used in a CSS rule. The specificity is represented as a four-part value: (a, b, c, d), where:

- a: Number of inline styles (highest specificity)
- b: Number of ID selectors
- c: Number of class selectors, attribute selectors, and pseudo-classes
- d: Number of type selectors and pseudo-elements (lowest specificity)
  When comparing selectors, the one with the higher values in these categories will take precedence.

```css
/* Specificity Calculation Example */
/* Inline style (specificity: 1, 0, 0, 0) */
h1 {
  color: red; /* Specificity: (1, 0, 0, 0) */
}
/* ID selector (specificity: 0, 1, 0, 0) */
#header {
  color: blue; /* Specificity: (0, 1, 0, 0) */
}
/* Class selector (specificity: 0, 0, 1, 0) */
.container {
  color: green; /* Specificity: (0, 0, 1, 0) */
}
/* Type selector (specificity: 0, 0, 0, 1) */
p {
  color: yellow; /* Specificity: (0, 0, 0, 1) */
}
```

#### Example of Specificity Calculation

```css
h1 {
  color: blue;
}

.highlight {
  color: green;
}

#main-title {
  color: red;
}

h1.highlight {
  color: purple;
}
```

##### Specificity Breakdown

- The `h1` selector applies blue but has a specificity of (0, 0, 0, 1).
- The `.highlight` class applies green but has a specificity of (0, 0, 1, 0).
- The `#main-title` ID selector applies red with a specificity of (0, 1, 0, 0).
- The combined selector `h1.highlight` applies purple with a specificity of (0, 0, 1, 1).

**Result:**  
The final color for `<h1 id="main-title" class="highlight">Welcome!</h1>` will be red, as the ID selector (`#main-title`) has the highest specificity.

### Overriding the Order with `!important`

The `!important` declaration in CSS is like a loud megaphone that allows you to override the natural cascade of styles. When a style is marked as `!important`, it takes precedence over any other styles, no matter how specific they are or what order they appear in. It’s the ultimate trump card in the game of CSS!

However, this power should be wielded sparingly. Using `!important` can make debugging and maintaining your styles feel like navigating a maze blindfolded. It effectively breaks the cascade, leading to unexpected results if overused—kind of like when someone insists on using all caps in an email; it might get your attention, but it can also be a bit overwhelming!

So, use `!important` judiciously, or you might find yourself tangled in a web of CSS chaos!

### Tie-Break Situations

In cases where styles have the same specificity and order, tie-break situations arise. The browser resolves these conflicts based on:

- Source Order: The later style in the CSS will take precedence.
- Browser Default Styles: If two user-defined styles conflict and have the same specificity, the browser’s default style may apply, which could differ between browsers.
- Inheritance: Some properties are inherited from parent elements. If styles are tied, inherited styles may also come into play, affecting the final appearance of the element.

## Best Practices for Using Selectors

- Use Classes for Reusability: Prefer using class selectors over IDs for styling, as classes can be reused across multiple elements.
- Keep Selectors Simple: Avoid overly complex selectors that can make your CSS harder to read and maintain. Aim for clarity and simplicity.
- Organize CSS: Group related styles together and use comments to separate sections. This improves readability and maintainability.
- Use Specificity Wisely: Be mindful of specificity to avoid unintended style overrides. Use more specific selectors only when necessary.
- Test Across Browsers: Ensure your selectors work consistently across different browsers and devices. Use tools like browser developer tools to inspect and debug styles.
  <BackToTop />
