import BackToTop from "@/components/BackToTop";

# Data Structures in JavaScript

## Table of Contents

## Stacks

A **stack** is a data structure that follows the **LIFO** (Last In, First Out) principle, where the last item added is the first to be removed. It's like a stack of plates: you can only add or remove plates from the top.

## Key Stack Operations:

1. **Push**: Adds an item to the top
2. **Pop**: Removes the top item
3. **Peek**: Views the top item without removing it
4. **IsEmpty**: Checks if the stack is empty
5. **Size**: Returns the number of items

Stacks are often implemented using arrays, where **push** adds to the end, and **pop** removes the last item, maintaining LIFO behavior.

### Common Uses of Stacks:

- Function call management in programming languages (call stack)
- Expression parsing (e.g., evaluating mathematical expressions)
- Backtracking algorithms (e.g., maze solving)
- Undo/Redo functionality in applications

### Stack Variants:

- Simple Stack: Basic LIFO stack
- Dynamic Stack: Grows and shrinks as needed, often implemented with linked lists
- Array-based Stack: Uses a fixed-size array, which can lead to overflow if the stack exceeds its capacity
- Bounded Stack: Has a maximum size limit, preventing overflow but can lead to underflow if items are popped from an empty stack

### Limitations of Stacks:

- Limited access: You can only access the top item
- Fixed size: For array-based stacks, the size is fixed unless dynamic structures like linked lists are used
- No random access: You cannot access items in the middle of the stack; you must pop items off the top to reach them

<BackToTop />

## Queues

A **queue** is a data structure that follows the **FIFO** (First In, First Out) principle, where the first element added is the first to be removed. This is the opposite of stacks, which follow LIFO (Last In, First Out).

### How Queues Work

Elements are added at the back and removed from the front, like people standing in line – the first person in line is served first.

### Key Operations:

1. **Enqueue**: Adds an element to the back
2. **Dequeue**: Removes and returns the front element
3. **Peek**: Views the front element without removing it
4. **IsEmpty**: Checks if the queue is empty
5. **Size**: Returns the number of elements

### Queue Variants:

- Simple Queue: Basic FIFO queue
- Circular Queue: Allows the front and back to wrap around for efficient space use
- Priority Queue: Elements are dequeued based on priority rather than order
- Deque (Double-ended Queue): Allows adding/removing from both ends

Queues are often implemented using arrays or linked lists, where **enqueue** adds to the end, and **dequeue** removes from the front.

### Common Uses:

- Task scheduling in operating systems
- Print job management in printers
- Breadth-first search in graph algorithms
- Event handling in user interfaces
- Message queues in distributed systems
- Buffering in streaming applications

<BackToTop />

## Linked Lists

A **linked list** is a data structure where values are stored as individual **nodes** linked sequentially via **pointers**. Each node points to the next one, and the last node points to **null**, marking the end of the list.

### Types of Linked Lists:

1. **Singly Linked List**: Each node has one pointer, pointing to the next node, allowing one-way traversal.

```
[Node 1] -> [Node 2] -> [Node 3] -> null
```

2. **Doubly Linked List**: Each node has two pointers – one to the next and one to the previous node, enabling two-way traversal.

```
null <- [Node 1] <-> [Node 2] <-> [Node 3] -> null
```

### Key Components of a Linked List

- Head: The first node in the list
- Tail: The last node in the list, where the pointer to the next node is null
- Node: Each element in the list, which contains a value and one or two pointers
- Length: Like arrays, linked lists have a length, referring to the number of nodes

### Differences between Linked Lists and Arrays

1. **No Indexes**: Unlike arrays, linked lists do not use indexes. Each node in the list only "knows" its immediate neighbors through pointers.

2. **Sequential Access**: Since there are no indexes, values cannot be accessed randomly. To find a specific value, you must traverse the list starting from the head (or tail in the case of a doubly linked list) until you reach the desired node.

3. **Efficient Insertion and Deletion**: One of the major advantages of linked lists is the efficiency of insertion and deletion operations. In arrays, inserting or deleting an element in the middle of the list requires shifting elements and updating indexes, which can be time-consuming. In linked lists, you only need to adjust the pointers of neighboring nodes.

### Common Operations:

- Push: Adds a node to the end
- Pop: Removes the last node
- Unshift: Adds a node to the beginning
- Shift: Removes the first node
- Get/Set: Retrieves or updates a node by position
- Insert/Remove: Inserts or deletes a node at a specific position
- Reverse: Reverses the node order in the list

<BackToTop />

## Trees

**Trees** are hierarchical structures with nodes arranged in a parent-child relationship. Each tree starts with a **root** node, and nodes that follow are called **children**, with the last nodes being **leaf** nodes. The height of the tree is the longest path from root to leaf.

### Key Features:

- Non-linear: Unlike arrays or linked lists, trees branch, enabling multiple paths
- Hierarchy: Each node can have many children but only one parent
- Rooted: Trees have a single root node with no cycles (no backtracking)

### Trees VS Other Structures:

- Arrays/Lists: Linear structures with one path, while trees branch
- Graphs: Can have multiple roots and cycles, unlike trees

### Common Uses:

- DOM in web development
- File systems
- AI decision trees

### Types of Trees:

- Binary Trees: Each node has up to two children
- Heaps: A special tree where parents are larger (MaxHeap) or smaller (MinHeap) than children
- Binary Search Trees (BST): A type of binary tree where left children are smaller, and right children are larger, making search operations fast and efficient

<BackToTop />

## Graphs

**Graphs** are a flexible data structure consisting of **nodes** (or vertices) and **edges** (connections between the nodes). Unlike trees, graphs don't follow a hierarchy; nodes can be connected in various ways, without the concepts of "root," "parent," or "leaf" nodes.

### Types of Graphs:

- Directed vs. Undirected: In **directed** graphs, edges have a one-way direction, like one-way streets, whereas **undirected** graphs have two-way connections, like two-way streets.
- Weighted vs. Unweighted: **Weighted** graphs assign values (e.g., cost or distance) to edges, useful for algorithms like finding the shortest path. **Unweighted** graphs simply show connections without any values.
- Cyclic vs. Acyclic: **Cyclic** graphs contain loops where a node can lead back to itself, while **acyclic** graphs have no such loops. Trees are a specific type of acyclic graph.

Graphs are essential for solving real-world problems, from social networks and transportation systems to web page ranking (like Google's PageRank) and recommendation engines. Their ability to model complex relationships makes them a cornerstone in computer science and algorithms.

### Common Graph Algorithms:

- Depth-First Search (DFS): Explores as far as possible along each branch before backtracking, useful for traversing or searching tree-like structures.
- Breadth-First Search (BFS): Explores all neighbors at the present depth prior to moving on to nodes at the next depth level, ideal for finding the shortest path in unweighted graphs.
- Dijkstra's Algorithm: Finds the shortest path from a starting node to all other nodes in a weighted graph, commonly used in routing and navigation systems.
- **A\* Algorithm**: An extension of Dijkstra's that uses heuristics to find the shortest path more efficiently, often used in pathfinding and graph traversal.
- Kruskal's and Prim's Algorithms: Used for finding the minimum spanning tree of a graph, which connects all vertices with the minimum total edge weight, useful in network design and optimization problems.
- Topological Sorting: Orders the nodes in a directed acyclic graph (DAG) such that for every directed edge from node A to node B, A comes before B in the ordering, useful in scheduling tasks and resolving dependencies.
- Floyd-Warshall Algorithm: Computes shortest paths between all pairs of nodes in a weighted graph, useful for dense graphs and network routing.
- Bellman-Ford Algorithm: Computes shortest paths from a single source node to all other nodes, even in graphs with negative edge weights, useful in scenarios like currency exchange rates.
- Tarjan's Algorithm: Finds strongly connected components in a directed graph, useful for analyzing networks and dependencies.
- Johnson's Algorithm: Computes shortest paths between all pairs of nodes in a sparse graph, useful for large graphs with varying edge weights.
- Graph Coloring: Assigns colors to nodes such that no two adjacent nodes share the same color, useful in scheduling and resource allocation problems.
- Network Flow Algorithms: Such as the Ford-Fulkerson method, used to find the maximum flow in a flow network, applicable in transportation and logistics.
- Community Detection Algorithms: Identify clusters or communities within a graph, useful in social network analysis and recommendation systems.
- Graph Isomorphism: Determines if two graphs are structurally the same, useful in pattern recognition and chemical structure analysis.
- Graph Traversal Algorithms: Such as random walks, used in various applications like web crawling and recommendation systems.
- Graph Partitioning: Divides a graph into smaller subgraphs while minimizing the number of edges between them, useful in parallel computing and load balancing.
- Graph Embedding: Maps graph nodes to a lower-dimensional space while preserving structural properties, useful in machine learning and data analysis.
- Spectral Graph Theory: Analyzes the properties of graphs using eigenvalues and eigenvectors, useful in network analysis and clustering.
- Graph Neural Networks (GNNs): A type of neural network designed to work directly with graph-structured data, useful in various applications like social network analysis, recommendation systems, and molecular chemistry.
- Random Graphs: Studies properties of graphs generated by random processes, useful in understanding complex networks and phenomena like the small-world effect.
- Graph Databases: Specialized databases designed to store and query graph data efficiently, useful in applications like social networks, recommendation systems, and fraud detection.

<BackToTop />
