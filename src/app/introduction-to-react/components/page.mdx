# Components

## Table of Contents

This is an example of a deeply nested navigation item to demonstrate the recursive accordion functionality.

## Components Overview

## Props and State Management in React

React components can manage their own data using props and state. Understanding how to use props and state effectively is crucial for building dynamic and interactive user interfaces.

### Props

Props (short for properties) are used to pass data from a parent component to a child component. They are read-only and cannot be modified by the child component. Props allow you to create dynamic and reusable components by passing different data to them.
Props are passed to components as attributes in JSX and can be accessed within the component using the `props` object.

```javascript
import React from "react";
function MyComponent(props) {
  return <div>Hello, {props.name}!</div>;
}
export default MyComponent;
```

In this example, `MyComponent` is a functional component that takes `props` as an argument and renders a `div` element with a greeting message. The `name` prop is accessed using `props.name`.
This component can be used in another component like this:

```javascript
import React from "react";
import MyComponent from "./MyComponent";
function App() {
  return <MyComponent name="John" />;
}
export default App;
```

In this example, the `App` component uses the `MyComponent` component and passes the `name` prop with the value "John". The `MyComponent` will render "Hello, John!" when it is rendered.

### State

State is a built-in object in React that allows components to manage their own data. It can be used to store dynamic data that can change over time, such as user input or fetched data from an API. State is mutable and can be updated using the `setState` method in class components or the `useState` hook in functional components.
State is an object that holds the data that affects the rendering of a component. When the state changes, React re-renders the component to reflect the new state. This allows for dynamic and interactive user interfaces.

```javascript
import React, { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
}
export default Counter;
```

In this example, the `Counter` component uses the `useState` hook to manage the `count` state. The `useState` hook returns an array with the current state value and a function to update the state. The `setCount` function is used to update the state when the button is clicked. The component re-renders whenever the state changes, displaying the updated count.

```javascript
import React, { Component } from "react";
class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }
  handleClick = () => {
    this.setState({ count: this.state.count + 1 });
  };
  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={this.handleClick}>Click me</button>
      </div>
    );
  }
}
export default Counter;
```

In this example, the `Counter` component is a class component that manages its own state using the `state` object. The `constructor` initializes the state with a `count` property set to 0. The `handleClick` method is used to update the state when the button is clicked. The component re-renders whenever the state changes, displaying the updated count.

## Creating Components

React applications are built using components, which are reusable pieces of UI that can be composed together to create complex user interfaces. Components can be either class-based or functional, with functional components being the preferred approach in modern React development.

### Functional Components

Functional components are simple JavaScript functions that return JSX (JavaScript XML) to render the UI. They can accept props as arguments and can use hooks to manage state and side effects.

```javascript
import React from "react";
function MyComponent(props) {
  return <div>Hello, {props.name}!</div>;
}
export default MyComponent;
```

Here, `MyComponent` is a functional component that takes `props` as an argument and renders a `div` element with a greeting message. The `name` prop is accessed using `props.name`.

This component can be used in another component like this:

```javascript
import React from "react";
import MyComponent from "./MyComponent";
function App() {
  return <MyComponent name="John" />;
}
export default App;
```

### Class Components

Class components are ES6 classes that extend the `React.Component` class. They can have their own state and lifecycle methods, but they are less commonly used in modern React development due to the introduction of hooks.

```javascript
import React, { Component } from "react";
class MyComponent extends Component {
  render() {
    return <div>Hello, {this.props.name}!</div>;
  }
}
export default MyComponent;
```

In this example, `MyComponent` is a class component that extends `React.Component`. It has a `render` method that returns JSX. The `name` prop is accessed using `this.props.name`.

## Server vs Client Components

In React, components can be categorized into server components and client components based on where they are rendered.

### Client Components

Client components, on the other hand, are rendered on the client side and can interact with the DOM directly. They are typically used for dynamic and interactive parts of the application, such as forms, buttons, and other UI elements that require user interaction. Client components can also fetch data from APIs or perform client-side rendering based on user actions.

### Server Components

Server components are rendered on the server and sent to the client as HTML. They can fetch data from APIs or databases and render the initial UI before sending it to the client. This approach improves performance and SEO by reducing the amount of JavaScript that needs to be executed on the client side.

## Component Lifecycle

React components have a lifecycle that consists of several phases: mounting, updating, and unmounting. Understanding the component lifecycle is essential for managing side effects, such as fetching data or subscribing to events.

### Mounting

Mounting is the phase where a component is created and inserted into the DOM. The following lifecycle methods are called during this phase:

- `constructor`: Called when the component is initialized. It is used to set up initial state and bind methods.
- `render`: Called to render the component's UI. It returns the JSX representation of the component.
- `componentDidMount`: Called after the component is mounted in the DOM. It is often used to perform side effects, such as fetching data or subscribing to events.

```javascript
import React, { Component } from "react";
class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.state = { data: null };
  }

  componentDidMount() {
    // Fetch data from an API
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((data) => this.setState({ data }));
  }

  render() {
    return (
      <div>
        {this.state.data ? <p>Data: {this.state.data}</p> : <p>Loading...</p>}
      </div>
    );
  }
}
export default MyComponent;
```

### Updating

Updating is the phase where a component's state or props change, causing it to re-render.
The following lifecycle methods are called during this phase:

- `shouldComponentUpdate`: Called before the component re-renders. It allows you to optimize rendering by returning `false` to prevent unnecessary updates.
- `render`: Called to re-render the component's UI.
- `componentDidUpdate`: Called after the component has re-rendered. It is often used to perform side effects based on the updated state or props.

```javascript
import React, { Component } from "react";
class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  shouldComponentUpdate(nextProps, nextState) {
    // Prevent re-rendering if count is even
    return nextState.count % 2 !== 0;
  }

  componentDidUpdate(prevProps, prevState) {
    console.log(
      "Component updated from",
      prevState.count,
      "to",
      this.state.count
    );
  }

  handleClick = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
export default MyComponent;
```

### Unmounting

Unmounting is the phase where a component is removed from the DOM. The following lifecycle method is called during this phase:

- `componentWillUnmount`: Called before the component is removed from the DOM. It is often used to clean up resources, such as unsubscribing from events or canceling network requests.

```javascript
import React, { Component } from "react";
class MyComponent extends Component {
  componentWillUnmount() {
    // Clean up resources, such as unsubscribing from events
    console.log("Component will unmount");
  }

  render() {
    return <div>My Component</div>;
  }
}
export default MyComponent;
```
