import BackToTop from "@/components/BackToTop";

# Suspense

## Table of Contents

## Overview

Suspense is a feature in React that allows components to "wait" for something before rendering. It is primarily used for handling asynchronous operations, such as data fetching, by allowing components to suspend rendering until the required data is available. This helps in managing loading states and improving user experience by preventing the display of incomplete or incorrect UI.

- **Suspense Component**: A wrapper component that can suspend rendering of its children until a promise is resolved.
- **Fallback UI**: A UI that is displayed while the component is suspended. This can be a loading spinner, placeholder, or any other component that indicates loading state.
- **Lazy Loading**: Suspense works well with React's lazy loading feature, allowing components to be loaded on demand.

## Suspense VS SuspenseList

- **Suspense**: Used to handle the loading state of a single component or a group of components that depend on asynchronous data.
- **SuspenseList**: Used to coordinate the loading states of multiple Suspense components, allowing them to be displayed in a specific order or with a staggered effect. This is useful for managing lists of components that may load at different times, ensuring a smoother user experience.

| Feature         | Suspense                                                          | SuspenseList                                                  |
| --------------- | ----------------------------------------------------------------- | ------------------------------------------------------------- |
| Purpose         | Handle loading state of a single component or group of components | Coordinate loading states of multiple Suspense components     |
| Use Case        | Displaying a loading spinner for a single data-fetching component | Managing a list of components that load asynchronously        |
| Rendering Order | Renders when the promise resolves                                 | Can control the order of rendering for multiple components    |
| Fallback UI     | Single fallback UI for the suspended component                    | Can have multiple fallbacks for each component in the list    |
| Coordination    | Does not coordinate multiple components                           | Coordinates multiple Suspense components for smoother loading |

<BackToTop />
## When to Use SuspenseList SuspenseList is particularly useful when you have
multiple components that depend on asynchronous data fetching and you want to
control their loading states in a coordinated manner. It allows you to manage
the order of rendering and display fallback UI for each component in the list,
providing a smoother user experience. - **List of Components**: Use SuspenseList
when you have a list of components that need to load asynchronously, such as a
list of articles, products, or user profiles. - **Coordinated Loading**: Use
SuspenseList to coordinate the loading states of multiple components, ensuring
that they are displayed in a specific order or with a staggered effect. -
**Fallback UI Management**: Use SuspenseList to manage fallback UI for each
component in the list, allowing you to display loading indicators or
placeholders while waiting for data to be fetched. - **Performance
Optimization**: Use SuspenseList to optimize performance by reducing the number
of unnecessary renders and improving the overall responsiveness of your
application. - **Complex UIs**: Use SuspenseList in complex UIs where multiple
components may depend on different data sources, allowing you to manage loading
states effectively. - **User Experience**: Use SuspenseList to provide a smooth
user experience by displaying loading indicators or placeholders while waiting
for content to load, especially in scenarios where multiple components are being
fetched simultaneously. ## When to Use Suspense

Suspense is particularly useful when you have components that rely on asynchronous data fetching or lazy loading. It allows you to manage loading states effectively, providing a better user experience by displaying fallback content while waiting for the data to be ready.

- **Data Fetching**: Use Suspense to handle loading states for components that fetch data from APIs or other sources.
- **Lazy Loading**: Use Suspense to load components on demand, reducing the initial load time of your application.
- **Complex UIs**: Use Suspense to manage loading states in complex UIs where multiple components may depend on different data sources.
- **User Experience**: Use Suspense to provide a smooth user experience by displaying loading indicators or placeholders while waiting for content to load.
- **Error Handling**: Use Suspense in conjunction with error boundaries to handle errors gracefully when fetching data or loading components.
- **Performance Optimization**: Use Suspense to optimize performance by reducing the number of unnecessary renders and improving the overall responsiveness of your application.
- **Code Splitting**: Use Suspense to split your code into smaller chunks, allowing for faster initial loading and better performance on subsequent navigations.
- **Progressive Loading**: Use Suspense to progressively load content as the user interacts with your application, enhancing perceived performance.
- **User Feedback**: Use Suspense to provide immediate feedback to users while waiting for data, improving the overall user experience.
- **Dynamic Imports**: Use Suspense to dynamically import components or modules, allowing for on-demand loading and reducing the initial bundle size.

#### Example Usage

```javascript
import React, { Suspense, lazy } from "react";
const LazyComponent = lazy(() => import("./LazyComponent"));
function App() {
  return (
    <div>
      <h1>My App</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
export default App;
```

<BackToTop />

## Props

- **fallback**: A React element that is displayed while the component is suspended. This can be a loading spinner, placeholder, or any other component that indicates loading state.
- **unstable_expectedLoadTime**: An optional prop that can be used to hint the expected loading time for the suspended component. This can help React optimize the rendering process and improve user experience.
- **children**: The child components that will be suspended until the promise resolves. These components will not render until the data they depend on is available.
- **maxDuration**: An optional prop that specifies the maximum time (in milliseconds) that the Suspense component should wait before rendering the fallback UI. If the promise takes longer than this duration, the fallback UI will be displayed.
- **onResolve**: An optional callback function that is called when the promise resolves. This can be used to perform additional actions or updates once the data is available.
- **onReject**: An optional callback function that is called when the promise is rejected. This can be used to handle errors or perform cleanup actions when the data fetching fails.
- **suspense**: A boolean prop that indicates whether the component should suspend rendering or not. If set to true, the component will suspend until the promise resolves. If set to false, the component will render immediately without waiting for the promise.

## Caveats

- **Server-Side Rendering (SSR)**: Suspense is primarily designed for client-side rendering. While it can be used with SSR, it may not behave as expected in all scenarios.
- **Error Handling**: Suspense does not handle errors by itself. You should use error boundaries to catch errors in suspended components and provide fallback UI.
- **Performance**: Overusing Suspense can lead to performance issues, especially if many components are suspended simultaneously. Use it judiciously to avoid unnecessary delays in rendering.
- **Compatibility**: Ensure that your React version supports Suspense, as it is a relatively new feature introduced in React 16.6. Some older versions may not support it fully or at all.
- **Nested Suspense**: Be cautious when nesting Suspense components, as it can lead to complex loading states and unexpected behavior. Ensure that the fallback UI is appropriate for each level of nesting and that it does not cause confusion for users.
- **State Management**: Suspense does not manage state by itself. You may need to use additional state management libraries or hooks to manage the state of suspended components effectively.
- **Testing**: Testing components that use Suspense can be challenging, as you need to account for the asynchronous nature of data fetching and rendering. Use testing libraries that support asynchronous testing, such as React Testing Library or Jest, to handle Suspense components properly.
- **Browser Compatibility**: Ensure that the browsers you are targeting support the features used in Suspense, as some older browsers may not fully support the latest React features. Always test your application in different browsers to ensure compatibility and a consistent user experience.
- **Loading Indicators**: When using Suspense, it's essential to provide clear loading indicators in the fallback UI. This helps users understand that content is being loaded and prevents confusion or frustration while waiting for data to be available.
  <BackToTop />

## Common Pitfalls

- **Not Providing Fallback UI**: Always provide a fallback UI when using Suspense. Failing to do so can lead to a blank screen or unresponsive UI while the component is suspended.
- **Overusing Suspense**: Using Suspense for every component can lead to performance issues. Use it selectively for components that require asynchronous data fetching or lazy loading.
- **Ignoring Error Boundaries**: Always wrap Suspense components in error boundaries to handle errors gracefully. This ensures that your application can recover from errors without crashing and provides a better user experience.
- **Assuming Immediate Resolution**: Do not assume that the promise will resolve immediately. Always handle the loading state appropriately and provide a fallback UI until the data is available.
- **Not Testing Suspense Components**: Ensure that you test components that use Suspense thoroughly. Use testing libraries that support asynchronous testing to verify that the loading states and fallback UI behave as expected.
- **Neglecting Accessibility**: When using Suspense, ensure that the fallback UI is accessible to all users. This includes providing appropriate ARIA attributes, ensuring keyboard navigation works, and using semantic HTML elements. Accessibility should always be a priority, even when dealing with loading states and asynchronous components.
- **Ignoring Performance**: Be mindful of the performance implications of using Suspense. Avoid suspending too many components simultaneously, as this can lead to delays in rendering and a poor user experience. Use tools like React Profiler to monitor performance and identify potential bottlenecks in your application.
- **Not Handling Edge Cases**: Consider edge cases where the data fetching may fail or take longer than expected. Implement proper error handling and timeouts to ensure that your application remains responsive and provides a good user experience even in adverse conditions.
- **Assuming Compatibility**: Ensure that your React version supports Suspense and that you are using the correct APIs. Some features may not be available in older versions of React, so always check the documentation and compatibility before implementing Suspense in your application.
- **Neglecting User Experience**: Always prioritize user experience when using Suspense. Ensure that the fallback UI is informative and provides clear feedback to users about the loading state. Avoid using generic loading indicators that do not convey meaningful information, as this can lead to confusion and frustration for users waiting for content to load.
- **Not Considering Network Conditions**: Be aware that network conditions can vary significantly for users. Implement strategies to handle slow or unreliable network connections, such as providing a way to retry failed requests or displaying informative messages when data cannot be fetched. This helps improve the user experience, especially in regions with poor connectivity.
- **Ignoring SEO Considerations**: If your application relies on server-side rendering (SSR) or static site generation (SSG), be cautious about how Suspense affects SEO. Search engines may not execute JavaScript, so ensure that critical content is available without relying solely on Suspense. Use techniques like pre-rendering or server-side rendering to ensure that important content is accessible to search engines and users without JavaScript execution.
- **Not Using Suspense with Concurrent Features**: If you are using React's concurrent features, such as concurrent mode or transitions, ensure that you understand how Suspense interacts with these features. Suspense can enhance the user experience by allowing components to load concurrently, but it requires careful management of loading states and fallbacks to ensure a smooth experience. Familiarize yourself with the best practices for using Suspense in conjunction with concurrent features to maximize performance and user experience.
  <BackToTop />

## Common Use Cases

- **Data Fetching**: Use Suspense to handle loading states for components that fetch data from APIs or other sources. This allows you to display a loading spinner or placeholder while waiting for the data to be available, improving the user experience by preventing the display of incomplete or incorrect UI.
- **Lazy Loading Components**: Use Suspense to load components on demand, reducing the initial load time of your application. This is particularly useful for large applications where not all components are needed immediately, allowing you to split your code into smaller chunks and load them as needed.
- **Complex UIs**: Use Suspense to manage loading states in complex UIs where multiple components may depend on different data sources. This helps ensure that the UI remains responsive and provides a smooth user experience by displaying loading indicators or placeholders while waiting for content to load.
- **User Feedback**: Use Suspense to provide immediate feedback to users while waiting for data. This can include displaying loading indicators, progress bars, or other visual cues that inform users that content is being loaded. This enhances the overall user experience by keeping users engaged and informed about the status of their actions.
- **Error Handling**: Use Suspense in conjunction with error boundaries to handle errors gracefully when fetching data or loading components. This allows you to catch errors in suspended components and provide fallback UI, ensuring that your application can recover from errors without crashing and providing a better user experience.
- **Performance Optimization**: Use Suspense to optimize performance by reducing the number of unnecessary renders and improving the overall responsiveness of your application. By managing loading states effectively, you can ensure that components only render when the required data is available, reducing the load on the browser and improving the perceived performance of your application.
- **Code Splitting**: Use Suspense to split your code into smaller chunks, allowing for faster initial loading and better performance on subsequent navigations. This is particularly useful for large applications where not all components are needed immediately, allowing you to load components on demand and reduce the initial bundle size.
- **Progressive Loading**: Use Suspense to progressively load content as the user interacts with your application. This enhances perceived performance by loading only the necessary components and data as needed, rather than loading everything upfront. This can lead to a more responsive and engaging user experience, especially in applications with large datasets or complex UIs.
- **Dynamic Imports**: Use Suspense to dynamically import components or modules, allowing for on-demand loading and reducing the initial bundle size. This is particularly useful for applications that have large or infrequently used components, as it allows you to load only the necessary code when needed, improving performance and reducing the initial load time.
- **User Experience Enhancements**: Use Suspense to enhance the overall user experience by providing clear loading indicators, placeholders, or other visual cues while waiting for content to load. This helps keep users engaged and informed about the status of their actions, reducing frustration and improving the perceived performance of your application.
- **Dynamic Content Loading**: Use Suspense to load dynamic content, such as user-generated data or real-time updates, without blocking the main thread. This allows your application to remain responsive while fetching and rendering new content, providing a seamless user experience even when dealing with large datasets or frequent updates.
- **Interactive Features**: Use Suspense to implement interactive features that require asynchronous data fetching, such as search suggestions, autocomplete inputs, or live data feeds. By suspending the rendering of these components until the data is available, you can ensure that users see accurate and up-to-date information without experiencing delays or incomplete UI.
- **Third-Party Integrations**: Use Suspense to handle loading states for third-party integrations, such as analytics, payment gateways, or social media widgets. This allows you to manage the loading of external resources effectively, ensuring that your application remains responsive while waiting for these integrations to load. By providing fallback UI or loading indicators, you can enhance the user experience and prevent confusion while waiting for external content to be available.
- **Real-Time Applications**: Use Suspense to manage loading states in real-time applications, such as chat applications or collaborative tools. By suspending the rendering of components until the necessary data is available, you can ensure that users see the most up-to-date information without experiencing delays or incomplete UI. This is particularly important in applications where real-time updates are critical for user engagement and collaboration.
- **Form Handling**: Use Suspense to manage loading states in forms that require asynchronous validation or data fetching. This allows you to provide immediate feedback to users while waiting for validation results or data to be fetched, enhancing the overall user experience. By suspending the rendering of form components until the necessary data is available, you can ensure that users see accurate and up-to-date information, reducing frustration and improving the perceived performance of your application.
- **Content Preloading**: Use Suspense to preload content that users are likely to access next, such as related articles, product recommendations, or next steps in a workflow. By suspending the rendering of these components until the data is available, you can ensure that users see relevant content immediately when they navigate to a new page or section. This can enhance the user experience by reducing load times and providing a seamless transition between different parts of your application.
- **A/B Testing**: Use Suspense to manage loading states in A/B testing scenarios, where different variations of a component or page are tested with different user groups. By suspending the rendering of the test variations until the necessary data is available, you can ensure that users see the correct version of the component without experiencing delays or incomplete UI. This allows you to gather accurate data on user interactions and preferences, helping you make informed decisions about which variation performs best.
- **Analytics Tracking**: Use Suspense to handle loading states for analytics tracking components that require asynchronous data fetching. This allows you to track user interactions and events without blocking the main thread, ensuring that your application remains responsive while collecting valuable data. By suspending the rendering of analytics components until the necessary data is available, you can ensure that users see accurate and up-to-date information, reducing the risk of missing important events or interactions.
- **Internationalization (i18n)**: Use Suspense to manage loading states for internationalization components that require asynchronous data fetching for translations or locale-specific content. This allows you to provide a seamless user experience by suspending the rendering of components until the necessary translations are available. By doing so, you can ensure that users see the correct language and content without experiencing delays or incomplete UI, enhancing the overall usability of your application for users in different regions and languages.
- **Feature Flags**: Use Suspense to manage loading states for feature flags that require asynchronous data fetching to determine which features should be enabled for a user. This allows you to dynamically enable or disable features based on user preferences or experimental conditions without blocking the main thread. By suspending the rendering of components until the feature flag data is available, you can ensure that users see the correct features and functionality without experiencing delays or incomplete UI, enhancing the overall user experience and allowing for more flexible feature management.
- **Content Management Systems (CMS)**: Use Suspense to handle loading states for components that fetch content from a CMS. This allows you to display dynamic content, such as blog posts, articles, or product listings, while managing loading states effectively. By suspending the rendering of these components until the content is available, you can ensure that users see complete and accurate information without experiencing delays or incomplete UI. This is particularly useful in applications where content is frequently updated or managed by non-technical users, as it allows for a more seamless and efficient content delivery process.
- **E-commerce Applications**: Use Suspense to manage loading states for product listings, reviews, and other e-commerce components that require asynchronous data fetching. This allows you to provide a smooth shopping experience by displaying loading indicators or placeholders while waiting for product data to be available. By suspending the rendering of these components until the data is ready, you can ensure that users see accurate and up-to-date product information, enhancing the overall user experience and reducing the risk of displaying incomplete or incorrect information.
- **Social Media Applications**: Use Suspense to handle loading states for social media components, such as user profiles, posts, and comments, that require asynchronous data fetching. This allows you to provide a seamless user experience by displaying loading indicators or placeholders while waiting for social media data to be available. By suspending the rendering of these components until the data is ready, you can ensure that users see complete and accurate information without experiencing delays or incomplete UI. This is particularly important in social media applications where real-time updates and user engagement are critical for maintaining user interest and interaction.
- **Real-Time Collaboration Tools**: Use Suspense to manage loading states in real-time collaboration tools, such as document editors or project management applications. This allows you to provide a smooth user experience by suspending the rendering of components until the necessary data is available, ensuring that users see the most up-to-date information without experiencing delays or incomplete UI.
- **Gaming Applications**: Use Suspense to handle loading states for game components that require asynchronous data fetching, such as player profiles, game stats, or leaderboard information. This allows you to provide a seamless gaming experience by suspending the rendering of these components until the data is available, ensuring that users see accurate and up-to-date information without experiencing delays or incomplete UI. By managing loading states effectively, you can enhance the overall user experience and keep players engaged with the game.
- **Educational Platforms**: Use Suspense to manage loading states for educational content, such as courses, quizzes, and interactive lessons, that require asynchronous data fetching. This allows you to provide a smooth learning experience by suspending the rendering of components until the necessary data is available, ensuring that users see complete and accurate information without experiencing delays or incomplete UI. By effectively managing loading states, you can enhance the overall user experience and keep learners engaged with the educational content.
- **Media Streaming Applications**: Use Suspense to handle loading states for media streaming components, such as video players, audio players, or image galleries, that require asynchronous data fetching. This allows you to provide a seamless media consumption experience by suspending the rendering of these components until the media data is available, ensuring that users see complete and accurate information without experiencing delays or incomplete UI. By managing loading states effectively, you can enhance the overall user experience and keep users engaged with the media content.

<BackToTop />
