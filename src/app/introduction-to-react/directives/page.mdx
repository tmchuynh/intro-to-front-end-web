import BackToTop from "@/components/BackToTop";

# Directives

## Table of Contents

[Overview](#overview)
["use client" Directive](#use-client-directive)
["use server" Directive](#use-server-directive) 4. [Server Actions](#server-actions) 5. [Advanced Patterns](#advanced-patterns) 6. [Best Practices](#best-practices)
[Troubleshooting](#troubleshooting)

## Overview

Directives in React are special string literals that provide instructions to React's bundler and runtime about how components and functions should be executed. Unlike traditional HTML directives or Angular directives, React directives are specifically designed for the React Server Components (RSC) architecture introduced in React 18 and popularized by Next.js 13+.

These directives are primarily used to define the \*\*execution boundarybetween server and client code in full-stack React applications. They help optimize performance by allowing developers to explicitly control where code runs - either on the server during build/request time or in the client browser.

**Key Characteristics:**

- Must be placed at the \*\*very topof the file (before any imports)
- Are string literals (not comments or function calls)
- Only affect the current module and its children
- Are build-time instructions, not runtime features
- Enable React's Server Components architecture

\*\*Important Note:These directives are specifically for React Server Components and are most commonly used with frameworks like Next.js 13+ that support this architecture. They are not applicable to traditional client-only React applications.

## `"use client"` Directive

The `"use client"` directive marks a file as a **Client Component**, indicating that the component and its children should run in the browser environment. This directive creates a boundary between Server Components (which run on the server) and Client Components (which run in the browser).

**Key Facts:**

- Only needed in Next.js 13+ with App Router or other RSC-enabled frameworks
- Must be the first line of the file (before imports)
- Makes the entire component tree below it run on the client
- Enables access to browser APIs, event handlers, and React hooks like `useState`, `useEffect`
- Creates a JavaScript bundle that gets sent to the browser

```javascript
"use client";

import React, { useState, useEffect } from "react";

function InteractiveCounter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default InteractiveCounter;
```

<BackToTop />

### Real-World Examples

#### Local Storage Manager

```javascript
"use client";

import React, { useState, useEffect } from "react";

function UserPreferences() {
  const [theme, setTheme] = useState("light");
  const [fontSize, setFontSize] = useState(16);
  const [preferences, setPreferences] = useState(null);

  // Load preferences from localStorage on mount
  useEffect(() => {
    const savedPreferences = localStorage.getItem("userPreferences");
    if (savedPreferences) {
      const parsed = JSON.parse(savedPreferences);
      setTheme(parsed.theme || "light");
      setFontSize(parsed.fontSize || 16);
      setPreferences(parsed);
    }
  }, []);

  // Save preferences whenever they change
  useEffect(() => {
    const newPreferences = { theme, fontSize };
    localStorage.setItem("userPreferences", JSON.stringify(newPreferences));
    setPreferences(newPreferences);
  }, [theme, fontSize]);

  const toggleTheme = () => {
    setTheme((current) => (current === "light" ? "dark" : "light"));
  };

  const adjustFontSize = (delta) => {
    setFontSize((current) => Math.max(12, Math.min(24, current + delta)));
  };

  return (
    <div
      className={`preferences-panel ${theme}`}
      style={{ fontSize: `${fontSize}px` }}
    >
      <h3>User Preferences</h3>

      <div className="preference-group">
        <label>Theme:</label>
        <button onClick={toggleTheme}>
          Current: {theme} (click to toggle)
        </button>
      </div>

      <div className="preference-group">
        <label>Font Size: {fontSize}px</label>
        <div>
          <button onClick={() => adjustFontSize(-2)}>A-</button>
          <button onClick={() => adjustFontSize(2)}>A+</button>
        </div>
      </div>

      {preferences && (
        <div className="preferences-display">
          <h4>Saved Preferences:</h4>
          <pre>{JSON.stringify(preferences, null, 2)}</pre>
        </div>
      )}
    </div>
  );
}

export default UserPreferences;
```

<BackToTop />

#### Geolocation Tracker

```javascript
"use client";

import React, { useState, useEffect } from "react";

function LocationTracker() {
  const [location, setLocation] = useState(null);
  const [error, setError] = useState(null);
  const [isTracking, setIsTracking] = useState(false);
  const [watchId, setWatchId] = useState(null);

  const startTracking = () => {
    if (!navigator.geolocation) {
      setError("Geolocation is not supported by this browser");
      return;
    }

    setIsTracking(true);
    setError(null);

    const options = {
      enableHighAccuracy: true,
      timeout: 5000,
      maximumAge: 0,
    };

    const success = (position) => {
      setLocation({
        latitude: position.coords.latitude,
        longitude: position.coords.longitude,
        accuracy: position.coords.accuracy,
        timestamp: new Date(position.timestamp).toLocaleString(),
      });
    };

    const errorCallback = (err) => {
      setError(`Error: ${err.message}`);
      setIsTracking(false);
    };

    // Watch position for continuous tracking
    const id = navigator.geolocation.watchPosition(
      success,
      errorCallback,
      options
    );
    setWatchId(id);
  };

  const stopTracking = () => {
    if (watchId) {
      navigator.geolocation.clearWatch(watchId);
      setWatchId(null);
    }
    setIsTracking(false);
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
      }
    };
  }, [watchId]);

  return (
    <div className="location-tracker">
      <h3>üìç Location Tracker</h3>

      <div className="controls">
        {!isTracking ? (
          <button onClick={startTracking} className="start-btn">
            Start Tracking
          </button>
        ) : (
          <button onClick={stopTracking} className="stop-btn">
            Stop Tracking
          </button>
        )}
      </div>

      {error && <div className="error-message">‚ö†Ô∏è {error}</div>}

      {location && (
        <div className="location-info">
          <h4>Current Location:</h4>
          <div className="location-details">
            <p>
              <strong>Latitude:</strong> {location.latitude.toFixed(6)}
            </p>
            <p>
              <strong>Longitude:</strong> {location.longitude.toFixed(6)}
            </p>
            <p>
              <strong>Accuracy:</strong> ¬±{Math.round(location.accuracy)}m
            </p>
            <p>
              <strong>Last Updated:</strong> {location.timestamp}
            </p>
          </div>

          <div className="map-link">
            <a
              href={`https://www.google.com/maps?q=${location.latitude},${location.longitude}`}
              target="_blank"
              rel="noopener noreferrer"
              className="map-button"
            >
              üìç View on Google Maps
            </a>
          </div>
        </div>
      )}

      {isTracking && (
        <div className="tracking-indicator">
          <span className="pulse">üî¥</span> Live tracking active
        </div>
      )}
    </div>
  );
}

export default LocationTracker;
```

<BackToTop />

#### Real-time Chat Interface

```javascript
"use client";

import React, { useState, useEffect, useRef } from "react";

function ChatInterface() {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [isConnected, setIsConnected] = useState(false);
  const [username, setUsername] = useState("");
  const messagesEndRef = useRef(null);
  const wsRef = useRef(null);

  // Auto-scroll to bottom when new messages arrive
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const connectToChat = () => {
    if (!username.trim()) {
      alert("Please enter a username");
      return;
    }

    // Simulate WebSocket connection (replace with actual WebSocket)
    const mockConnection = {
      send: (message) => {
        // Simulate receiving the message back
        setTimeout(() => {
          addMessage({
            id: Date.now(),
            username: username,
            text: message,
            timestamp: new Date().toLocaleTimeString(),
            isOwn: true,
          });

          // Simulate a bot response
          setTimeout(() => {
            addMessage({
              id: Date.now() + 1,
              username: "ChatBot",
              text: `Echo: ${message}`,
              timestamp: new Date().toLocaleTimeString(),
              isOwn: false,
            });
          }, 1000);
        }, 100);
      },
      close: () => {
        setIsConnected(false);
      },
    };

    wsRef.current = mockConnection;
    setIsConnected(true);

    addMessage({
      id: Date.now(),
      username: "System",
      text: `${username} joined the chat`,
      timestamp: new Date().toLocaleTimeString(),
      isSystem: true,
    });
  };

  const disconnectFromChat = () => {
    if (wsRef.current) {
      wsRef.current.close();
    }
    setIsConnected(false);
    addMessage({
      id: Date.now(),
      username: "System",
      text: `${username} left the chat`,
      timestamp: new Date().toLocaleTimeString(),
      isSystem: true,
    });
  };

  const addMessage = (message) => {
    setMessages((prev) => [...prev, message]);
  };

  const sendMessage = (e) => {
    e.preventDefault();
    if (!inputValue.trim() || !isConnected) return;

    wsRef.current?.send(inputValue.trim());
    setInputValue("");
  };

  const handleKeyPress = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendMessage(e);
    }
  };

  return (
    <div className="chat-interface">
      <div className="chat-header">
        <h3>üí¨ Live Chat</h3>
        <div className="connection-status">
          <span
            className={`status-indicator ${isConnected ? "connected" : "disconnected"}`}
          >
            {isConnected ? "üü¢ Connected" : "üî¥ Disconnected"}
          </span>
        </div>
      </div>

      {!isConnected ? (
        <div className="login-form">
          <div className="form-group">
            <label htmlFor="username">Enter your username:</label>
            <input
              id="username"
              type="text"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              placeholder="Your username..."
              onKeyPress={(e) => e.key === "Enter" && connectToChat()}
            />
          </div>
          <button onClick={connectToChat} className="connect-btn">
            Join Chat
          </button>
        </div>
      ) : (
        <>
          <div className="messages-container">
            {messages.map((message) => (
              <div
                key={message.id}
                className={`message ${message.isOwn ? "own" : ""} ${message.isSystem ? "system" : ""}`}
              >
                {!message.isSystem && (
                  <div className="message-header">
                    <span className="username">{message.username}</span>
                    <span className="timestamp">{message.timestamp}</span>
                  </div>
                )}
                <div className="message-text">{message.text}</div>
              </div>
            ))}
            <div ref={messagesEndRef} />
          </div>

          <form onSubmit={sendMessage} className="message-form">
            <div className="input-group">
              <input
                type="text"
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Type your message..."
                className="message-input"
              />
              <button type="submit" disabled={!inputValue.trim()}>
                Send
              </button>
            </div>
          </form>

          <button onClick={disconnectFromChat} className="disconnect-btn">
            Leave Chat
          </button>
        </>
      )}
    </div>
  );
}

export default ChatInterface;
```

<BackToTop />

### When to Use `"use client"`

The `"use client"` directive is essential when your component needs:

#### Browser APIs and Environment

- **DOM Manipulation**: Accessing `document`, `window`, or DOM elements directly
- **Storage APIs**: `localStorage`, `sessionStorage`, `IndexedDB`
- **Device APIs**: Geolocation, Camera, Microphone, Device Orientation
- **Performance APIs**: `requestAnimationFrame`, Intersection Observer
- **Network APIs**: `fetch` (when not using Server Actions), WebSockets, EventSource

#### Interactive Features

- **Event Handlers**: `onClick`, `onSubmit`, `onKeyDown`, etc.
- **Form Handling**: Real-time validation, controlled inputs
- **Animations**: CSS-in-JS animations, gesture handling
- **Drag and Drop**: File uploads, sortable lists
- **Real-time Features**: Live chat, notifications, live updates

#### Client-Side State Management

- **React Hooks**: `useState`, `useEffect`, `useReducer`, `useContext`
- **Third-party State Libraries**: Redux, Zustand, Jotai
- **Form Libraries**: React Hook Form, Formik
- **Animation Libraries**: Framer Motion, React Spring

#### Third-Party Integrations

- **Analytics**: Google Analytics, tracking pixels
- **Payment Processing**: Stripe Elements, PayPal
- **Maps**: Google Maps, Mapbox
- **Social Features**: Social media embeds, sharing buttons

### Advantages and Disadvantages of `"use client"`

| Aspect                  | Advantages                                                                                                                  | Disadvantages                                                                                                                  |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| \*\*Performance         | ‚Ä¢ Immediate interactivity after hydration<br/>‚Ä¢ Can cache client bundles<br/>‚Ä¢ Reduced server load for interactive features | ‚Ä¢ Larger JavaScript bundle size<br/>‚Ä¢ Requires hydration step<br/>‚Ä¢ Potential layout shift during hydration                    |
| \*\*SEO & Accessibility | ‚Ä¢ Can enhance user experience with progressive enhancement<br/>‚Ä¢ Maintains React's accessibility features                   | ‚Ä¢ Content not available during initial HTML parse<br/>‚Ä¢ May impact Core Web Vitals<br/>‚Ä¢ Requires JavaScript for functionality |
| \*\*Development         | ‚Ä¢ Full access to browser APIs<br/>‚Ä¢ Rich ecosystem of client-side libraries<br/>‚Ä¢ Real-time debugging in browser            | ‚Ä¢ More complex state management<br/>‚Ä¢ Bundle size considerations<br/>‚Ä¢ Potential hydration mismatches                          |
| \*\*Security            | ‚Ä¢ Client-side validation for UX<br/>‚Ä¢ Can implement client-side encryption                                                  | ‚Ä¢ All code visible to users<br/>‚Ä¢ Cannot store sensitive data<br/>‚Ä¢ Vulnerable to XSS attacks                                  |

<BackToTop />

### Implementation Best Practices

#### Minimize Client Components

```javascript
// ‚ùå Entire component marked as client
"use client";
import ServerData from "./ServerData";
import InteractiveButton from "./InteractiveButton";

function MyPage() {
  return (
    <div>
      <ServerData /> {/* This doesn't need to be client */}
      <InteractiveButton />
    </div>
  );
}

// ‚úÖ Only interactive parts are client components
// MyPage.jsx (Server Component)
import ServerData from "./ServerData";
import InteractiveButton from "./InteractiveButton";

function MyPage() {
  return (
    <div>
      <ServerData /> {/* Server Component */}
      <InteractiveButton /> {/* Client Component */}
    </div>
  );
}

// InteractiveButton.jsx
("use client");
import { useState } from "react";

function InteractiveButton() {
  const [clicked, setClicked] = useState(false);
  return (
    <button onClick={() => setClicked(!clicked)}>
      {clicked ? "Clicked!" : "Click me"}
    </button>
  );
}
```

#### Prop Serialization Awareness

```javascript
// ‚ùå Cannot pass non-serializable props to client components
function ServerComponent() {
  const handleClick = () => console.log("clicked"); // Function
  const date = new Date(); // Date object

  return (
    <ClientComponent
      onClick={handleClick} // ‚ùå Functions cannot be serialized
      date={date} // ‚ùå Dates need to be serialized
    />
  );
}

// ‚úÖ Pass serializable data and define handlers in client
function ServerComponent() {
  const timestamp = new Date().toISOString(); // String

  return (
    <ClientComponent
      timestamp={timestamp} // ‚úÖ Serializable
    />
  );
}

// ClientComponent.jsx
("use client");
function ClientComponent({ timestamp }) {
  const handleClick = () => console.log("clicked"); // Define locally
  const date = new Date(timestamp); // Parse on client

  return <button onClick={handleClick}>{date.toLocaleDateString()}</button>;
}
```

<BackToTop />

### Common Patterns and Solutions

#### Hydration-Safe Components

```javascript
"use client";
import { useState, useEffect } from "react";

function HydrationSafeComponent() {
  const [mounted, setMounted] = useState(false);
  const [data, setData] = useState(null);

  // Ensure component is mounted before accessing browser APIs
  useEffect(() => {
    setMounted(true);
    // Safe to access localStorage now
    const saved = localStorage.getItem("data");
    if (saved) {
      setData(JSON.parse(saved));
    }
  }, []);

  // Prevent hydration mismatch
  if (!mounted) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <p>Client-side data: {data?.value || "No data"}</p>
    </div>
  );
}
```

<BackToTop />

#### Progressive Enhancement Pattern

```javascript
"use client";
import { useState, useEffect } from "react";

function ProgressiveForm({ initialData }) {
  const [isEnhanced, setIsEnhanced] = useState(false);
  const [formData, setFormData] = useState(initialData);

  useEffect(() => {
    // Enable enhanced features after hydration
    setIsEnhanced(true);
  }, []);

  const handleSubmit = (e) => {
    if (!isEnhanced) {
      // Let form submit normally for non-JS users
      return;
    }

    e.preventDefault();
    // Enhanced submission with validation, optimistic updates, etc.
    submitWithEnhancements(formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={formData.name}
        onChange={
          isEnhanced
            ? (e) => setFormData({ ...formData, name: e.target.value })
            : undefined
        }
      />
      {isEnhanced && (
        <div className="enhanced-features">
          <div className="live-validation">
            {/* Real-time validation feedback */}
          </div>
          <div className="character-count">{formData.name.length}/50</div>
        </div>
      )}
      <button type="submit">
        {isEnhanced ? "Submit (Enhanced)" : "Submit"}
      </button>
    </form>
  );
}
```

<BackToTop />

## `"use server"` Directive

The `"use server"` directive marks functions as \*\*Server Actions- functions that run exclusively on the server and can be called from both Server and Client Components. This directive is used to create secure server-side functions that can handle form submissions, database operations, and other server-side logic.

\*\*Important Note:`"use server"` is NOT used to mark entire components as server components. By default, all components in the App Router are Server Components unless marked with `"use client"`.

**Key Facts:**

- Only applies to individual functions, not entire files/components
- Functions run on the server with access to server-side resources
- Can be called from both server and client components
- Automatically handles serialization of arguments and return values
- Provides built-in security and CSRF protection

### Basic Server Action Example

```javascript
// app/actions.js
"use server";

import { db } from "@/lib/database";
import { revalidatePath } from "next/cache";

export async function createUser(formData) {
  // This function runs on the server
  const name = formData.get("name");
  const email = formData.get("email");

  // Validate input
  if (!name || !email) {
    throw new Error("Name and email are required");
  }

  // Database operation (server-side only)
  const user = await db.user.create({
    data: { name, email },
  });

  // Revalidate cache
  revalidatePath("/users");

  return { success: true, user };
}

export async function deleteUser(userId) {
  "use server";

  await db.user.delete({
    where: { id: userId },
  });

  revalidatePath("/users");
}
```

<BackToTop />

### Real-World Server Action Examples

#### Advanced Form Handling with Validation

```javascript
// app/actions/contact.js
"use server";

import { z } from "zod";
import { sendEmail } from "@/lib/email";
import { rateLimiter } from "@/lib/rate-limit";

const contactSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  subject: z.string().min(5, "Subject must be at least 5 characters"),
  message: z.string().min(10, "Message must be at least 10 characters"),
  company: z.string().optional(),
});

export async function submitContactForm(prevState, formData) {
  try {
    // Rate limiting
    const identifier = formData.get("email");
    const isAllowed = await rateLimiter.check(identifier);

    if (!isAllowed) {
      return {
        success: false,
        error: "Too many requests. Please try again later.",
        fields: {},
      };
    }

    // Validate form data
    const validatedData = contactSchema.parse({
      name: formData.get("name"),
      email: formData.get("email"),
      subject: formData.get("subject"),
      message: formData.get("message"),
      company: formData.get("company"),
    });

    // Process the contact form
    await sendEmail({
      to: "contact@company.com",
      from: validatedData.email,
      subject: `Contact Form: ${validatedData.subject}`,
      html: `
        <h2>New Contact Form Submission</h2>
        <p><strong>Name:</strong> ${validatedData.name}</p>
        <p><strong>Email:</strong> ${validatedData.email}</p>
        ${validatedData.company ? `<p><strong>Company:</strong> ${validatedData.company}</p>` : ""}
        <p><strong>Subject:</strong> ${validatedData.subject}</p>
        <p><strong>Message:</strong></p>
        <p>${validatedData.message.replace(/\n/g, "<br>")}</p>
      `,
    });

    // Log to database for tracking
    await db.contactSubmission.create({
      data: {
        ...validatedData,
        submittedAt: new Date(),
        ipAddress: headers().get("x-forwarded-for") || "unknown",
      },
    });

    return {
      success: true,
      message: "Thank you for your message! We'll get back to you soon.",
      fields: {},
    };
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Validation errors
      return {
        success: false,
        error: "Please check the form for errors.",
        fields: error.flatten().fieldErrors,
      };
    }

    // Unexpected errors
    console.error("Contact form error:", error);
    return {
      success: false,
      error: "An unexpected error occurred. Please try again.",
      fields: {},
    };
  }
}
```

<BackToTop />

#### File Upload Server Action

```javascript
// app/actions/upload.js
"use server";

import { put } from "@vercel/blob";
import { auth } from "@/lib/auth";
import { db } from "@/lib/database";
import { revalidatePath } from "next/cache";

export async function uploadFile(formData) {
  try {
    // Authentication check
    const session = await auth();
    if (!session?.user) {
      throw new Error("Unauthorized");
    }

    const file = formData.get("file");

    if (!file || file.size === 0) {
      throw new Error("No file provided");
    }

    // Validate file type and size
    const allowedTypes = [
      "image/jpeg",
      "image/png",
      "image/webp",
      "application/pdf",
    ];
    if (!allowedTypes.includes(file.type)) {
      throw new Error(
        "Invalid file type. Only JPEG, PNG, WebP, and PDF files are allowed."
      );
    }

    const maxSize = 10 * 1024 * 1024; // 10MB
    if (file.size > maxSize) {
      throw new Error("File too large. Maximum size is 10MB.");
    }

    // Generate unique filename
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(7);
    const extension = file.name.split(".").pop();
    const filename = `${timestamp}-${randomString}.${extension}`;

    // Upload to blob storage
    const blob = await put(filename, file, {
      access: "public",
      addRandomSuffix: false,
    });

    // Save file metadata to database
    const fileRecord = await db.file.create({
      data: {
        originalName: file.name,
        filename: filename,
        url: blob.url,
        size: file.size,
        mimeType: file.type,
        userId: session.user.id,
        uploadedAt: new Date(),
      },
    });

    // Revalidate relevant pages
    revalidatePath("/dashboard/files");
    revalidatePath("/profile");

    return {
      success: true,
      file: {
        id: fileRecord.id,
        url: blob.url,
        name: file.name,
        size: file.size,
      },
    };
  } catch (error) {
    console.error("File upload error:", error);
    return {
      success: false,
      error: error.message || "Failed to upload file",
    };
  }
}

export async function deleteFile(fileId) {
  "use server";

  try {
    const session = await auth();
    if (!session?.user) {
      throw new Error("Unauthorized");
    }

    // Verify file ownership
    const file = await db.file.findFirst({
      where: {
        id: fileId,
        userId: session.user.id,
      },
    });

    if (!file) {
      throw new Error("File not found or unauthorized");
    }

    // Delete from blob storage
    await del(file.url);

    // Delete from database
    await db.file.delete({
      where: { id: fileId },
    });

    revalidatePath("/dashboard/files");

    return { success: true };
  } catch (error) {
    console.error("File deletion error:", error);
    return {
      success: false,
      error: error.message || "Failed to delete file",
    };
  }
}
```

<BackToTop />

#### Database Operations with Optimistic Updates

```javascript
// app/actions/todos.js
"use server";

import { auth } from "@/lib/auth";
import { db } from "@/lib/database";
import { revalidateTag } from "next/cache";

export async function createTodo(title) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Must be logged in");
  }

  const todo = await db.todo.create({
    data: {
      title: title.trim(),
      completed: false,
      userId: session.user.id,
      createdAt: new Date(),
    },
  });

  revalidateTag("todos");
  return todo;
}

export async function toggleTodo(todoId) {
  "use server";

  const session = await auth();
  if (!session?.user) {
    throw new Error("Must be logged in");
  }

  // Find the todo
  const todo = await db.todo.findFirst({
    where: {
      id: todoId,
      userId: session.user.id,
    },
  });

  if (!todo) {
    throw new Error("Todo not found");
  }

  // Toggle completion status
  const updatedTodo = await db.todo.update({
    where: { id: todoId },
    data: {
      completed: !todo.completed,
      completedAt: !todo.completed ? new Date() : null,
    },
  });

  revalidateTag("todos");
  return updatedTodo;
}

export async function updateTodoTitle(todoId, newTitle) {
  "use server";

  const session = await auth();
  if (!session?.user) {
    throw new Error("Must be logged in");
  }

  if (!newTitle.trim()) {
    throw new Error("Title cannot be empty");
  }

  const updatedTodo = await db.todo.update({
    where: {
      id: todoId,
      userId: session.user.id, // Ensure ownership
    },
    data: {
      title: newTitle.trim(),
      updatedAt: new Date(),
    },
  });

  revalidateTag("todos");
  return updatedTodo;
}

export async function deleteTodo(todoId) {
  "use server";

  const session = await auth();
  if (!session?.user) {
    throw new Error("Must be logged in");
  }

  await db.todo.delete({
    where: {
      id: todoId,
      userId: session.user.id,
    },
  });

  revalidateTag("todos");
  return { deleted: true };
}

export async function reorderTodos(todoIds) {
  "use server";

  const session = await auth();
  if (!session?.user) {
    throw new Error("Must be logged in");
  }

  // Update order for each todo
  const updatePromises = todoIds.map((todoId, index) =>
    db.todo.update({
      where: {
        id: todoId,
        userId: session.user.id,
      },
      data: { order: index },
    })
  );

  await Promise.all(updatePromises);
  revalidateTag("todos");

  return { reordered: true };
}
```

<BackToTop />

### Using Server Actions in Components

#### With Client Components

```javascript
// components/ContactForm.jsx
"use client";

import { useFormState } from "react-dom";
import { submitContactForm } from "@/app/actions/contact";

const initialState = {
  success: false,
  error: "",
  fields: {},
};

export function ContactForm() {
  const [state, formAction] = useFormState(submitContactForm, initialState);

  return (
    <form action={formAction} className="contact-form">
      {state.success && <div className="success-message">{state.message}</div>}

      {state.error && <div className="error-message">{state.error}</div>}

      <div className="form-group">
        <label htmlFor="name">Name *</label>
        <input type="text" id="name" name="name" required />
        {state.fields?.name && (
          <span className="field-error">{state.fields.name[0]}</span>
        )}
      </div>

      <div className="form-group">
        <label htmlFor="email">Email *</label>
        <input type="email" id="email" name="email" required />
        {state.fields?.email && (
          <span className="field-error">{state.fields.email[0]}</span>
        )}
      </div>

      <div className="form-group">
        <label htmlFor="subject">Subject *</label>
        <input type="text" id="subject" name="subject" required />
        {state.fields?.subject && (
          <span className="field-error">{state.fields.subject[0]}</span>
        )}
      </div>

      <div className="form-group">
        <label htmlFor="message">Message *</label>
        <textarea id="message" name="message" rows="5" required />
        {state.fields?.message && (
          <span className="field-error">{state.fields.message[0]}</span>
        )}
      </div>

      <button type="submit" disabled={state.pending} className="submit-button">
        {state.pending ? "Sending..." : "Send Message"}
      </button>
    </form>
  );
}
```

<BackToTop />

#### With Server Components

```javascript
// app/todos/page.jsx (Server Component)
import { auth } from "@/lib/auth";
import { db } from "@/lib/database";
import { createTodo, toggleTodo, deleteTodo } from "@/app/actions/todos";

async function getTodos(userId) {
  return await db.todo.findMany({
    where: { userId },
    orderBy: { createdAt: "desc" },
  });
}

export default async function TodosPage() {
  const session = await auth();
  const todos = await getTodos(session.user.id);

  return (
    <div className="todos-page">
      <h1>My Todos</h1>

      <form action={createTodo} className="create-todo-form">
        <input
          type="text"
          name="title"
          placeholder="What needs to be done?"
          required
        />
        <button type="submit">Add Todo</button>
      </form>

      <div className="todos-list">
        {todos.map((todo) => (
          <div key={todo.id} className="todo-item">
            <form action={toggleTodo} style={{ display: "inline" }}>
              <input type="hidden" name="todoId" value={todo.id} />
              <button
                type="submit"
                className={`toggle-btn ${todo.completed ? "completed" : ""}`}
              >
                {todo.completed ? "‚úì" : "‚óã"}
              </button>
            </form>

            <span className={todo.completed ? "completed" : ""}>
              {todo.title}
            </span>

            <form action={deleteTodo} style={{ display: "inline" }}>
              <input type="hidden" name="todoId" value={todo.id} />
              <button type="submit" className="delete-btn">
                ‚úï
              </button>
            </form>
          </div>
        ))}
      </div>
    </div>
  );
}
```

<BackToTop />

### When to Use `"use server"`

Server Actions with the `"use server"` directive are ideal for:

#### Form Processing and Data Mutations

- **Form Submissions**: Contact forms, user registration, profile updates
- **CRUD Operations**: Creating, updating, deleting database records
- **File Uploads**: Processing and storing uploaded files
- **Bulk Operations**: Mass updates, data imports, batch processing

#### Server-Side Security Operations

- **Authentication**: Login, logout, password resets
- **Authorization**: Role-based access control, permission checks
- **Data Validation**: Server-side validation that can't be bypassed
- **Rate Limiting**: Preventing abuse and spam

#### External Service Integration

- **Email Sending**: Transactional emails, notifications
- **Payment Processing**: Stripe, PayPal integrations
- **Third-party APIs**: Weather data, geolocation, social media
- **Webhook Handling**: Processing incoming webhooks

#### Data Processing

- **Image Processing**: Resizing, compression, format conversion
- **File Processing**: PDF generation, CSV parsing
- **Analytics**: Logging events, tracking user behavior
- **Background Jobs**: Queuing tasks for later processing

### Advantages and Disadvantages of `"use server"`

| Aspect          | Advantages                                                                                                                                              | Disadvantages                                                                                                   |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| \*\*Security    | ‚Ä¢ Code runs on server (not visible to users)<br/>‚Ä¢ Direct database access<br/>‚Ä¢ Environment variables and secrets access<br/>‚Ä¢ Built-in CSRF protection | ‚Ä¢ Cannot access browser APIs<br/>‚Ä¢ No real-time client interaction<br/>‚Ä¢ Requires server round-trip             |
| \*\*Performance | ‚Ä¢ Reduces client bundle size<br/>‚Ä¢ Leverages server resources<br/>‚Ä¢ Can cache results server-side<br/>‚Ä¢ No hydration required                           | ‚Ä¢ Network latency for each call<br/>‚Ä¢ Server resource usage<br/>‚Ä¢ Cannot run offline                            |
| \*\*Development | ‚Ä¢ Simple form handling<br/>‚Ä¢ Progressive enhancement<br/>‚Ä¢ Type safety with TypeScript<br/>‚Ä¢ Automatic serialization                                    | ‚Ä¢ Debugging requires server logs<br/>‚Ä¢ Limited to serializable data<br/>‚Ä¢ Cannot use browser-specific libraries |

<BackToTop />

### Server Action Best Practices

#### Input Validation and Sanitization

```javascript
"use server";

import { z } from "zod";

const userSchema = z.object({
  email: z.string().email().toLowerCase(),
  name: z.string().min(2).max(50).trim(),
  age: z.number().min(13).max(120),
});

export async function createUser(formData) {
  try {
    // Always validate input on the server
    const validatedData = userSchema.parse({
      email: formData.get("email"),
      name: formData.get("name"),
      age: parseInt(formData.get("age")),
    });

    // Proceed with validated data
    const user = await db.user.create({
      data: validatedData,
    });

    return { success: true, user };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        errors: error.flatten().fieldErrors,
      };
    }

    return {
      success: false,
      error: "Failed to create user",
    };
  }
}
```

<BackToTop />

#### Error Handling and User Feedback

```javascript
"use server";

export async function updateUserProfile(userId, formData) {
  try {
    // Check authentication
    const session = await auth();
    if (!session || session.user.id !== userId) {
      return {
        success: false,
        error: "Unauthorized",
      };
    }

    // Validate and update
    const updatedUser = await db.user.update({
      where: { id: userId },
      data: {
        name: formData.get("name"),
        bio: formData.get("bio"),
      },
    });

    revalidatePath("/profile");

    return {
      success: true,
      message: "Profile updated successfully",
      user: updatedUser,
    };
  } catch (error) {
    console.error("Profile update error:", error);

    // Return user-friendly error messages
    if (error.code === "P2002") {
      return {
        success: false,
        error: "Email already exists",
      };
    }

    return {
      success: false,
      error: "Failed to update profile",
    };
  }
}
```

<BackToTop />

#### Performance Optimization

```javascript
"use server";

import { unstable_cache } from "next/cache";

// Cache expensive operations
const getCachedStats = unstable_cache(
  async (userId) => {
    const stats = await db.userStats.aggregate({
      where: { userId },
      _sum: { points: true },
      _count: { activities: true },
    });
    return stats;
  },
  ["user-stats"],
  { revalidate: 3600 } // Cache for 1 hour
);

export async function getUserDashboard(userId) {
  const [user, stats, recentActivity] = await Promise.all([
    db.user.findUnique({ where: { id: userId } }),
    getCachedStats(userId),
    db.activity.findMany({
      where: { userId },
      orderBy: { createdAt: "desc" },
      take: 10,
    }),
  ]);

  return { user, stats, recentActivity };
}
```

<BackToTop />

#### Progressive Enhancement

```javascript
// Server Component with Server Action
export default function NewsletterSignup() {
  async function subscribe(formData) {
    "use server";

    const email = formData.get("email");

    // Add to newsletter
    await addToNewsletter(email);

    // Redirect with success message
    redirect("/newsletter/success");
  }

  return (
    <form action={subscribe}>
      <input
        type="email"
        name="email"
        placeholder="Enter your email"
        required
      />
      <button type="submit">Subscribe</button>
    </form>
  );
}
```

<BackToTop />

### Security Considerations

#### Authentication and Authorization

```javascript
"use server";

import { auth } from "@/lib/auth";

export async function deletePost(postId) {
  // Always check authentication
  const session = await auth();
  if (!session?.user) {
    throw new Error("Not authenticated");
  }

  // Check ownership or permissions
  const post = await db.post.findUnique({
    where: { id: postId },
    select: { authorId: true },
  });

  if (post.authorId !== session.user.id && !session.user.isAdmin) {
    throw new Error("Not authorized");
  }

  await db.post.delete({ where: { id: postId } });
}
```

<BackToTop />

#### Input Sanitization

```javascript
"use server";

import DOMPurify from "isomorphic-dompurify";

export async function createBlogPost(formData) {
  const title = formData.get("title");
  const content = formData.get("content");

  // Sanitize HTML content
  const sanitizedContent = DOMPurify.sanitize(content, {
    ALLOWED_TAGS: ["p", "br", "strong", "em", "ul", "ol", "li"],
    ALLOWED_ATTR: [],
  });

  await db.post.create({
    data: {
      title: title.trim(),
      content: sanitizedContent,
      authorId: session.user.id,
    },
  });
}
```

<BackToTop />

#### Rate Limiting

```javascript
"use server";

import { ratelimit } from "@/lib/rate-limit";

export async function sendContactMessage(formData) {
  const email = formData.get("email");

  // Rate limit by email
  const { success } = await ratelimit.limit(email);

  if (!success) {
    return {
      success: false,
      error: "Too many requests. Please try again later.",
    };
  }

  // Process the message
  await processContactMessage(formData);

  return { success: true };
}
```

<BackToTop />

## Server Actions

Server Actions are asynchronous functions that run on the server and can be called from both Client and Server Components. They are the primary way to handle data mutations in React Server Components applications.

### Server Action Fundamentals

#### Inline Server Actions

```javascript
// In a Server Component
export default function CreateUserForm() {
  async function createUser(formData) {
    "use server";

    const name = formData.get("name");
    const email = formData.get("email");

    await db.user.create({
      data: { name, email },
    });

    redirect("/users");
  }

  return (
    <form action={createUser}>
      <input name="name" placeholder="Name" required />
      <input name="email" type="email" placeholder="Email" required />
      <button type="submit">Create User</button>
    </form>
  );
}
```

<BackToTop />

#### Module-Level Server Actions

```javascript
// actions/user-actions.js
"use server";

import { db } from "@/lib/database";
import { auth } from "@/lib/auth";
import { revalidatePath } from "next/cache";

export async function createUser(formData) {
  const session = await auth();
  if (!session) throw new Error("Unauthorized");

  const user = await db.user.create({
    data: {
      name: formData.get("name"),
      email: formData.get("email"),
    },
  });

  revalidatePath("/users");
  return user;
}

export async function updateUser(id, formData) {
  const session = await auth();
  if (!session) throw new Error("Unauthorized");

  const user = await db.user.update({
    where: { id },
    data: {
      name: formData.get("name"),
      email: formData.get("email"),
    },
  });

  revalidatePath("/users");
  revalidatePath(`/users/${id}`);
  return user;
}
```

<BackToTop />

### Advanced Server Action Patterns

#### Multi-Step Forms with Server Actions

```javascript
"use server";

import { z } from "zod";

const stepSchemas = {
  1: z.object({
    firstName: z.string().min(2),
    lastName: z.string().min(2),
    email: z.string().email(),
  }),
  2: z.object({
    company: z.string().min(2),
    jobTitle: z.string().min(2),
    industry: z.string().min(2),
  }),
  3: z.object({
    interests: z.array(z.string()).min(1),
    newsletter: z.boolean(),
  }),
};

export async function submitRegistrationStep(
  step,
  formData,
  existingData = {}
) {
  try {
    // Validate current step
    const schema = stepSchemas[step];
    const stepData = {};

    for (const [key] of Object.entries(schema.shape)) {
      stepData[key] = formData.get(key);
    }

    const validatedStepData = schema.parse(stepData);

    // Combine with existing data
    const combinedData = { ...existingData, ...validatedStepData };

    if (step === 3) {
      // Final step - save to database
      const user = await db.user.create({
        data: combinedData,
      });

      // Send welcome email
      await sendWelcomeEmail(user.email);

      return {
        success: true,
        isComplete: true,
        user,
      };
    } else {
      // Return data for next step
      return {
        success: true,
        isComplete: false,
        data: combinedData,
      };
    }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        errors: error.flatten().fieldErrors,
      };
    }
    throw error;
  }
}
```

<BackToTop />

#### Optimistic Updates with Server Actions

```javascript
// components/OptimisticTodoList.jsx
"use client";

import { useOptimistic } from "react";
import { addTodo, toggleTodo, deleteTodo } from "@/actions/todos";

export function OptimisticTodoList({ initialTodos }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    initialTodos,
    (state, newTodo) => {
      switch (newTodo.action) {
        case "add":
          return [...state, newTodo.todo];
        case "toggle":
          return state.map((todo) =>
            todo.id === newTodo.id
              ? { ...todo, completed: !todo.completed }
              : todo
          );
        case "delete":
          return state.filter((todo) => todo.id !== newTodo.id);
        default:
          return state;
      }
    }
  );

  async function handleAddTodo(formData) {
    const title = formData.get("title");
    const optimisticTodo = {
      id: Date.now(), // Temporary ID
      title,
      completed: false,
      createdAt: new Date(),
    };

    // Add optimistically
    addOptimisticTodo({ action: "add", todo: optimisticTodo });

    // Submit to server
    try {
      await addTodo(title);
    } catch (error) {
      // Handle error - optimistic update will be reverted
      console.error("Failed to add todo:", error);
    }
  }

  async function handleToggleTodo(todoId) {
    // Update optimistically
    addOptimisticTodo({ action: "toggle", id: todoId });

    try {
      await toggleTodo(todoId);
    } catch (error) {
      console.error("Failed to toggle todo:", error);
    }
  }

  async function handleDeleteTodo(todoId) {
    // Delete optimistically
    addOptimisticTodo({ action: "delete", id: todoId });

    try {
      await deleteTodo(todoId);
    } catch (error) {
      console.error("Failed to delete todo:", error);
    }
  }

  return (
    <div className="todo-list">
      <form action={handleAddTodo} className="add-todo-form">
        <input name="title" placeholder="Add new todo..." required />
        <button type="submit">Add</button>
      </form>

      <div className="todos">
        {optimisticTodos.map((todo) => (
          <div key={todo.id} className="todo-item">
            <button
              onClick={() => handleToggleTodo(todo.id)}
              className={`toggle ${todo.completed ? "completed" : ""}`}
            >
              {todo.completed ? "‚úì" : "‚óã"}
            </button>

            <span className={todo.completed ? "completed" : ""}>
              {todo.title}
            </span>

            <button
              onClick={() => handleDeleteTodo(todo.id)}
              className="delete-btn"
            >
              ‚úï
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

<BackToTop />

#### File Upload with Progress

```javascript
// actions/file-upload.js
"use server";

import { put } from "@vercel/blob";
import { auth } from "@/lib/auth";

export async function uploadFileWithProgress(formData) {
  const session = await auth();
  if (!session) throw new Error("Unauthorized");

  const file = formData.get("file");
  if (!file) throw new Error("No file provided");

  // Validate file
  const maxSize = 10 * 1024 * 1024; // 10MB
  if (file.size > maxSize) {
    throw new Error("File too large");
  }

  try {
    // Upload to blob storage
    const blob = await put(file.name, file, {
      access: "public",
      handleUploadUrl: "/api/upload-progress", // Custom progress handler
    });

    // Save metadata
    const fileRecord = await db.file.create({
      data: {
        name: file.name,
        url: blob.url,
        size: file.size,
        userId: session.user.id,
      },
    });

    return {
      success: true,
      file: fileRecord,
    };
  } catch (error) {
    console.error("Upload failed:", error);
    return {
      success: false,
      error: error.message,
    };
  }
}
```

```javascript
// components/FileUploadWithProgress.jsx
"use client";

import { useState } from "react";
import { uploadFileWithProgress } from "@/actions/file-upload";

export function FileUploadWithProgress() {
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [result, setResult] = useState(null);

  async function handleUpload(formData) {
    setUploading(true);
    setProgress(0);
    setResult(null);

    try {
      // Simulate progress for demo
      const progressInterval = setInterval(() => {
        setProgress((prev) => Math.min(prev + 10, 90));
      }, 200);

      const result = await uploadFileWithProgress(formData);

      clearInterval(progressInterval);
      setProgress(100);
      setResult(result);
    } catch (error) {
      setResult({ success: false, error: error.message });
    } finally {
      setUploading(false);
    }
  }

  return (
    <div className="file-upload">
      <form action={handleUpload}>
        <input
          type="file"
          name="file"
          accept="image/*,.pdf"
          required
          disabled={uploading}
        />

        <button type="submit" disabled={uploading}>
          {uploading ? `Uploading... ${progress}%` : "Upload File"}
        </button>
      </form>

      {uploading && (
        <div className="progress-bar">
          <div className="progress-fill" style={{ width: `${progress}%` }} />
        </div>
      )}

      {result && (
        <div className={`result ${result.success ? "success" : "error"}`}>
          {result.success ? (
            <div>
              <p>File uploaded successfully!</p>
              <a
                href={result.file.url}
                target="_blank"
                rel="noopener noreferrer"
              >
                View File
              </a>
            </div>
          ) : (
            <p>Error: {result.error}</p>
          )}
        </div>
      )}
    </div>
  );
}
```

<BackToTop />

## Advanced Patterns

### Hybrid Components (Server + Client)

Sometimes you need components that have both server-side data fetching and client-side interactivity:

```javascript
// app/dashboard/page.jsx (Server Component)
import { auth } from "@/lib/auth";
import { getUserStats } from "@/lib/queries";
import { InteractiveDashboard } from "./InteractiveDashboard";

export default async function DashboardPage() {
  const session = await auth();
  const stats = await getUserStats(session.user.id);

  return (
    <div className="dashboard">
      <h1>Dashboard</h1>
      <InteractiveDashboard initialStats={stats} userId={session.user.id} />
    </div>
  );
}
```

```javascript
// app/dashboard/InteractiveDashboard.jsx (Client Component)
"use client";

import { useState, useEffect } from "react";
import { updateUserPreferences } from "@/actions/user";

export function InteractiveDashboard({ initialStats, userId }) {
  const [stats, setStats] = useState(initialStats);
  const [preferences, setPreferences] = useState({
    theme: "light",
    notifications: true,
  });

  // Real-time updates
  useEffect(() => {
    const eventSource = new EventSource(`/api/stats-stream?userId=${userId}`);

    eventSource.onmessage = (event) => {
      const newStats = JSON.parse(event.data);
      setStats(newStats);
    };

    return () => eventSource.close();
  }, [userId]);

  async function handlePreferenceChange(key, value) {
    setPreferences((prev) => ({ ...prev, [key]: value }));

    // Save to server
    await updateUserPreferences(userId, { [key]: value });
  }

  return (
    <div className={`dashboard-content theme-${preferences.theme}`}>
      <div className="stats-grid">
        <div className="stat-card">
          <h3>Total Views</h3>
          <p>{stats.totalViews}</p>
        </div>
        <div className="stat-card">
          <h3>Active Projects</h3>
          <p>{stats.activeProjects}</p>
        </div>
      </div>

      <div className="preferences">
        <h3>Preferences</h3>
        <label>
          <input
            type="checkbox"
            checked={preferences.notifications}
            onChange={(e) =>
              handlePreferenceChange("notifications", e.target.checked)
            }
          />
          Enable Notifications
        </label>

        <select
          value={preferences.theme}
          onChange={(e) => handlePreferenceChange("theme", e.target.value)}
        >
          <option value="light">Light Theme</option>
          <option value="dark">Dark Theme</option>
        </select>
      </div>
    </div>
  );
}
```

<BackToTop />

### Data Streaming with Server Actions

```javascript
// actions/data-stream.js
"use server";

export async function streamLargeDataset(query) {
  const session = await auth();
  if (!session) throw new Error("Unauthorized");

  // Create a ReadableStream for large datasets
  const stream = new ReadableStream({
    async start(controller) {
      try {
        const totalCount = await db.record.count({ where: query });
        const batchSize = 100;

        for (let offset = 0; offset < totalCount; offset += batchSize) {
          const batch = await db.record.findMany({
            where: query,
            skip: offset,
            take: batchSize,
          });

          controller.enqueue({
            data: batch,
            progress: Math.min((offset + batchSize) / totalCount, 1),
            isComplete: offset + batchSize >= totalCount,
          });

          // Add small delay to prevent overwhelming the client
          await new Promise((resolve) => setTimeout(resolve, 50));
        }

        controller.close();
      } catch (error) {
        controller.error(error);
      }
    },
  });

  return stream;
}
```

<BackToTop />

## Best Practices

### Component Architecture

```javascript
// ‚úÖ Good: Separate concerns clearly
// ServerDataProvider.jsx (Server Component)
async function ServerDataProvider({ children }) {
  const data = await fetchServerData();
  return <DataContext.Provider value={data}>{children}</DataContext.Provider>;
}

// ClientInteractiveWrapper.jsx (Client Component)
("use client");
function ClientInteractiveWrapper({ children }) {
  const [state, setState] = useState();
  return (
    <InteractiveContext.Provider value={{ state, setState }}>
      {children}
    </InteractiveContext.Provider>
  );
}

// Usage
<ServerDataProvider>
  <ClientInteractiveWrapper>
    <MyComponent />
  </ClientInteractiveWrapper>
</ServerDataProvider>;
```

<BackToTop />

### Error Boundaries for Client Components

```javascript
"use client";

import { Component } from "react";

class ClientErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error("Client component error:", error, errorInfo);
    // Send to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Something went wrong</h2>
          <details>
            <summary>Error details</summary>
            <pre>{this.state.error?.message}</pre>
          </details>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Usage
function MyApp() {
  return (
    <ClientErrorBoundary>
      <MyClientComponent />
    </ClientErrorBoundary>
  );
}
```

<BackToTop />

### Type Safety with TypeScript

```typescript
// types/actions.ts
export type ActionResult<T> =
  | {
      success: true;
      data: T;
    }
  | {
      success: false;
      error: string;
      fieldErrors?: Record<string, string[]>;
    };

// actions/user.ts
("use server");

import { z } from "zod";
import type { ActionResult } from "@/types/actions";

const userSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
});

export async function createUser(
  formData: FormData
): Promise<ActionResult<User>> {
  try {
    const validatedData = userSchema.parse({
      name: formData.get("name"),
      email: formData.get("email"),
    });

    const user = await db.user.create({
      data: validatedData,
    });

    return { success: true, data: user };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        error: "Validation failed",
        fieldErrors: error.flatten().fieldErrors,
      };
    }

    return {
      success: false,
      error: "Failed to create user",
    };
  }
}
```

<BackToTop />

## Troubleshooting

### Common Issues and Solutions

#### Hydration Mismatches

```javascript
// ‚ùå Problem: Different content on server vs client
"use client";
function ProblematicComponent() {
  return <div>Current time: {new Date().toLocaleString()}</div>;
}

// ‚úÖ Solution: Ensure consistent rendering
("use client");
import { useState, useEffect } from "react";

function FixedComponent() {
  const [mounted, setMounted] = useState(false);
  const [currentTime, setCurrentTime] = useState("");

  useEffect(() => {
    setMounted(true);
    setCurrentTime(new Date().toLocaleString());
  }, []);

  if (!mounted) {
    return <div>Loading...</div>;
  }

  return <div>Current time: {currentTime}</div>;
}
```

<BackToTop />

#### Server Action Not Working

```javascript
// ‚ùå Problem: Server action not being called
function BrokenForm() {
  const handleSubmit = async (formData) => {
    "use server"; // ‚ùå Can't use directive inside function
    // ...
  };

  return <form action={handleSubmit}>...</form>;
}

// ‚úÖ Solution: Define server action properly
async function handleSubmit(formData) {
  "use server";
  // ...
}

function WorkingForm() {
  return <form action={handleSubmit}>...</form>;
}

// Or use separate file
import { submitForm } from "@/actions/forms";

function WorkingForm() {
  return <form action={submitForm}>...</form>;
}
```

<BackToTop />

#### Bundle Size Issues

```javascript
// ‚ùå Problem: Large client bundle
"use client";
import { massive-library } from 'massive-library';
import { anotherLibrary } from 'another-library';

// ‚úÖ Solution: Dynamic imports
"use client";
import { useState } from 'react';

function OptimizedComponent() {
  const [showAdvanced, setShowAdvanced] = useState(false);

  const handleAdvancedFeature = async () => {
    const { massiveLibrary } = await import('massive-library');
    // Use library only when needed
    massiveLibrary.doSomething();
  };

  return (
    <div>
      <button onClick={() => setShowAdvanced(true)}>
        Show Advanced
      </button>
      {showAdvanced && (
        <AdvancedComponent onAction={handleAdvancedFeature} />
      )}
    </div>
  );
}
```

<BackToTop />

#### Environment Variables in Client Components

```javascript
// ‚ùå Problem: Server env vars in client
"use client";
function ProblematicComponent() {
  const secret = process.env.SECRET_KEY; // ‚ùå Undefined on client
  return <div>{secret}</div>;
}

// ‚úÖ Solution: Use public env vars or pass from server
("use client");
function FixedComponent({ publicApiKey }) {
  // Use NEXT_PUBLIC_ prefixed vars or props from server
  const publicKey = process.env.NEXT_PUBLIC_API_KEY || publicApiKey;
  return <div>{publicKey}</div>;
}

// Server Component passing data
async function ServerWrapper() {
  const publicData = await getPublicConfig();
  return <FixedComponent publicApiKey={publicData.apiKey} />;
}
```

<BackToTop />

### Debugging Tips

#### Development Tools

```javascript
// Enable React DevTools profiling
"use client";
import { Profiler } from "react";

function ProfiledComponent({ children }) {
  const onRenderCallback = (id, phase, actualDuration) => {
    console.log("Profiler:", { id, phase, actualDuration });
  };

  return (
    <Profiler id="MyComponent" onRender={onRenderCallback}>
      {children}
    </Profiler>
  );
}
```

<BackToTop />

#### Server Action Debugging

```javascript
"use server";

export async function debugServerAction(formData) {
  console.log("Server action called with:", Object.fromEntries(formData));

  try {
    const result = await someOperation();
    console.log("Operation result:", result);
    return result;
  } catch (error) {
    console.error("Server action error:", error);
    throw error;
  }
}
```

#### Network Tab Analysis

- Check for unnecessary re-renders causing multiple server action calls
- Monitor payload sizes for form submissions
- Verify server action responses are properly formatted
- Look for failed requests and error responses

<BackToTop />
