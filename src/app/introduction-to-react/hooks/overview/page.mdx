import BackToTop from "@/components/BackToTop";

# Overview

## Table of Contents

## Not The Hooks on a Pirate!

Hooks are a powerful feature in React that allow you to use state and other React features without writing a class. They enable you to manage state, handle side effects, and more in functional components.

React Hooks are functions that let you use state and other React features in functional components. They were introduced in React 16.8 and have become the standard way to write React components. Hooks allow you to manage state, handle side effects, and access context without needing to convert your functional components into class components.

## Why Use Hooks?

Hooks provide a more concise and readable way to manage state and side effects in React applications. They allow you to:

- Write cleaner and more maintainable code by avoiding class components.
- Share logic between components without changing the component hierarchy.
- Use state and lifecycle methods in functional components, making them more powerful and flexible.

Hooks are functions that allow you to "hook into" React state and lifecycle features from functional components. They enable you to use state, context, and other React features without writing a class component.

Hooks are a way to use state and other React features in functional components. They allow you to manage state, handle side effects, and access context without needing to convert your functional components into class components.

## Commonly Used Hooks

| Hook                  | Description                                                                                                                                             |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `useState`            | Allows you to add state to functional components.                                                                                                       |
| `useEffect`           | Lets you perform side effects in functional components, such as data fetching, subscriptions, or manually changing the DOM.                             |
| `useContext`          | Provides a way to access context values in functional components, allowing you to avoid prop drilling.                                                  |
| `useReducer`          | An alternative to `useState` for managing complex state logic, similar to Redux reducers.                                                               |
| `useRef`              | Provides a way to access and interact with DOM elements or store mutable values that persist across renders without causing re-renders.                 |
| `useMemo`             | Optimizes performance by memoizing expensive calculations, preventing unnecessary recalculations on every render.                                       |
| `useCallback`         | Returns a memoized callback function, useful for passing callbacks to child components without causing unnecessary re-renders.                          |
| `useLayoutEffect`     | Similar to `useEffect`, but it runs synchronously after all DOM mutations, allowing you to read layout from the DOM and synchronously reender.          |
| `useImperativeHandle` | Customizes the instance value that is exposed when using `ref` in parent components, allowing you to control what methods or properties are accessible. |
| `useDebugValue`       | Used to display a label for custom hooks in React DevTools, helping with debugging.                                                                     |
| `useFormStatus`       | Provides information about the status of a form submission, such as whether it is submitting or has been submitted.                                     |

<BackToTop />

```javascript
import React, { useState, useEffect } from "react";
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
export default Counter;
```

## Rules of Hooks

- **Only Call Hooks at the Top Level**: Do not call hooks inside loops, conditions, or nested functions. Always call them at the top level of your React function.
- **Only Call Hooks from React Functions**: You can call hooks from React functional components or custom hooks. Do not call them from regular JavaScript functions.
- **Use the Same Order**: Ensure that hooks are called in the same order on every render. This is crucial for React to correctly preserve the state and effects between renders.
