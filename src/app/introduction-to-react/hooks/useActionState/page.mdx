import BackToTop from "@/components/BackToTop";

# useActionState

## Table of Contents

## Overview

The `useActionState` hook is a custom React hook that allows you to manage the state of actions in your application. It provides a way to handle asynchronous operations, such as API calls or other side effects, while keeping track of the loading and error states.
It is particularly useful for managing the state of actions that can be triggered by user interactions, such as form submissions or button clicks.

This hook simplifies the process of managing action states by providing a consistent interface for starting actions, handling success and error states, and resetting the state when necessary. It helps you keep your components clean and focused on rendering UI, while delegating the state management logic to the hook.

#### Benefits of using `useActionState`:

- **Simplified State Management**: It abstracts the complexity of managing loading and error states, allowing you to focus on the core logic of your application.
- **Improved User Experience**: By providing feedback on the status of actions, it enhances the user experience by indicating when an action is in progress or has failed.
- **Reusability**: The hook can be reused across different components, promoting consistency in how actions are handled throughout your application.
- **Separation of Concerns**: It separates the logic of managing action states from the UI components, making your code cleaner and easier to maintain.
- **Flexibility**: It allows you to define custom initial states and provides methods to update the state based on the lifecycle of the action.

#### When to use `useActionState`:

- When you need to manage the state of asynchronous actions in your application.
- When you want to provide feedback to users about the status of actions, such as loading indicators or error messages.
- When you want to simplify the management of action states in your components.
- When you want to encapsulate the logic of handling actions in a reusable way.
- When you want to keep your components clean and focused on rendering UI, while delegating state management to the hook.
- When you want to handle complex action states that involve loading, error, and data management in a consistent manner.
- When you want to improve the maintainability of your code by separating action state management from UI logic.

### Syntax

```javascript
const [state, action] = useActionState(initialState);
```

### Parameters

- `initialState`: The initial state of the action, which can be an object containing properties like `loading`, `error`, and `data`.

### Returns

- An array containing:
  - `state`: The current state of the action, including properties like `loading`, `error`, and `data`.
  - `action`: An object containing methods to update the state, such as `start`, `success`, and `error`.
    <BackToTop />

## Common Use Cases

- **Form Submissions**: Managing the state of form submissions, including loading indicators and error messages.
- **API Calls**: Handling the state of API calls, such as fetching data or submitting data to a server.
- **User Interactions**: Managing the state of user interactions, such as button clicks or other events that trigger actions in your application.
- **Loading Indicators**: Providing visual feedback to users when actions are in progress, such as showing a spinner or disabling buttons.
- **Error Handling**: Capturing and displaying error messages when actions fail, allowing users to understand what went wrong.
- **Data Management**: Keeping track of data returned from actions, such as API responses, and updating the UI accordingly.

## How It Works

The `useActionState` hook works by maintaining an internal state that tracks the status of an action. It provides methods to update this state based on the lifecycle of the action, such as when it starts, succeeds, or fails. The hook returns the current state and the action methods, allowing you to easily manage and respond to changes in the action's status.

### Initial Render

When the hook is first called, it initializes the state with the provided `initialState`. This state typically includes properties like `loading`, `error`, and `data`.

### Action Methods

The `action` object returned by the hook contains methods to update the state:

- `start`: Call this method to set the `loading` state to `true` and reset any previous `error` state.
- `success`: Call this method to set the `loading` state to `false`, clear any `error` state, and update the `data` with the result of the action.
- `error`: Call this method to set the `loading` state to `false` and update the `error` state with the provided error message.
- `reset`: Call this method to reset the state to the initial state, clearing any `loading`, `error`, or `data` values.
- `setData`: Call this method to update the `data` state with a new value without changing the `loading` or `error` states.
- `setError`: Call this method to update the `error` state with a new error message without changing the `loading` or `data` states.
- `setLoading`: Call this method to update the `loading` state to a specific boolean value.
- `setState`: Call this method to update the entire state object with a new state, allowing for more complex state updates.
- `getState`: Call this method to retrieve the current state of the action.
- `getLoading`: Call this method to retrieve the current loading state.
- `getError`: Call this method to retrieve the current error state.
- `getData`: Call this method to retrieve the current data state.
- `getAction`: Call this method to retrieve the action methods, allowing you to access them outside of the hook's context.
- `getInitialState`: Call this method to retrieve the initial state of the action, which can be useful for resetting the state or comparing against the current state.
- `getInitialLoading`: Call this method to retrieve the initial loading state, which can be useful for determining if the action was initially in a loading state.
- `getInitialError`: Call this method to retrieve the initial error state, which can be useful for determining if the action was initially in an error state.
- `getInitialData`: Call this method to retrieve the initial data state, which can be useful for determining if the action was initially in a data state.
- `getInitialAction`: Call this method to retrieve the initial action methods, which can be useful for resetting the action state or comparing against the current action methods.

## What to Avoid

- Avoid using `useActionState` for synchronous actions, as it is designed for managing asynchronous operations.
- Avoid directly mutating the state returned by the hook; always use the provided action methods to update the state.
- Avoid using the hook in non-functional components, as it relies on React's hooks system, which is only available in functional components.

  <BackToTop />

## Examples

### Basic Usage

```javascript
import React from "react";
import { useActionState } from "your-hook-library";
const MyComponent = () => {
  const [state, action] = useActionState({
    loading: false,
    error: null,
    data: null,
  });

  const handleSubmit = async () => {
    action.start();
    try {
      const response = await fetch("/api/data");
      const data = await response.json();
      action.success(data);
    } catch (error) {
      action.error(error.message);
    }
  };

  return (
    <div>
      <button onClick={handleSubmit} disabled={state.loading}>
        {state.loading ? "Loading..." : "Submit"}
      </button>
      {state.error && <p>Error: {state.error}</p>}
      {state.data && <p>Data: {JSON.stringify(state.data)}</p>}
    </div>
  );
};
```

<BackToTop />
### Form Submission Example

```javascript
import React, { useState } from "react";
import { useActionState } from "your-hook-library";
const FormComponent = () => {
  const [formData, setFormData] = useState({ name: "", email: "" });
  const [state, action] = useActionState({
    loading: false,
    error: null,
    data: null,
  });
  const handleChange = (e) => {
    setFormData({ ...formData, [e.target.name]: e.target.value });
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    action.start();
    try {
      const response = await fetch("/api/submit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });
      const data = await response.json();
      action.success(data);
    } catch (error) {
      action.error(error.message);
    }
  };
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        name="name"
        value={formData.name}
        onChange={handleChange}
        placeholder="Name"
      />
      <input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <button type="submit" disabled={state.loading}>
        {state.loading ? "Submitting..." : "Submit"}
      </button>
      {state.error && <p>Error: {state.error}</p>}
      {state.data && <p>Success: {JSON.stringify(state.data)}</p>}
    </form>
  );
};
```

<BackToTop />

## Best Practices

- **Use Descriptive State Names**: When defining the initial state, use descriptive names for properties like `loading`, `error`, and `data` to make the code more readable.
- **Handle Errors Gracefully**: Always handle errors in your action methods to provide feedback to users when something goes wrong.
- **Keep State Management Simple**: Use the `useActionState` hook to manage the state of actions in a simple and consistent way, avoiding unnecessary complexity in your components.
- **Reuse the Hook**: If you find yourself managing similar action states in multiple components, consider creating a custom hook that encapsulates the logic of `useActionState` to promote reusability and maintainability.
- **Test Your Actions**: Write tests for your action methods to ensure they behave as expected, especially when handling loading and error states.
- **Use the Hook in Functional Components**: Ensure that you are using the `useActionState` hook within functional components, as it relies on React's hooks system.
  <BackToTop />
