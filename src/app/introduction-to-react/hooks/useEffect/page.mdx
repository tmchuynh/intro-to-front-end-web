import BackToTop from "@/components/BackToTop";

# useEffect

## Table of Contents

## Overview

`useEffect` is a React Hook that allows you to perform side effects in function components. Side effects are operations that can affect other components and cannot be done during rendering, such as data fetching, subscriptions, or manually changing the DOM. `useEffect` runs after the render is committed to the screen, making it suitable for tasks that need to interact with the browser or external systems.

### Syntax

```javascript
useEffect(() => {
  // Your side effect code here
}, [dependencies]);
```

### Parameters

- **callback**: A function that contains the side effect code. This function is executed after the component renders.
- **dependencies**: An optional array of dependencies that determines when the effect should run. If any of the dependencies change, the effect will re-run. If you pass an empty array, the effect will only run once after the initial render, similar to componentDidMount in class components.

#### Example

```javascript
import React, { useState, useEffect } from "react";
function ExampleComponent() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `Count: ${count}`;
    return () => {
      // Cleanup function to run before the effect runs again or on unmount
      console.log("Cleaning up...");
    };
  }, [count]); // Effect runs when 'count' changes
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
export default ExampleComponent;
```

<BackToTop />

### Cleanup Function

When you use useEffect, you can return a cleanup function that React will call before the component unmounts or before the effect runs again. This is useful for cleaning up subscriptions, timers, or any other resources that need to be released.

```javascript
useEffect(() => {
  const timer = setTimeout(() => {
    console.log("Timer executed");
  }, 1000);
  return () => {
    clearTimeout(timer); // Cleanup function to clear the timer
    console.log("Cleanup executed");
  };
}, []); // Empty dependency array means this effect runs once on mount
```

This cleanup function will run when the component unmounts or before the effect runs again, ensuring that resources are properly released.

<BackToTop />

## Common Use Cases

- **Data Fetching**: Fetching data from an API when the component mounts or when certain dependencies change.
- **Event Listeners**: Adding and removing event listeners for user interactions.
- **Timers**: Setting up and clearing timers or intervals.
- **Subscriptions**: Managing subscriptions to external data sources, such as WebSocket connections or third-party libraries.
- **Animations**: Triggering animations or transitions based on state changes.
- **Local Storage**: Syncing state with local storage or session storage.
- **Form Validation**: Validating form inputs and updating the UI based on validation results.
- **Logging**: Logging component lifecycle events or state changes for debugging purposes.
- **Third-Party Libraries**: Integrating with third-party libraries that require side effects, such as charting libraries or UI frameworks.
- **Cleanup Operations**: Performing cleanup operations when the component unmounts, such as clearing intervals or unsubscribing from events.
  <BackToTop />

## What to Avoid

- **Avoid Side Effects in Render**: Do not perform side effects directly in the render method. Use `useEffect` to handle side effects after the render is complete.
- **Avoid Infinite Loops**: Be cautious with the dependency array. If you include a state variable that is updated within the effect, it can lead to an infinite loop. Always ensure that the dependencies are correctly set to avoid this issue.
- **Avoid Heavy Computations**: Do not perform heavy computations or synchronous operations inside the effect callback, as it can block the main thread and lead to a poor user experience. Use asynchronous operations or web workers for heavy tasks.
- **Avoid Memory Leaks**: Always clean up resources in the cleanup function to prevent memory leaks, especially when dealing with subscriptions or timers.
- **Avoid Using `useEffect` for Initial State**: Do not use `useEffect` to set the initial state of a component. Instead, use the initial state directly in the useState hook.
- **Avoid Using `useEffect` for Component Logic**: Use `useEffect` primarily for side effects. Keep your component logic and state management separate to maintain clarity and separation of concerns.
- **Avoid Overusing `useEffect`**: While `useEffect` is powerful, overusing it can lead to complex and hard-to-maintain code. Use it judiciously for side effects that cannot be handled during rendering.
- **Avoid Using `useEffect` for Simple State Updates**: If you only need to update state based on user interactions, consider using event handlers instead of `useEffect`. UseEffect is best suited for side effects that involve external systems or APIs.

## Examples

### Timer Example

```javascript
import React, { useState, useEffect } from "react";
function TimerComponent() {
  const [seconds, setSeconds] = useState(0);
  useEffect(() => {
    const timer = setInterval(() => {
      setSeconds((prevSeconds) => prevSeconds + 1);
    }, 1000);
    return () => clearInterval(timer); // Cleanup function to clear the interval
  }, []); // Empty dependency array means this effect runs once on mount
  return (
    <div>
      <h1>Timer: {seconds} seconds</h1>
    </div>
  );
}
export default TimerComponent;
```

In this example, a timer is set up to increment the seconds every second. The cleanup function clears the interval when the component unmounts or before the effect runs again.

<BackToTop />

### Data Fetching Example

```javascript
import React, { useState, useEffect } from "react";
function FetchDataComponent() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch("https://api.example.com/data");
        const result = await response.json();
        setData(result);
      } catch (error) {
        console.error("Error fetching data:", error);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []); // Effect runs once on mount
  return (
    <div>
      {loading ? <p>Loading...</p> : <pre>{JSON.stringify(data, null, 2)}</pre>}
    </div>
  );
}
export default FetchDataComponent;
```

This example demonstrates how to fetch data from an API when the component mounts. The loading state is managed to show a loading message while the data is being fetched.

<BackToTop />

### Animation Example

```javascript
import React, { useState, useEffect } from "react";
function AnimationComponent() {
  const [isAnimating, setIsAnimating] = useState(false);
  useEffect(() => {
    const animation = () => {
      console.log("Animation started");
      setIsAnimating(true);
    };
    const cleanup = () => {
      console.log("Animation ended");
      setIsAnimating(false);
    };
    window.addEventListener("animationstart", animation);
    window.addEventListener("animationend", cleanup);
    return () => {
      window.removeEventListener("animationstart", animation);
      window.removeEventListener("animationend", cleanup); // Cleanup function to remove event listeners
    };
  }, []); // Effect runs once on mount
  return (
    <div>
      <h1>{isAnimating ? "Animating..." : "Not Animating"}</h1>
    </div>
  );
}
export default AnimationComponent;
```

This example shows how to handle animations by adding and removing event listeners for animation events. The cleanup function ensures that the event listeners are removed when the component unmounts or before the effect runs again.

<BackToTop />

### Subscription Example

```javascript
import React, { useState, useEffect } from "react";
function SubscriptionComponent() {
  const [data, setData] = useState(null);
  useEffect(() => {
    const subscribe = () => {
      console.log("Subscribed to data source");
      // Simulate data subscription
      setData({ message: "Data from subscription" });
    };
    subscribe();
    return () => {
      console.log("Unsubscribed from data source"); // Cleanup function to unsubscribe
      setData(null);
    };
  }, []); // Effect runs once on mount
  return (
    <div>
      <h1>Subscription Data: {data ? data.message : "No data"}</h1>
    </div>
  );
}
export default SubscriptionComponent;
```

This example demonstrates how to manage subscriptions to an external data source. The cleanup function ensures that the subscription is properly cleaned up when the component unmounts or before the effect runs again.

<BackToTop />

## Best Practices

- **Dependency Array**: Always specify the dependency array to avoid unnecessary re-renders and side effects. If you want the effect to run only once, pass an empty array.
- **Cleanup Functions**: Use cleanup functions to prevent memory leaks and ensure that resources are released when the component unmounts or before the effect runs again.
- **Avoid Side Effects in Render**: Do not perform side effects directly in the render method. Use `useEffect` to handle side effects after the render is complete.
- **Keep Effects Focused**: Each `useEffect` should handle a single concern or side effect. Avoid combining unrelated logic in a single effect to keep your code clean and maintainable.
- **Use Multiple Effects**: If you have multiple side effects, consider using multiple `useEffect` calls instead of combining them into one. This improves readability and separation of concerns.
  <BackToTop />
