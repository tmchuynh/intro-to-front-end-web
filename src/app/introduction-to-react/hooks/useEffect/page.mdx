import BackToTop from "@/components/BackToTop";

# useEffect

## Table of Contents

## Overview

`useEffect` is a React Hook that allows you to perform side effects in function components. Side effects are operations that can affect other components and cannot be done during rendering, such as data fetching, subscriptions, or manually changing the DOM. `useEffect` runs after the render is committed to the screen, making it suitable for tasks that need to interact with the browser or external systems.

#### Benefits of `useEffect`

- **Separation of Concerns**: It allows you to separate side effects from the main component logic, making your code cleaner and easier to maintain.
- **Lifecycle Management**: It provides a way to manage component lifecycle events, such as mounting, updating, and unmounting, similar to `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` in class components.
- **Asynchronous Operations**: It enables you to handle asynchronous operations, such as fetching data from an API or subscribing to events, without blocking the main thread.
- **Cleanup**: It allows you to clean up resources, such as event listeners or timers, when the component unmounts or before the effect runs again, preventing memory leaks.
- **Performance Optimization**: It can help optimize performance by controlling when side effects run, reducing unnecessary re-renders and computations.
- **Declarative Approach**: It provides a declarative way to express side effects, making it easier to reason about the component's behavior and state changes.
- **Flexibility**: It allows you to specify dependencies, so the effect only runs when certain values change, giving you fine-grained control over when side effects occur.
- **Integration with External Libraries**: It makes it easier to integrate with third-party libraries that require side effects, such as animation libraries or data fetching libraries.
- **Testing**: It simplifies testing by allowing you to mock side effects and control their behavior during tests.
- **Improved Readability**: It enhances code readability by keeping side effects in a dedicated place, making it easier to understand the component's behavior.
- **Consistency**: It provides a consistent way to handle side effects across different components, reducing the need for custom solutions or patterns.
- **Debugging**: It can help with debugging by providing a clear structure for side effects, making it easier to trace issues related to state changes or external interactions.

#### When to Use `useEffect`

- **Data Fetching**: When you need to fetch data from an API or external source when the component mounts or when certain dependencies change.
- **Event Listeners**: When you need to add event listeners for user interactions, such as clicks or key presses, and remove them when the component unmounts or before the effect runs again.
- **Timers**: When you need to set up timers or intervals to perform actions at specific intervals, such as updating a clock or polling for data.
- **Subscriptions**: When you need to subscribe to external data sources, such as WebSocket connections or third-party libraries, and clean up the subscription when the component unmounts or before the effect runs again.
- **Animations**: When you need to trigger animations or transitions based on state changes or user interactions, ensuring that the animations run smoothly without blocking the main thread.
- **Local Storage**: When you need to sync state with local storage or session storage, allowing the state to persist across page reloads or sessions.
- **Form Validation**: When you need to validate form inputs and update the UI based on validation results, ensuring that the form behaves correctly as the user interacts with it.
- **Logging**: When you need to log component lifecycle events or state changes for debugging purposes, providing insights into the component's behavior during development.
- **Third-Party Libraries**: When you need to integrate with third-party libraries that require side effects, such as charting libraries or UI frameworks, ensuring that the library functions correctly within your React component.
- **Cleanup Operations**: When you need to perform cleanup operations, such as clearing intervals or unsubscribing from events, to prevent memory leaks and ensure that resources are properly released when the component unmounts or before the effect runs again.

### Syntax

```javascript
useEffect(() => {
  // Your side effect code here
}, [dependencies]);
```

### Parameters

- **callback**: A function that contains the side effect code. This function is executed after the component renders.
- **dependencies**: An optional array of dependencies that determines when the effect should run. If any of the dependencies change, the effect will re-run. If you pass an empty array, the effect will only run once after the initial render, similar to componentDidMount in class components.

#### Example

```javascript
import React, { useState, useEffect } from "react";

function DataFetcher() {
  const [data, setData] = useState(null); // State to hold the fetched data
  const [loading, setLoading] = useState(true); // State to track loading status
  const [error, setError] = useState(null); // State to handle potential errors

  useEffect(() => {
    // Define an asynchronous function to fetch the data
    const fetchData = async () => {
      try {
        const response = await fetch(
          "https://jsonplaceholder.typicode.com/users",
        ); // Replace with your API endpoint
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const jsonData = await response.json();
        setData(jsonData); // Update the data state
      } catch (error) {
        setError(error); // Handle errors
      } finally {
        setLoading(false); // Set loading to false after fetch completes
      }
    };

    fetchData(); // Call the async function to start fetching

    // Cleanup function (optional but good practice for more complex scenarios,
    // like cancelling a request if the component unmounts before the fetch finishes)
    return () => {
      // In a real-world scenario, you might use AbortController to cancel the fetch request here.
    };
  }, []); // Empty dependency array: runs only once after the initial render

  if (loading) {
    return <div>Loading data...</div>; // Show loading indicator
  }

  if (error) {
    return <div>Error fetching data: {error.message}</div>; // Display error message
  }

  return (
    <div>
      <h1>Fetched Data:</h1>
      {/* Render the fetched data */}
      {data &&
        data.map((item) => (
          <div key={item.id}>
            <h2>{item.name}</h2>
            <p>{item.email}</p>
          </div>
        ))}
    </div>
  );
}

export default DataFetcher;
```

<BackToTop />

### Cleanup Function

When you use useEffect, you can return a cleanup function that React will call before the component unmounts or before the effect runs again. This is useful for cleaning up subscriptions, timers, or any other resources that need to be released.

```javascript
useEffect(() => {
  // Your side effect code here

  return () => {
    // Cleanup code here
    // This function will run when the component unmounts or before the effect runs again
  };
}, [dependencies]);
```

This cleanup function will run when the component unmounts or before the effect runs again, ensuring that resources are properly released.

<BackToTop />

## Common Use Cases

- **Data Fetching**: Fetching data from an API when the component mounts or when certain dependencies change.
- **Event Listeners**: Adding and removing event listeners for user interactions.
- **Timers**: Setting up and clearing timers or intervals.
- **Subscriptions**: Managing subscriptions to external data sources, such as WebSocket connections or third-party libraries.
- **Animations**: Triggering animations or transitions based on state changes.
- **Local Storage**: Syncing state with local storage or session storage.
- **Form Validation**: Validating form inputs and updating the UI based on validation results.
- **Logging**: Logging component lifecycle events or state changes for debugging purposes.
- **Third-Party Libraries**: Integrating with third-party libraries that require side effects, such as charting libraries or UI frameworks.
- **Cleanup Operations**: Performing cleanup operations when the component unmounts, such as clearing intervals or unsubscribing from events.
  <BackToTop />

## How It Works

### Initial Render

When a component first renders, the `useEffect` callback is executed after the render is committed to the screen. This allows you to perform side effects without blocking the initial render.

### Dependency Array

The dependency array is crucial for controlling when the effect runs. If you provide an empty array, the effect will only run once after the initial render, similar to `componentDidMount`. If you include dependencies, the effect will re-run whenever any of those dependencies change, similar to `componentDidUpdate`.

### Cleanup Function

If you return a cleanup function from the `useEffect` callback, React will call this function before the component unmounts or before the effect runs again. This is useful for cleaning up resources, such as event listeners or timers, to prevent memory leaks and ensure that resources are properly released.

### Execution Order

1. The component renders.
2. The `useEffect` callback is executed after the render is committed to the screen.
3. If the effect has a cleanup function, it will be called before the component unmounts or before the effect runs again.
4. The component re-renders if the state or props change, and the process repeats.

```javascript
useEffect(() => {
  // Your side effect code here
  return () => {
    // Cleanup code here
  };
}, [dependencies]);
```

<BackToTop />

## What to Avoid

- **Avoid Side Effects in Render**: Do not perform side effects directly in the render method. Use `useEffect` to handle side effects after the render is complete.
- **Avoid Infinite Loops**: Be cautious with the dependency array. If you include a state variable that is updated within the effect, it can lead to an infinite loop. Always ensure that the dependencies are correctly set to avoid this issue.
- **Avoid Heavy Computations**: Do not perform heavy computations or synchronous operations inside the effect callback, as it can block the main thread and lead to a poor user experience. Use asynchronous operations or web workers for heavy tasks.
- **Avoid Memory Leaks**: Always clean up resources in the cleanup function to prevent memory leaks, especially when dealing with subscriptions or timers.
- **Avoid Using `useEffect` for Initial State**: Do not use `useEffect` to set the initial state of a component. Instead, use the initial state directly in the useState hook.
- **Avoid Using `useEffect` for Component Logic**: Use `useEffect` primarily for side effects. Keep your component logic and state management separate to maintain clarity and separation of concerns.
- **Avoid Overusing `useEffect`**: While `useEffect` is powerful, overusing it can lead to complex and hard-to-maintain code. Use it judiciously for side effects that cannot be handled during rendering.
- **Avoid Using `useEffect` for Simple State Updates**: If you only need to update state based on user interactions, consider using event handlers instead of `useEffect`. UseEffect is best suited for side effects that involve external systems or APIs.
  <BackToTop />

## Examples

### Real-time Weather Dashboard with Geolocation

```javascript
import React, { useState, useEffect } from "react";

function WeatherDashboard() {
  const [weatherData, setWeatherData] = useState(null);
  const [location, setLocation] = useState({ latitude: null, longitude: null });
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [lastUpdated, setLastUpdated] = useState(null);
  const [autoRefresh, setAutoRefresh] = useState(true);

  // Effect for getting user's geolocation
  useEffect(() => {
    let watchId;

    const successCallback = (position) => {
      setLocation({
        latitude: position.coords.latitude,
        longitude: position.coords.longitude,
      });
      setError(null);
    };

    const errorCallback = (err) => {
      setError(`Geolocation error: ${err.message}`);
      setLoading(false);
      // Fallback to a default location (New York City)
      setLocation({ latitude: 40.7128, longitude: -74.006 });
    };

    if ("geolocation" in navigator) {
      // Get initial position
      navigator.geolocation.getCurrentPosition(successCallback, errorCallback, {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 300000, // 5 minutes
      });

      // Watch for position changes
      watchId = navigator.geolocation.watchPosition(
        successCallback,
        errorCallback,
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 60000, // 1 minute
        },
      );
    } else {
      setError("Geolocation is not supported by this browser");
      setLocation({ latitude: 40.7128, longitude: -74.006 });
    }

    // Cleanup function
    return () => {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
      }
    };
  }, []);

  // Effect for fetching weather data when location changes
  useEffect(() => {
    if (!location.latitude || !location.longitude) return;

    const fetchWeatherData = async () => {
      setLoading(true);
      try {
        // Mock API call - replace with real weather API
        const response = await fetch(
          `https://api.openweathermap.org/data/2.5/weather?lat=${location.latitude}&lon=${location.longitude}&appid=YOUR_API_KEY&units=metric`,
        );

        if (!response.ok) {
          throw new Error(`Weather API error: ${response.status}`);
        }

        // For demo purposes, using mock data
        const mockData = {
          name: "Current Location",
          main: {
            temp: Math.round(Math.random() * 30 + 5),
            feels_like: Math.round(Math.random() * 30 + 5),
            humidity: Math.round(Math.random() * 50 + 30),
            pressure: Math.round(Math.random() * 50 + 1000),
          },
          weather: [
            {
              main: ["Clear", "Clouds", "Rain", "Snow"][
                Math.floor(Math.random() * 4)
              ],
              description: "scattered clouds",
              icon: "03d",
            },
          ],
          wind: {
            speed: Math.round(Math.random() * 20 + 5),
            deg: Math.round(Math.random() * 360),
          },
          sys: {
            sunrise: Date.now() - 6 * 60 * 60 * 1000,
            sunset: Date.now() + 6 * 60 * 60 * 1000,
          },
        };

        setWeatherData(mockData);
        setLastUpdated(new Date());
        setError(null);
      } catch (err) {
        setError(`Failed to fetch weather data: ${err.message}`);
      } finally {
        setLoading(false);
      }
    };

    fetchWeatherData();
  }, [location.latitude, location.longitude]);

  // Effect for auto-refresh functionality
  useEffect(() => {
    if (!autoRefresh || !location.latitude || !location.longitude) return;

    const interval = setInterval(() => {
      // Trigger a re-fetch by updating a dependency
      setLocation((prev) => ({ ...prev }));
    }, 300000); // Refresh every 5 minutes

    return () => clearInterval(interval);
  }, [autoRefresh, location.latitude, location.longitude]);

  // Effect for page visibility API to pause/resume updates
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden) {
        setAutoRefresh(false);
        console.log("Page hidden - pausing weather updates");
      } else {
        setAutoRefresh(true);
        console.log("Page visible - resuming weather updates");
        // Trigger immediate update when page becomes visible
        if (location.latitude && location.longitude) {
          setLocation((prev) => ({ ...prev }));
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [location.latitude, location.longitude]);

  // Effect for keyboard shortcuts
  useEffect(() => {
    const handleKeyPress = (event) => {
      if (event.ctrlKey || event.metaKey) {
        switch (event.key) {
          case "r":
            event.preventDefault();
            if (location.latitude && location.longitude) {
              setLocation((prev) => ({ ...prev }));
            }
            break;
          case "t":
            event.preventDefault();
            setAutoRefresh((prev) => !prev);
            break;
        }
      }
    };

    window.addEventListener("keydown", handleKeyPress);

    return () => {
      window.removeEventListener("keydown", handleKeyPress);
    };
  }, [location.latitude, location.longitude]);

  const formatTime = (timestamp) => {
    return new Date(timestamp).toLocaleTimeString();
  };

  const getWeatherIcon = (weatherMain) => {
    const icons = {
      Clear: "â˜€ï¸",
      Clouds: "â˜ï¸",
      Rain: "ğŸŒ§ï¸",
      Snow: "â„ï¸",
    };
    return icons[weatherMain] || "ğŸŒ¤ï¸";
  };

  if (loading) {
    return (
      <div
        style={{
          padding: "40px",
          textAlign: "center",
          fontFamily: "Arial, sans-serif",
        }}
      >
        <div style={{ fontSize: "24px", marginBottom: "20px" }}>ğŸŒ</div>
        <div>Loading weather data...</div>
        <div style={{ fontSize: "12px", color: "#666", marginTop: "10px" }}>
          Getting your location and fetching weather information
        </div>
      </div>
    );
  }

  return (
    <div
      style={{
        padding: "20px",
        maxWidth: "800px",
        margin: "0 auto",
        fontFamily: "Arial, sans-serif",
      }}
    >
      <div
        style={{
          background: "linear-gradient(135deg, #74b9ff 0%, #0984e3 100%)",
          color: "white",
          padding: "30px",
          borderRadius: "15px",
          marginBottom: "20px",
          boxShadow: "0 10px 25px rgba(0,0,0,0.1)",
        }}
      >
        <h1 style={{ margin: "0 0 20px 0", fontSize: "28px" }}>
          Weather Dashboard ğŸŒ¦ï¸
        </h1>

        {error && (
          <div
            style={{
              backgroundColor: "rgba(255,255,255,0.2)",
              padding: "10px",
              borderRadius: "8px",
              marginBottom: "20px",
              fontSize: "14px",
            }}
          >
            âš ï¸ {error}
          </div>
        )}

        {weatherData && (
          <div>
            <div
              style={{
                display: "flex",
                alignItems: "center",
                marginBottom: "20px",
              }}
            >
              <div style={{ fontSize: "60px", marginRight: "20px" }}>
                {getWeatherIcon(weatherData.weather[0].main)}
              </div>
              <div>
                <div style={{ fontSize: "48px", fontWeight: "bold" }}>
                  {weatherData.main.temp}Â°C
                </div>
                <div style={{ fontSize: "18px", opacity: 0.9 }}>
                  Feels like {weatherData.main.feels_like}Â°C
                </div>
                <div
                  style={{
                    fontSize: "16px",
                    opacity: 0.8,
                    textTransform: "capitalize",
                  }}
                >
                  {weatherData.weather[0].description}
                </div>
              </div>
            </div>

            <div
              style={{
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(150px, 1fr))",
                gap: "15px",
                marginBottom: "20px",
              }}
            >
              <div style={{ textAlign: "center" }}>
                <div style={{ fontSize: "24px" }}>ğŸ’§</div>
                <div style={{ fontSize: "20px", fontWeight: "bold" }}>
                  {weatherData.main.humidity}%
                </div>
                <div style={{ fontSize: "14px", opacity: 0.8 }}>Humidity</div>
              </div>

              <div style={{ textAlign: "center" }}>
                <div style={{ fontSize: "24px" }}>ğŸŒªï¸</div>
                <div style={{ fontSize: "20px", fontWeight: "bold" }}>
                  {weatherData.wind.speed} m/s
                </div>
                <div style={{ fontSize: "14px", opacity: 0.8 }}>Wind Speed</div>
              </div>

              <div style={{ textAlign: "center" }}>
                <div style={{ fontSize: "24px" }}>ğŸ“Š</div>
                <div style={{ fontSize: "20px", fontWeight: "bold" }}>
                  {weatherData.main.pressure} hPa
                </div>
                <div style={{ fontSize: "14px", opacity: 0.8 }}>Pressure</div>
              </div>

              <div style={{ textAlign: "center" }}>
                <div style={{ fontSize: "24px" }}>ğŸŒ…</div>
                <div style={{ fontSize: "16px", fontWeight: "bold" }}>
                  {formatTime(weatherData.sys.sunrise)}
                </div>
                <div style={{ fontSize: "14px", opacity: 0.8 }}>Sunrise</div>
              </div>
            </div>
          </div>
        )}

        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            fontSize: "12px",
            opacity: 0.8,
            borderTop: "1px solid rgba(255,255,255,0.3)",
            paddingTop: "15px",
          }}
        >
          <div>
            ğŸ“ {location.latitude?.toFixed(4)}, {location.longitude?.toFixed(4)}
          </div>
          <div>
            {lastUpdated && `Last updated: ${lastUpdated.toLocaleTimeString()}`}
          </div>
        </div>
      </div>

      <div
        style={{
          display: "flex",
          gap: "10px",
          justifyContent: "center",
          flexWrap: "wrap",
        }}
      >
        <button
          onClick={() => setLocation((prev) => ({ ...prev }))}
          style={{
            padding: "10px 20px",
            backgroundColor: "#00b894",
            color: "white",
            border: "none",
            borderRadius: "8px",
            cursor: "pointer",
            fontSize: "14px",
          }}
        >
          ğŸ”„ Refresh Now
        </button>

        <button
          onClick={() => setAutoRefresh((prev) => !prev)}
          style={{
            padding: "10px 20px",
            backgroundColor: autoRefresh ? "#e17055" : "#74b9ff",
            color: "white",
            border: "none",
            borderRadius: "8px",
            cursor: "pointer",
            fontSize: "14px",
          }}
        >
          {autoRefresh ? "â¸ï¸ Pause Auto-refresh" : "â–¶ï¸ Enable Auto-refresh"}
        </button>
      </div>

      <div
        style={{
          marginTop: "20px",
          padding: "15px",
          backgroundColor: "#f8f9fa",
          borderRadius: "8px",
          fontSize: "12px",
          color: "#666",
        }}
      >
        <div style={{ fontWeight: "bold", marginBottom: "8px" }}>
          Keyboard Shortcuts:
        </div>
        <div>â€¢ Ctrl/Cmd + R: Refresh weather data</div>
        <div>â€¢ Ctrl/Cmd + T: Toggle auto-refresh</div>
        <div style={{ marginTop: "8px" }}>
          Auto-refresh is {autoRefresh ? "enabled" : "disabled"}
          {autoRefresh && " (updates every 5 minutes)"}
        </div>
      </div>
    </div>
  );
}

export default WeatherDashboard;
```

<BackToTop />

### Advanced Document Title and Meta Manager

```javascript
import React, { useState, useEffect, useRef } from "react";

function DocumentManager() {
  const [pageTitle, setPageTitle] = useState("Document Manager");
  const [metaDescription, setMetaDescription] = useState(
    "Advanced document management",
  );
  const [favicon, setFavicon] = useState("ğŸ“„");
  const [notifications, setNotifications] = useState([]);
  const [isActive, setIsActive] = useState(true);
  const [visitDuration, setVisitDuration] = useState(0);
  const originalTitle = useRef(document.title);
  const originalFavicon = useRef(null);
  const startTime = useRef(Date.now());

  // Effect for managing document title with activity status
  useEffect(() => {
    const updateTitle = () => {
      if (isActive) {
        document.title = pageTitle;
      } else {
        document.title = `ğŸ’¤ ${pageTitle} - Come back!`;
      }
    };

    updateTitle();

    // Cleanup: restore original title when component unmounts
    return () => {
      document.title = originalTitle.current;
    };
  }, [pageTitle, isActive]);

  // Effect for managing meta description
  useEffect(() => {
    let metaTag = document.querySelector('meta[name="description"]');

    if (!metaTag) {
      metaTag = document.createElement("meta");
      metaTag.name = "description";
      document.head.appendChild(metaTag);
    }

    const originalDescription = metaTag.content;
    metaTag.content = metaDescription;

    // Cleanup: restore original description
    return () => {
      if (originalDescription) {
        metaTag.content = originalDescription;
      } else {
        metaTag.remove();
      }
    };
  }, [metaDescription]);

  // Effect for managing favicon
  useEffect(() => {
    let linkTag = document.querySelector('link[rel="icon"]');

    if (!linkTag) {
      linkTag = document.createElement("link");
      linkTag.rel = "icon";
      document.head.appendChild(linkTag);
    }

    // Store original favicon on first run
    if (!originalFavicon.current) {
      originalFavicon.current = linkTag.href;
    }

    // Create emoji favicon
    const canvas = document.createElement("canvas");
    canvas.height = 64;
    canvas.width = 64;
    const context = canvas.getContext("2d");
    context.font = "50px serif";
    context.fillText(favicon, 0, 50);

    linkTag.href = canvas.toDataURL();

    // Cleanup: restore original favicon
    return () => {
      if (originalFavicon.current) {
        linkTag.href = originalFavicon.current;
      }
    };
  }, [favicon]);

  // Effect for tracking page visibility and activity
  useEffect(() => {
    const handleVisibilityChange = () => {
      setIsActive(!document.hidden);

      if (document.hidden) {
        addNotification("Page became inactive", "info");
      } else {
        addNotification("Page became active", "success");
      }
    };

    const handleFocus = () => {
      setIsActive(true);
      addNotification("Window gained focus", "success");
    };

    const handleBlur = () => {
      setIsActive(false);
      addNotification("Window lost focus", "warning");
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    window.addEventListener("focus", handleFocus);
    window.addEventListener("blur", handleBlur);

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("focus", handleFocus);
      window.removeEventListener("blur", handleBlur);
    };
  }, []);

  // Effect for tracking visit duration
  useEffect(() => {
    const interval = setInterval(() => {
      if (isActive) {
        setVisitDuration(Math.floor((Date.now() - startTime.current) / 1000));
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [isActive]);

  // Effect for browser storage sync
  useEffect(() => {
    const storageKey = "documentManagerSettings";

    // Load settings from localStorage
    const savedSettings = localStorage.getItem(storageKey);
    if (savedSettings) {
      try {
        const settings = JSON.parse(savedSettings);
        setPageTitle(settings.title || pageTitle);
        setMetaDescription(settings.description || metaDescription);
        setFavicon(settings.favicon || favicon);
      } catch (error) {
        console.error("Error loading settings:", error);
      }
    }

    // Save settings to localStorage when they change
    const settings = {
      title: pageTitle,
      description: metaDescription,
      favicon: favicon,
    };
    localStorage.setItem(storageKey, JSON.stringify(settings));
  }, [pageTitle, metaDescription, favicon]);

  // Effect for keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.ctrlKey || event.metaKey) {
        switch (event.key) {
          case "1":
            event.preventDefault();
            setFavicon("ğŸ ");
            addNotification("Favicon changed to home", "info");
            break;
          case "2":
            event.preventDefault();
            setFavicon("âš™ï¸");
            addNotification("Favicon changed to settings", "info");
            break;
          case "3":
            event.preventDefault();
            setFavicon("ğŸ“Š");
            addNotification("Favicon changed to analytics", "info");
            break;
          case "d":
            event.preventDefault();
            exportSettings();
            break;
          case "r":
            event.preventDefault();
            resetSettings();
            break;
        }
      }
    };

    window.addEventListener("keydown", handleKeyDown);

    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);

  // Effect for beforeunload warning
  useEffect(() => {
    const handleBeforeUnload = (event) => {
      if (visitDuration > 30) {
        // If user has been on page for more than 30 seconds
        event.preventDefault();
        event.returnValue =
          "Are you sure you want to leave? Your changes might not be saved.";
        return event.returnValue;
      }
    };

    window.addEventListener("beforeunload", handleBeforeUnload);

    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [visitDuration]);

  const addNotification = (message, type = "info") => {
    const notification = {
      id: Date.now(),
      message,
      type,
      timestamp: new Date().toLocaleTimeString(),
    };

    setNotifications((prev) => [notification, ...prev.slice(0, 4)]);

    // Auto-remove notification after 3 seconds
    setTimeout(() => {
      setNotifications((prev) => prev.filter((n) => n.id !== notification.id));
    }, 3000);
  };

  const exportSettings = () => {
    const settings = {
      title: pageTitle,
      description: metaDescription,
      favicon: favicon,
      exportedAt: new Date().toISOString(),
    };

    const blob = new Blob([JSON.stringify(settings, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "document-settings.json";
    a.click();
    URL.revokeObjectURL(url);

    addNotification("Settings exported", "success");
  };

  const resetSettings = () => {
    setPageTitle("Document Manager");
    setMetaDescription("Advanced document management");
    setFavicon("ğŸ“„");
    addNotification("Settings reset to defaults", "info");
  };

  const formatDuration = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
      return `${hours}h ${minutes}m ${secs}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${secs}s`;
    } else {
      return `${secs}s`;
    }
  };

  const emojiOptions = [
    "ğŸ“„",
    "ğŸ ",
    "âš™ï¸",
    "ğŸ“Š",
    "ğŸ¨",
    "ğŸ”§",
    "ğŸ’¼",
    "ğŸŒŸ",
    "ğŸš€",
    "ğŸ’¡",
  ];

  return (
    <div
      style={{
        padding: "20px",
        maxWidth: "800px",
        margin: "0 auto",
        fontFamily: "Arial, sans-serif",
      }}
    >
      <div
        style={{
          background: isActive
            ? "linear-gradient(135deg, #667eea 0%, #764ba2 100%)"
            : "#6c757d",
          color: "white",
          padding: "30px",
          borderRadius: "15px",
          marginBottom: "20px",
          transition: "background 0.3s ease",
        }}
      >
        <h1 style={{ margin: "0 0 10px 0" }}>{favicon} Document Manager</h1>
        <div style={{ fontSize: "14px", opacity: 0.9 }}>
          Status: {isActive ? "ğŸŸ¢ Active" : "ğŸ”´ Inactive"} | Visit Duration:{" "}
          {formatDuration(visitDuration)}
        </div>
      </div>

      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(300px, 1fr))",
          gap: "20px",
          marginBottom: "20px",
        }}
      >
        {/* Document Settings */}
        <div
          style={{
            padding: "20px",
            border: "1px solid #ddd",
            borderRadius: "10px",
            backgroundColor: "white",
          }}
        >
          <h3 style={{ margin: "0 0 15px 0" }}>Document Settings</h3>

          <div style={{ marginBottom: "15px" }}>
            <label
              style={{
                display: "block",
                marginBottom: "5px",
                fontWeight: "bold",
              }}
            >
              Page Title:
            </label>
            <input
              type="text"
              value={pageTitle}
              onChange={(e) => setPageTitle(e.target.value)}
              style={{
                width: "100%",
                padding: "8px",
                border: "1px solid #ddd",
                borderRadius: "4px",
              }}
            />
          </div>

          <div style={{ marginBottom: "15px" }}>
            <label
              style={{
                display: "block",
                marginBottom: "5px",
                fontWeight: "bold",
              }}
            >
              Meta Description:
            </label>
            <textarea
              value={metaDescription}
              onChange={(e) => setMetaDescription(e.target.value)}
              style={{
                width: "100%",
                padding: "8px",
                border: "1px solid #ddd",
                borderRadius: "4px",
                height: "60px",
                resize: "vertical",
              }}
            />
          </div>

          <div style={{ marginBottom: "15px" }}>
            <label
              style={{
                display: "block",
                marginBottom: "5px",
                fontWeight: "bold",
              }}
            >
              Favicon:
            </label>
            <div style={{ display: "flex", gap: "8px", flexWrap: "wrap" }}>
              {emojiOptions.map((emoji) => (
                <button
                  key={emoji}
                  onClick={() => setFavicon(emoji)}
                  style={{
                    padding: "8px",
                    fontSize: "20px",
                    border:
                      favicon === emoji
                        ? "2px solid #667eea"
                        : "1px solid #ddd",
                    borderRadius: "4px",
                    backgroundColor: favicon === emoji ? "#e3f2fd" : "white",
                    cursor: "pointer",
                  }}
                >
                  {emoji}
                </button>
              ))}
            </div>
          </div>

          <div style={{ display: "flex", gap: "10px", flexWrap: "wrap" }}>
            <button
              onClick={exportSettings}
              style={{
                padding: "8px 16px",
                backgroundColor: "#28a745",
                color: "white",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
              }}
            >
              ğŸ“¤ Export Settings
            </button>
            <button
              onClick={resetSettings}
              style={{
                padding: "8px 16px",
                backgroundColor: "#dc3545",
                color: "white",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
              }}
            >
              ğŸ”„ Reset
            </button>
          </div>
        </div>

        {/* Activity Monitor */}
        <div
          style={{
            padding: "20px",
            border: "1px solid #ddd",
            borderRadius: "10px",
            backgroundColor: "white",
          }}
        >
          <h3 style={{ margin: "0 0 15px 0" }}>Activity Monitor</h3>

          <div style={{ marginBottom: "15px" }}>
            <div
              style={{
                fontSize: "24px",
                fontWeight: "bold",
                color: isActive ? "#28a745" : "#dc3545",
              }}
            >
              {isActive ? "ğŸŸ¢ Active" : "ğŸ”´ Inactive"}
            </div>
            <div style={{ fontSize: "14px", color: "#666" }}>
              Page visibility status
            </div>
          </div>

          <div style={{ marginBottom: "15px" }}>
            <div style={{ fontSize: "20px", fontWeight: "bold" }}>
              {formatDuration(visitDuration)}
            </div>
            <div style={{ fontSize: "14px", color: "#666" }}>Time on page</div>
          </div>

          <div>
            <h4 style={{ margin: "0 0 10px 0", fontSize: "16px" }}>
              Recent Activity:
            </h4>
            <div style={{ maxHeight: "120px", overflowY: "auto" }}>
              {notifications.length === 0 ? (
                <div
                  style={{
                    fontSize: "14px",
                    color: "#666",
                    fontStyle: "italic",
                  }}
                >
                  No recent activity
                </div>
              ) : (
                notifications.map((notification) => (
                  <div
                    key={notification.id}
                    style={{
                      padding: "6px 0",
                      borderBottom: "1px solid #eee",
                      fontSize: "12px",
                    }}
                  >
                    <div style={{ fontWeight: "bold" }}>
                      {notification.message}
                    </div>
                    <div style={{ color: "#666" }}>
                      {notification.timestamp}
                    </div>
                  </div>
                ))
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Keyboard Shortcuts */}
      <div
        style={{
          padding: "15px",
          backgroundColor: "#f8f9fa",
          borderRadius: "8px",
          fontSize: "12px",
        }}
      >
        <div style={{ fontWeight: "bold", marginBottom: "8px" }}>
          Keyboard Shortcuts:
        </div>
        <div
          style={{
            display: "grid",
            gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))",
            gap: "5px",
          }}
        >
          <div>â€¢ Ctrl/Cmd + 1/2/3: Change favicon</div>
          <div>â€¢ Ctrl/Cmd + D: Export settings</div>
          <div>â€¢ Ctrl/Cmd + R: Reset settings</div>
        </div>
      </div>
    </div>
  );
}

export default DocumentManager;
```

<BackToTop />

### Advanced Infinite Scroll with Virtual Loading

```javascript
import React, { useState, useEffect, useRef, useCallback } from "react";

function InfiniteScrollGallery() {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);
  const [filter, setFilter] = useState("all");
  const [searchTerm, setSearchTerm] = useState("");
  const [viewMode, setViewMode] = useState("grid");
  const observerRef = useRef();
  const loadingRef = useRef();
  const retryTimeoutRef = useRef();

  // Mock data generator
  const generateMockItems = useCallback((pageNum, itemsPerPage = 20) => {
    const categories = [
      "technology",
      "nature",
      "architecture",
      "art",
      "science",
    ];
    const colors = [
      "#FF6B6B",
      "#4ECDC4",
      "#45B7D1",
      "#96CEB4",
      "#FFEAA7",
      "#DDA0DD",
      "#98D8C8",
    ];

    return Array.from({ length: itemsPerPage }, (_, index) => {
      const id = (pageNum - 1) * itemsPerPage + index + 1;
      const category =
        categories[Math.floor(Math.random() * categories.length)];

      return {
        id,
        title: `Item ${id}: ${category.charAt(0).toUpperCase() + category.slice(1)} Sample`,
        description: `This is a detailed description for item ${id}. It contains interesting information about ${category} and related topics.`,
        category,
        image: `https://picsum.photos/300/200?random=${id}`,
        color: colors[Math.floor(Math.random() * colors.length)],
        timestamp: new Date(
          Date.now() - Math.random() * 10000000000,
        ).toISOString(),
        author: `Author ${Math.floor(Math.random() * 10) + 1}`,
        likes: Math.floor(Math.random() * 1000),
        views: Math.floor(Math.random() * 5000),
      };
    });
  }, []);

  // Fetch items with error handling and retry logic
  const fetchItems = useCallback(
    async (pageNum, reset = false) => {
      if (loading) return;

      setLoading(true);
      setError(null);

      try {
        // Simulate network delay
        await new Promise((resolve) =>
          setTimeout(resolve, 1000 + Math.random() * 1000),
        );

        // Simulate occasional errors
        if (Math.random() < 0.1) {
          throw new Error("Network error occurred");
        }

        const newItems = generateMockItems(pageNum);

        setItems((prev) => (reset ? newItems : [...prev, ...newItems]));
        setHasMore(pageNum < 10); // Limit to 10 pages for demo
      } catch (err) {
        setError(err.message);

        // Auto-retry after 3 seconds
        retryTimeoutRef.current = setTimeout(() => {
          fetchItems(pageNum, reset);
        }, 3000);
      } finally {
        setLoading(false);
      }
    },
    [loading, generateMockItems],
  );

  // Initial load
  useEffect(() => {
    fetchItems(1, true);
    setPage(1);
  }, []);

  // Intersection Observer for infinite scroll
  useEffect(() => {
    const currentObserver = observerRef.current;
    const currentLoadingRef = loadingRef.current;

    if (!currentLoadingRef) return;

    const observer = new IntersectionObserver(
      (entries) => {
        const target = entries[0];
        if (target.isIntersecting && hasMore && !loading) {
          const nextPage = page + 1;
          setPage(nextPage);
          fetchItems(nextPage);
        }
      },
      {
        threshold: 0.1,
        rootMargin: "100px",
      },
    );

    observer.observe(currentLoadingRef);
    observerRef.current = observer;

    return () => {
      if (currentObserver) {
        currentObserver.disconnect();
      }
    };
  }, [hasMore, loading, page, fetchItems]);

  // Scroll position restoration
  useEffect(() => {
    const savedScrollPosition = sessionStorage.getItem("galleryScrollPosition");
    if (savedScrollPosition) {
      window.scrollTo(0, parseInt(savedScrollPosition));
      sessionStorage.removeItem("galleryScrollPosition");
    }

    const handleScroll = () => {
      sessionStorage.setItem(
        "galleryScrollPosition",
        window.scrollY.toString(),
      );
    };

    const throttledScroll = throttle(handleScroll, 200);
    window.addEventListener("scroll", throttledScroll);

    return () => {
      window.removeEventListener("scroll", throttledScroll);
    };
  }, []);

  // Filter and search functionality
  const filteredItems = items.filter((item) => {
    const matchesFilter = filter === "all" || item.category === filter;
    const matchesSearch =
      searchTerm === "" ||
      item.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
      item.description.toLowerCase().includes(searchTerm.toLowerCase());

    return matchesFilter && matchesSearch;
  });

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (event) => {
      switch (event.key) {
        case "Home":
          event.preventDefault();
          window.scrollTo({ top: 0, behavior: "smooth" });
          break;
        case "End":
          event.preventDefault();
          window.scrollTo({
            top: document.body.scrollHeight,
            behavior: "smooth",
          });
          break;
        case "r":
          if (event.ctrlKey || event.metaKey) {
            event.preventDefault();
            handleRefresh();
          }
          break;
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  // Performance monitoring
  useEffect(() => {
    let frameCount = 0;
    let lastTime = performance.now();

    const measureFPS = () => {
      frameCount++;
      const currentTime = performance.now();

      if (currentTime - lastTime >= 1000) {
        console.log(`FPS: ${frameCount}`);
        frameCount = 0;
        lastTime = currentTime;
      }

      requestAnimationFrame(measureFPS);
    };

    const animationId = requestAnimationFrame(measureFPS);

    return () => cancelAnimationFrame(animationId);
  }, []);

  // Utility functions
  const throttle = (func, delay) => {
    let timeoutId;
    let lastExecTime = 0;

    return function (...args) {
      const currentTime = Date.now();

      if (currentTime - lastExecTime > delay) {
        func.apply(this, args);
        lastExecTime = currentTime;
      } else {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(
          () => {
            func.apply(this, args);
            lastExecTime = Date.now();
          },
          delay - (currentTime - lastExecTime),
        );
      }
    };
  };

  const handleRefresh = () => {
    setItems([]);
    setPage(1);
    setError(null);
    setHasMore(true);
    if (retryTimeoutRef.current) {
      clearTimeout(retryTimeoutRef.current);
    }
    fetchItems(1, true);
  };

  const handleRetry = () => {
    if (retryTimeoutRef.current) {
      clearTimeout(retryTimeoutRef.current);
    }
    fetchItems(page);
  };

  const categories = [
    "all",
    "technology",
    "nature",
    "architecture",
    "art",
    "science",
  ];

  return (
    <div
      style={{
        padding: "20px",
        maxWidth: "1200px",
        margin: "0 auto",
        fontFamily: "Arial, sans-serif",
      }}
    >
      {/* Header */}
      <div
        style={{
          background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
          color: "white",
          padding: "30px",
          borderRadius: "15px",
          marginBottom: "20px",
        }}
      >
        <h1 style={{ margin: "0 0 15px 0" }}>Infinite Scroll Gallery</h1>
        <div style={{ fontSize: "14px", opacity: 0.9 }}>
          {items.length} items loaded â€¢ Page {page} â€¢ {filteredItems.length}{" "}
          items shown
        </div>
      </div>

      {/* Controls */}
      <div
        style={{
          display: "flex",
          gap: "15px",
          marginBottom: "20px",
          flexWrap: "wrap",
          alignItems: "center",
        }}
      >
        <input
          type="text"
          placeholder="Search items..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          style={{
            padding: "10px",
            border: "1px solid #ddd",
            borderRadius: "6px",
            minWidth: "200px",
          }}
        />

        <select
          value={filter}
          onChange={(e) => setFilter(e.target.value)}
          style={{
            padding: "10px",
            border: "1px solid #ddd",
            borderRadius: "6px",
          }}
        >
          {categories.map((category) => (
            <option key={category} value={category}>
              {category.charAt(0).toUpperCase() + category.slice(1)}
            </option>
          ))}
        </select>

        <div style={{ display: "flex", gap: "5px" }}>
          <button
            onClick={() => setViewMode("grid")}
            style={{
              padding: "10px",
              backgroundColor: viewMode === "grid" ? "#667eea" : "#f8f9fa",
              color: viewMode === "grid" ? "white" : "#333",
              border: "1px solid #ddd",
              borderRadius: "6px",
              cursor: "pointer",
            }}
          >
            ğŸ”² Grid
          </button>
          <button
            onClick={() => setViewMode("list")}
            style={{
              padding: "10px",
              backgroundColor: viewMode === "list" ? "#667eea" : "#f8f9fa",
              color: viewMode === "list" ? "white" : "#333",
              border: "1px solid #ddd",
              borderRadius: "6px",
              cursor: "pointer",
            }}
          >
            ğŸ“‹ List
          </button>
        </div>

        <button
          onClick={handleRefresh}
          style={{
            padding: "10px 15px",
            backgroundColor: "#28a745",
            color: "white",
            border: "none",
            borderRadius: "6px",
            cursor: "pointer",
          }}
        >
          ğŸ”„ Refresh
        </button>
      </div>

      {/* Items Grid/List */}
      <div
        style={{
          display: viewMode === "grid" ? "grid" : "flex",
          gridTemplateColumns:
            viewMode === "grid"
              ? "repeat(auto-fill, minmax(300px, 1fr))"
              : "none",
          flexDirection: viewMode === "list" ? "column" : "none",
          gap: "20px",
          marginBottom: "20px",
        }}
      >
        {filteredItems.map((item) => (
          <ItemCard key={item.id} item={item} viewMode={viewMode} />
        ))}
      </div>

      {/* Loading/Error States */}
      <div ref={loadingRef} style={{ textAlign: "center", padding: "20px" }}>
        {loading && (
          <div>
            <div style={{ fontSize: "24px", marginBottom: "10px" }}>â³</div>
            <div>Loading more items...</div>
          </div>
        )}

        {error && (
          <div
            style={{
              padding: "20px",
              backgroundColor: "#ffebee",
              border: "1px solid #ffcdd2",
              borderRadius: "8px",
              color: "#c62828",
            }}
          >
            <div style={{ fontSize: "18px", marginBottom: "10px" }}>
              âŒ Error loading items
            </div>
            <div style={{ marginBottom: "15px" }}>{error}</div>
            <button
              onClick={handleRetry}
              style={{
                padding: "10px 20px",
                backgroundColor: "#dc3545",
                color: "white",
                border: "none",
                borderRadius: "6px",
                cursor: "pointer",
              }}
            >
              ğŸ”„ Retry
            </button>
          </div>
        )}

        {!hasMore && !loading && !error && (
          <div
            style={{
              padding: "20px",
              color: "#666",
              fontSize: "16px",
            }}
          >
            ğŸ‰ You've reached the end! No more items to load.
          </div>
        )}
      </div>

      {/* Footer Info */}
      <div
        style={{
          marginTop: "30px",
          padding: "15px",
          backgroundColor: "#f8f9fa",
          borderRadius: "8px",
          fontSize: "12px",
          color: "#666",
        }}
      >
        <div style={{ fontWeight: "bold", marginBottom: "8px" }}>
          Performance Features:
        </div>
        <div>â€¢ Intersection Observer for efficient scroll detection</div>
        <div>â€¢ Virtual loading with automatic retry on errors</div>
        <div>â€¢ Scroll position restoration on page refresh</div>
        <div>â€¢ Throttled scroll events for better performance</div>
        <div>â€¢ Keyboard shortcuts: Home/End keys, Ctrl+R to refresh</div>
      </div>
    </div>
  );
}

// Memoized ItemCard component
const ItemCard = React.memo(({ item, viewMode }) => {
  return (
    <div
      style={{
        border: "1px solid #ddd",
        borderRadius: "10px",
        overflow: "hidden",
        backgroundColor: "white",
        boxShadow: "0 4px 8px rgba(0,0,0,0.1)",
        transition: "transform 0.2s ease, box-shadow 0.2s ease",
        cursor: "pointer",
        display: viewMode === "list" ? "flex" : "block",
      }}
      onMouseEnter={(e) => {
        e.currentTarget.style.transform = "translateY(-2px)";
        e.currentTarget.style.boxShadow = "0 8px 16px rgba(0,0,0,0.15)";
      }}
      onMouseLeave={(e) => {
        e.currentTarget.style.transform = "translateY(0)";
        e.currentTarget.style.boxShadow = "0 4px 8px rgba(0,0,0,0.1)";
      }}
    >
      <div
        style={{
          height: viewMode === "grid" ? "200px" : "120px",
          backgroundColor: item.color,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          color: "white",
          fontSize: "18px",
          fontWeight: "bold",
          minWidth: viewMode === "list" ? "120px" : "auto",
        }}
      >
        {item.category.charAt(0).toUpperCase()}
      </div>

      <div style={{ padding: "15px", flex: viewMode === "list" ? 1 : "none" }}>
        <h3 style={{ margin: "0 0 8px 0", fontSize: "16px" }}>{item.title}</h3>
        <p
          style={{
            margin: "0 0 10px 0",
            color: "#666",
            fontSize: "14px",
            display: "-webkit-box",
            WebkitLineClamp: 2,
            WebkitBoxOrient: "vertical",
            overflow: "hidden",
          }}
        >
          {item.description}
        </p>

        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            fontSize: "12px",
            color: "#999",
          }}
        >
          <span
            style={{
              padding: "3px 8px",
              backgroundColor: item.color + "20",
              borderRadius: "12px",
              textTransform: "capitalize",
            }}
          >
            {item.category}
          </span>
          <div style={{ display: "flex", gap: "10px" }}>
            <span>ğŸ‘ {item.likes}</span>
            <span>ğŸ‘ï¸ {item.views}</span>
          </div>
        </div>
      </div>
    </div>
  );
});

export default InfiniteScrollGallery;
```

<BackToTop />

## Best Practices

- **Dependency Array**: Always specify the dependency array to avoid unnecessary re-renders and side effects. If you want the effect to run only once, pass an empty array.
- **Cleanup Functions**: Use cleanup functions to prevent memory leaks and ensure that resources are released when the component unmounts or before the effect runs again.
- **Avoid Side Effects in Render**: Do not perform side effects directly in the render method. Use `useEffect` to handle side effects after the render is complete.
- **Keep Effects Focused**: Each `useEffect` should handle a single concern or side effect. Avoid combining unrelated logic in a single effect to keep your code clean and maintainable.
- **Use Multiple Effects**: If you have multiple side effects, consider using multiple `useEffect` calls instead of combining them into one. This improves readability and separation of concerns.
  <BackToTop />
