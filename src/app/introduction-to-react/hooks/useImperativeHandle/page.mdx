import BackToTop from "@/components/BackToTop";

# useImperativeHandle

## Table of Contents

## Overview

useImperativeHandle is a React hook that allows you to customize the instance value that is exposed to parent components when using `ref`. It is particularly useful when you want to expose a specific API or methods from a child component to its parent, while still maintaining encapsulation.
It is often used in conjunction with `forwardRef` to create a component that can be controlled by its parent.

#### Benefits of `useImperativeHandle`

- **Encapsulation**: It allows you to expose only the necessary methods or properties to the parent component, keeping the internal implementation details hidden.
- **Controlled API**: You can define a controlled API for the parent component to interact with the child component, making it easier to manage complex interactions.
- **Custom Behavior**: You can define custom behavior for the exposed methods, allowing you to control how the parent interacts with the child component.

#### When to Use `useImperativeHandle`

- When you need to expose specific methods or properties from a child component to its parent.
- When you want to create a controlled API for the parent component to interact with the child component.
- When you want to maintain encapsulation while still allowing the parent component to control certain aspects of the child component.

## Common Use Cases

- **Custom Input Components**: When creating custom input components that need to expose methods like `focus`, `blur`, or `reset` to the parent component.
- **Modals and Dialogs**: When creating modal or dialog components that need to expose methods for opening, closing, or toggling visibility to the parent component.
- **Animations**: When creating components that need to expose methods for starting, stopping, or controlling animations to the parent component.

### Syntax

```javascript
import React, { useImperativeHandle, forwardRef, useRef } from "react";
const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef(null);

  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = "";
    },
  }));

  return <input ref={inputRef} {...props} />;
});
```

### Parameters

- `ref`: The ref object that will be passed to the parent component.
- `createHandle`: A function that returns an object containing the methods or properties to be exposed to the parent component. This function receives the `ref` as an argument and should return an object with the methods or properties to be exposed.

## How It Works

### Initial Render

When the component is first rendered, the `useImperativeHandle` hook is called with the `ref` and the `createHandle` function. The `createHandle` function returns an object containing the methods or properties to be exposed to the parent component.
This object is then assigned to the `ref` passed to the parent component, allowing the parent to access the exposed methods or properties.

### Updates

If the component re-renders, the `useImperativeHandle` hook will be called again with the updated `createHandle` function. If the returned object is different from the previous one, the `ref` will be updated with the new object, allowing the parent component to access the updated methods or properties.

### Cleanup

When the component is unmounted, the `useImperativeHandle` hook will clean up the `ref`, ensuring that the parent component no longer has access to the exposed methods or properties.

## What to Avoid

- Avoid exposing too many methods or properties to the parent component, as this can lead to tight coupling between the child and parent components.
- Avoid using `useImperativeHandle` for simple components that do not require exposing specific methods or properties to the parent component, as it can add unnecessary complexity.
- Avoid using `useImperativeHandle` in components that do not use `forwardRef`, as it is designed to work with `forwardRef` to allow the parent component to access the child component's instance.

  <BackToTop />

## Examples

### Custom Input Component

```javascript
import React, { useImperativeHandle, forwardRef, useRef } from "react";
const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = "";
    },
  }));
  return <input ref={inputRef} {...props} />;
});
const ParentComponent = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current.focus();
  };

  const handleClear = () => {
    inputRef.current.clear();
  };

  return (
    <div>
      <CustomInput ref={inputRef} />
      <button onClick={handleFocus}>Focus Input</button>
      <button onClick={handleClear}>Clear Input</button>
    </div>
  );
};
```

### Modal Component

```javascript
import React, { useImperativeHandle, forwardRef, useState } from "react";
const Modal = forwardRef((props, ref) => {
  const [isOpen, setIsOpen] = useState(false);
  useImperativeHandle(ref, () => ({
    open: () => {
      setIsOpen(true);
    },
    close: () => {
      setIsOpen(false);
    },
  }));
  return (
    <div style={{ display: isOpen ? "block" : "none" }}>
      <div className="modal-content">
        <span className="close" onClick={() => setIsOpen(false)}>
          &times;
        </span>
        <p>{props.children}</p>
      </div>
    </div>
  );
});
const ParentComponent = () => {
  const modalRef = useRef(null);
  const handleOpen = () => {
    modalRef.current.open();
  };
  const handleClose = () => {
    modalRef.current.close();
  };
  return (
    <div>
      <button onClick={handleOpen}>Open Modal</button>
      <Modal ref={modalRef}>
        <h2>Modal Title</h2>
        <p>This is the modal content.</p>
        <button onClick={handleClose}>Close Modal</button>
      </Modal>
    </div>
  );
};
```

## Best Practices

- Use `useImperativeHandle` only when necessary, as it can add complexity to your components.
- Keep the exposed methods or properties minimal to avoid tight coupling between the child and parent components.
- Document the exposed methods or properties clearly to help other developers understand how to use the component.
- Use `forwardRef` in conjunction with `useImperativeHandle` to allow the parent component to access the child component's instance.
  <BackToTop />
