import BackToTop from "@/components/BackToTop";

# useRef

## Table of Contents

## Overview

The `useRef` hook in React is a powerful tool that allows you to create mutable references to DOM elements or any other value that persists across renders. It is commonly used to access and manipulate DOM nodes directly, bypassing the need for state updates. This can be particularly useful for performance optimization and when you need to interact with third-party libraries that require direct DOM access.

### Benefits of `useRef`:

- **Direct DOM Access**: It allows you to access and manipulate DOM elements directly, which can be more efficient than using state for certain operations.
- **Mutable References**: The reference created by `useRef` is mutable, meaning you can change its value without triggering a re-render of the component.
- **Persistent Value**: The value stored in a `useRef` persists across renders, making it useful for storing values that do not need to trigger re-renders when changed.
- **Avoiding Re-renders**: Using `useRef` can help avoid unnecessary re-renders when you need to store a value that does not affect the rendering of the component.

### When to Use `useRef`:

- When you need to access and manipulate DOM elements directly, such as focusing an input field or measuring the size of an element.
- When you want to store a value that persists across renders but does not need to trigger a re-render when changed, such as a timer ID or a previous value.
- When you need to integrate with third-party libraries that require direct access to the DOM.

### Syntax

```javascript
import React, { useRef } from "react";
const MyComponent = () => {
  const inputRef = useRef(null);
  const handleClick = () => {
    inputRef.current.focus(); // Focus the input element
  };
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Focus Input</button>
    </div>
  );
};
export default MyComponent;
```

## Common Use Cases

- **Accessing DOM Elements**: You can use `useRef` to get a reference to a DOM element and perform actions like focusing an input field, scrolling to an element, or measuring its dimensions.
- **Storing Previous Values**: You can use `useRef` to keep track of previous values without triggering re-renders. This is useful for comparing current and previous props or state values.
- **Integrating with Third-Party Libraries**: When working with libraries that require direct DOM manipulation, such as D3.js or jQuery, `useRef` provides a way to access the DOM nodes directly without interfering with React's rendering process.

## How It Works

The `useRef` hook returns a mutable object with a `current` property. You can assign a value to `current`, and it will persist across renders without causing the component to re-render. When you assign a DOM element to `current`, you can access its properties and methods directly.

## What to Avoid

- **Avoid Using `useRef` for State Management**: While `useRef` can store values, it should not be used as a replacement for state management. If you need to trigger re-renders based on changes to a value, use `useState` instead.
- **Avoid Overusing `useRef`**: While `useRef` is powerful, it should be used judiciously. Overusing it can lead to code that is harder to understand and maintain. Use it primarily for cases where direct DOM access is necessary or when you need to store values that do not affect rendering.
- **Avoid Mutating the `current` Property Directly**: While the `current` property is mutable, avoid mutating it directly in a way that could lead to unexpected behavior. Always use the `current` property to access and manipulate the value safely.
  <BackToTop />

## Examples

### Accessing a DOM Element

```javascript
import React, { useRef } from "react";
const TimerComponent = () => {
  const timerRef = useRef(null);
  const startTimer = () => {
    timerRef.current = setInterval(() => {
      console.log("Timer running");
    }, 1000);
  };
  const stopTimer = () => {
    clearInterval(timerRef.current);
    timerRef.current = null;
  };
  return (
    <div>
      <button onClick={startTimer}>Start Timer</button>
      <button onClick={stopTimer}>Stop Timer</button>
    </div>
  );
};
export default TimerComponent;
```

  <BackToTop />
### Storing Previous Values
```javascript
import React, { useState, useRef, useEffect } from "react";
const PreviousValueComponent = ({ value }) => {
  const prevValueRef = useRef();
  useEffect(() => {
    prevValueRef.current = value; // Store the current value in the ref
  }, [value]);
  const prevValue = prevValueRef.current; // Access the previous value
  return (
    <div>
      <p>Current Value: {value}</p>
      <p>Previous Value: {prevValue}</p>
    </div>
  );
};
export default PreviousValueComponent;
```
  <BackToTop />
### Integrating with Third-Party Libraries
```javascript
import React, { useRef, useEffect } from "react";
const ChartComponent = () => {
  const chartRef = useRef(null);
  useEffect(() => {
    const chart = new Chart(chartRef.current, {
      type: "line",
      data: {
        labels: ["January", "February", "March"],
        datasets: [
          {
            label: "My Dataset",
            data: [65, 59, 80],
            fill: false,
            borderColor: "rgb(75, 192, 192)",
            tension: 0.1,
          },
        ],
      },
    });
    return () => {
      chart.destroy(); // Clean up the chart instance on unmount
    };
  }, []);
  return <canvas ref={chartRef} />;
};
export default ChartComponent;
```
  <BackToTop />

## Best Practices

- **Use `useRef` for Direct DOM Access**: Use `useRef` when you need to access and manipulate DOM elements directly, such as focusing an input field or measuring an element's dimensions.
- **Store Non-Rendering Values**: Use `useRef` to store values that do not need to trigger re-renders, such as timers, previous values, or references to third-party library instances.
- **Avoid Overusing `useRef`**: Use `useRef` judiciously. Overusing it can lead to code that is harder to understand and maintain.
- **Clean Up References**: If you create references to DOM elements or third-party library instances, ensure to clean them up properly in the component's cleanup function to avoid memory leaks or unexpected behavior.
- **Use `useRef` for Performance Optimization**: When you need to access a value that does not affect rendering, use `useRef` to avoid unnecessary re-renders and improve performance.
- **Combine with Other Hooks**: You can combine `useRef` with other hooks like `useState` and `useEffect` to manage complex interactions and side effects in your components.

  <BackToTop />
