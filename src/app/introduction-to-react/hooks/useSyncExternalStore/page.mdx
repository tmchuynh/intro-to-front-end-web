import BackToTop from "@/components/BackToTop";

# useSyncExternalStore

## Table of Contents

## Overview

The `useSyncExternalStore` hook in React is designed to subscribe to external stores and ensure that your component re-renders when the store's state changes. This hook is particularly useful for integrating with state management libraries or custom stores that need to notify React components about updates.

### Benefits of `useSyncExternalStore`:

- **Synchronization**: It ensures that your component's state is always in sync with the external store, preventing inconsistencies between the UI and the underlying data.
- **Performance**: By subscribing to external stores, you can optimize performance by avoiding unnecessary re-renders and only updating the component when the store's state changes.
- **Flexibility**: It allows you to work with various types of external stores, whether they are custom implementations or third-party libraries, making it a versatile tool for managing state in React applications.

### When to Use `useSyncExternalStore`:

- When you need to integrate with external state management libraries or custom stores that provide a subscription mechanism.
- When you want to ensure that your component re-renders only when the external store's state changes, improving performance and reducing unnecessary updates.
- When you need to manage complex state interactions that involve multiple components or external data sources.

### Syntax

```javascript
import React, { useSyncExternalStore } from "react";
const useMyStore = (subscribe, getSnapshot) => {
  return useSyncExternalStore(subscribe, getSnapshot);
};
```

### Parameters

- `subscribe`: A function that registers a callback to be called when the external store's state changes. This function should return an unsubscribe function to clean up the subscription.
- `getSnapshot`: A function that retrieves the current state of the external store. This function is called to get the initial state and whenever the store updates.

### Return Value

- The current state of the external store, which can be used in your component to render the UI based on the store's data.

## Common Use Cases

- **Integrating with Redux**: Use `useSyncExternalStore` to subscribe to a Redux store and get the current state, ensuring that your component re-renders when the Redux state changes.
- **Custom State Management**: Implement your own state management solution using `useSyncExternalStore` to manage complex state interactions between multiple components or external data sources.
- **Third-Party Libraries**: Integrate with third-party libraries that provide a subscription mechanism, such as MobX or Zustand, to keep your component in sync with the external store's state.

## How It Works

The `useSyncExternalStore` hook works by subscribing to an external store and retrieving its current state. When the store's state changes, the provided `subscribe` function is called, triggering a re-render of the component with the updated state. The `getSnapshot` function is used to get the current state of the store, ensuring that the component always has the latest data.

## What to Avoid

- **Avoid Using `useSyncExternalStore` for Local State**: This hook is specifically designed for external stores. For managing local component state, use `useState` or `useReducer`.
- **Avoid Overusing Subscriptions**: Subscribing to too many external stores can lead to performance issues. Only subscribe to the stores that are necessary for your component's functionality.
- **Avoid Blocking the Main Thread**: Ensure that the `subscribe` and `getSnapshot` functions are efficient and do not block the main thread, as this can lead to performance degradation and a poor user experience.
  <BackToTop />

## Examples

### Simple Counter Example

```javascript
import React, { useSyncExternalStore } from "react";
// Example of a custom store
const myStore = {
  state: { count: 0 },
  listeners: new Set(),
  subscribe(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  },
  getSnapshot() {
    return this.state;
  },
  increment() {
    this.state.count += 1;
    this.listeners.forEach((callback) => callback());
  },
};
const Counter = () => {
  const state = useSyncExternalStore(
    myStore.subscribe.bind(myStore),
    myStore.getSnapshot.bind(myStore)
  );

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => myStore.increment()}>Increment</button>
    </div>
  );
};
export default Counter;
```

<BackToTop />

## Best Practices

- **Use Stable Functions**: Ensure that the `subscribe` and `getSnapshot` functions are stable and do not change on every render. This helps prevent unnecessary re-renders and improves performance.
- **Clean Up Subscriptions**: Always return an unsubscribe function from the `subscribe` method to clean up subscriptions when the component unmounts or when the store changes. This prevents memory leaks and ensures that your component does not receive updates from stale subscriptions.
- **Optimize Performance**: Use memoization techniques, such as `React.memo` or `useMemo`, to optimize performance when rendering components that use `useSyncExternalStore`. This can help reduce unnecessary re-renders and improve the overall performance of your application.
- **Test Your Implementation**: Ensure that your implementation of `useSyncExternalStore` works correctly by writing tests that verify the subscription and state retrieval logic. This helps catch any issues early and ensures that your component behaves as expected when the external store's state changes.
- **Document Your Store**: If you are creating a custom store, document its API and usage clearly. This will help other developers understand how to use the store and integrate it with `useSyncExternalStore` effectively.
- **Use TypeScript for Type Safety**: If you are using TypeScript, define types for your store's state and the `subscribe` and `getSnapshot` functions. This provides type safety and helps catch errors during development, making your code more robust and maintainable.
- **Avoid Side Effects in `getSnapshot`**: Ensure that the `getSnapshot` function does not have side effects. It should only return the current state of the store without modifying any external data or triggering additional updates. This helps maintain the purity of the function and ensures predictable behavior.
- **Keep the Store Simple**: When implementing a custom store, keep it simple and focused on managing state. Avoid adding complex logic or side effects within the store itself. Instead, handle side effects in the components that use the store or in separate hooks. This separation of concerns makes your code easier to understand and maintain.
- **Use React DevTools**: Leverage React DevTools to inspect the state of your components and the external store. This can help you debug issues related to state synchronization and ensure that your components are receiving the correct data from the store.
- **Monitor Performance**: Use performance monitoring tools to track the performance of your components that use `useSyncExternalStore`. This can help you identify any performance bottlenecks and optimize your implementation accordingly.
- **Follow React's Best Practices**: Always follow React's best practices for component design and state management. This includes using functional components, avoiding unnecessary state updates, and keeping your components as stateless as possible. By adhering to these principles, you can ensure that your components are efficient, maintainable, and easy to understand.
- **Stay Updated**: Keep an eye on updates to React and the `useSyncExternalStore` hook. As React evolves, new features and improvements may be introduced that can enhance your implementation or provide new capabilities. Staying updated with the latest changes ensures that you can take advantage of new features and best practices in your applications.
- **Use Context for Global State**: If you need to share the external store's state across multiple components, consider using React's Context API in conjunction with `useSyncExternalStore`. This allows you to provide the store's state to a wider range of components without having to pass props down through multiple levels of the component tree. It also helps keep your components decoupled and easier to manage.
- **Handle Errors Gracefully**: Implement error handling in your `subscribe` and `getSnapshot` functions to gracefully handle any issues that may arise when interacting with the external store. This can include logging errors, displaying error messages to users, or providing fallback UI in case of failures. Proper error handling ensures that your application remains robust and user-friendly, even in the face of unexpected issues.
- **Use Custom Hooks for Reusability**: If you find yourself using `useSyncExternalStore` frequently across different components, consider creating a custom hook that encapsulates the logic for subscribing to the external store and retrieving its state. This promotes code reuse and makes your components cleaner and easier to read. Custom hooks can also help you manage complex state interactions and encapsulate related logic, making your codebase more organized and maintainable.
- **Test with Different Store States**: When writing tests for components that use `useSyncExternalStore`, ensure that you test with various states of the external store. This includes testing initial states, updates, and edge cases. By covering a wide range of scenarios, you can ensure that your components behave correctly under different conditions and that the synchronization with the external store works as expected. This thorough testing helps catch potential bugs and ensures that your implementation is robust and reliable.
- **Document Your Custom Store**: If you create a custom store, document its API and usage clearly. This will help other developers understand how to use the store and integrate it with `useSyncExternalStore` effectively. Clear documentation can also serve as a reference for future maintenance and updates, ensuring that your store remains easy to use and understand over time. Include examples of how to subscribe to the store, retrieve its state, and handle updates, as well as any specific behaviors or conventions that users should be aware of when working with your custom store.
  <BackToTop />
