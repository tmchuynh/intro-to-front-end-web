import BackToTop from "@/components/BackToTop";

# useReducer

## Table of Contents

## Overview

useReducer is a React hook that allows you to manage complex state logic in your components. It is particularly useful when dealing with state that involves multiple sub-values or when the next state depends on the previous one. useReducer provides a way to encapsulate state management logic in a reducer function, making it easier to understand and maintain.

### Benefits of `useReducer`:

- Centralized State Management: It allows you to manage state in a single place, making it easier to reason about state changes.
- Predictable State Transitions: The reducer function defines how the state transitions occur, making it easier to track changes and debug issues.
- Separation of Concerns: It separates state management logic from the component logic, promoting cleaner and more maintainable code.
- Performance Optimization: It can help optimize performance by preventing unnecessary re-renders when state changes are localized to specific parts of the state.

#### When to Use `useReducer`:

- When you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.
- When you want to encapsulate state management logic in a reducer function for better organization and maintainability.
- When you need to manage state that is shared across multiple components or when you want to avoid prop drilling.
- When you want to optimize performance by preventing unnecessary re-renders.

### Syntax

```javascript
import React, { useReducer } from "react";
const initialState = { count: 0 };
const reducer = (state, action) => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
};
const MyComponent = () => {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>Increment</button>
      <button onClick={() => dispatch({ type: "decrement" })}>Decrement</button>
    </div>
  );
};
```

### Parameters

- `reducer`: A function that takes the current state and an action, and returns the next state. The reducer function defines how the state transitions occur based on the action type.
- `initialState`: The initial state value for the reducer. This is the state that will be used when the component first renders.
- `init` (optional): A function that takes the initial state and returns the initial state value. This can be used to compute the initial state based on some logic or to initialize the state from a more complex structure.
- `state`: The current state value managed by the reducer. This is the state that will be used in the component.
- `dispatch`: A function that takes an action and dispatches it to the reducer. This function is used to trigger state transitions by sending actions to the reducer.

### Returns

- An array containing the current state and the dispatch function. The current state is the value managed by the reducer, and the dispatch function is used to trigger state transitions by sending actions to the reducer.

## Common Use Cases

- Counter: Managing a simple counter state with increment and decrement actions.
- Form State: Managing complex form state with multiple fields and validation logic.
- Toggle State: Managing toggle states for UI components like modals or dropdowns.
- List Management: Managing a list of items with actions to add, remove, or update items in the list.
- Complex State Logic: Managing state that involves multiple sub-values or when the next state depends on the previous one, such as managing a shopping cart with multiple items and actions to add, remove, or update items in the cart.

## How It Works

1. **Reducer Function**: The reducer function defines how the state transitions occur based on the action type. It takes the current state and an action, and returns the next state.
2. **Initial State**: The initial state is provided as the second argument to the `useReducer` hook. This is the state that will be used when the component first renders.
3. **Dispatch Function**: The `dispatch` function is used to trigger state transitions by sending actions to the reducer. When an action is dispatched, the reducer function is called with the current state and the action, and it returns the next state.
4. **State Updates**: When the state is updated, the component re-renders with the new state value. The `useReducer` hook ensures that the component only re-renders when the state changes, optimizing performance by preventing unnecessary re-renders.

## What to Avoid

- Avoid Overusing: While `useReducer` is powerful, it can add complexity to your codebase. Use it when necessary, but don't overuse it for simple state management tasks.
- Avoid Mutating State: Always return a new state object from the reducer function. Mutating the state directly can lead to unexpected behavior and bugs.
- Avoid Side Effects in Reducer: The reducer function should be pure and not contain side effects. Side effects should be handled in a separate function or using the `useEffect` hook.
- Avoid Deeply Nested State: While `useReducer` can handle complex state, deeply nested state can make it difficult to manage and reason about. Consider flattening the state structure or using multiple reducers for different parts of the state.
  <BackToTop />

## Examples

### Multi-Step Form Wizard with Validation

```javascript
import React, { useReducer, useEffect } from "react";

// Action types
const FORM_ACTIONS = {
  SET_STEP: "SET_STEP",
  UPDATE_FIELD: "UPDATE_FIELD",
  SET_VALIDATION_ERRORS: "SET_VALIDATION_ERRORS",
  SET_LOADING: "SET_LOADING",
  SET_SUBMISSION_STATUS: "SET_SUBMISSION_STATUS",
  RESET_FORM: "RESET_FORM",
  SAVE_DRAFT: "SAVE_DRAFT",
  LOAD_DRAFT: "LOAD_DRAFT",
};

const initialFormState = {
  currentStep: 1,
  totalSteps: 4,
  data: {
    // Step 1: Personal Info
    firstName: "",
    lastName: "",
    email: "",
    phone: "",

    // Step 2: Address
    street: "",
    city: "",
    state: "",
    zipCode: "",
    country: "US",

    // Step 3: Preferences
    newsletter: false,
    notifications: {
      email: true,
      sms: false,
      push: true,
    },
    interests: [],

    // Step 4: Review
    agreedToTerms: false,
    marketingConsent: false,
  },
  validationErrors: {},
  isLoading: false,
  submissionStatus: null, // 'success', 'error', null
  draftSaved: false,
  lastSaved: null,
};

const formReducer = (state, action) => {
  switch (action.type) {
    case FORM_ACTIONS.SET_STEP:
      return {
        ...state,
        currentStep: Math.max(1, Math.min(action.payload, state.totalSteps)),
        validationErrors: {}, // Clear errors when changing steps
      };

    case FORM_ACTIONS.UPDATE_FIELD:
      const { field, value } = action.payload;
      const newData = { ...state.data };

      // Handle nested fields (e.g., notifications.email)
      if (field.includes(".")) {
        const [parent, child] = field.split(".");
        newData[parent] = { ...newData[parent], [child]: value };
      } else if (field === "interests") {
        // Handle array fields
        const currentInterests = newData.interests || [];
        newData.interests = currentInterests.includes(value)
          ? currentInterests.filter((interest) => interest !== value)
          : [...currentInterests, value];
      } else {
        newData[field] = value;
      }

      return {
        ...state,
        data: newData,
        draftSaved: false,
        // Clear field-specific validation errors
        validationErrors: {
          ...state.validationErrors,
          [field]: null,
        },
      };

    case FORM_ACTIONS.SET_VALIDATION_ERRORS:
      return {
        ...state,
        validationErrors: action.payload,
      };

    case FORM_ACTIONS.SET_LOADING:
      return {
        ...state,
        isLoading: action.payload,
      };

    case FORM_ACTIONS.SET_SUBMISSION_STATUS:
      return {
        ...state,
        submissionStatus: action.payload,
        isLoading: false,
      };

    case FORM_ACTIONS.SAVE_DRAFT:
      return {
        ...state,
        draftSaved: true,
        lastSaved: new Date().toISOString(),
      };

    case FORM_ACTIONS.LOAD_DRAFT:
      return {
        ...state,
        data: { ...state.data, ...action.payload },
        draftSaved: true,
      };

    case FORM_ACTIONS.RESET_FORM:
      return {
        ...initialFormState,
        currentStep: action.payload?.step || 1,
      };

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
};

const MultiStepFormWizard = () => {
  const [formState, dispatch] = useReducer(formReducer, initialFormState);

  // Auto-save draft every 30 seconds
  useEffect(() => {
    if (!formState.draftSaved && !formState.isLoading) {
      const timer = setTimeout(() => {
        localStorage.setItem("formDraft", JSON.stringify(formState.data));
        dispatch({ type: FORM_ACTIONS.SAVE_DRAFT });
      }, 30000);

      return () => clearTimeout(timer);
    }
  }, [formState.data, formState.draftSaved, formState.isLoading]);

  // Load draft on component mount
  useEffect(() => {
    const savedDraft = localStorage.getItem("formDraft");
    if (savedDraft) {
      try {
        const draftData = JSON.parse(savedDraft);
        dispatch({ type: FORM_ACTIONS.LOAD_DRAFT, payload: draftData });
      } catch (error) {
        console.error("Failed to load draft:", error);
      }
    }
  }, []);

  const validateStep = (step) => {
    const errors = {};
    const { data } = formState;

    switch (step) {
      case 1:
        if (!data.firstName.trim()) errors.firstName = "First name is required";
        if (!data.lastName.trim()) errors.lastName = "Last name is required";
        if (!data.email.trim()) {
          errors.email = "Email is required";
        } else if (!/\S+@\S+\.\S+/.test(data.email)) {
          errors.email = "Email is invalid";
        }
        break;

      case 2:
        if (!data.street.trim()) errors.street = "Street address is required";
        if (!data.city.trim()) errors.city = "City is required";
        if (!data.state.trim()) errors.state = "State is required";
        if (!data.zipCode.trim()) {
          errors.zipCode = "ZIP code is required";
        } else if (!/^\d{5}(-\d{4})?$/.test(data.zipCode)) {
          errors.zipCode = "Invalid ZIP code format";
        }
        break;

      case 3:
        if (data.interests.length === 0) {
          errors.interests = "Please select at least one interest";
        }
        break;

      case 4:
        if (!data.agreedToTerms) {
          errors.agreedToTerms = "You must agree to the terms and conditions";
        }
        break;
    }

    return errors;
  };

  const handleNext = () => {
    const errors = validateStep(formState.currentStep);
    if (Object.keys(errors).length > 0) {
      dispatch({ type: FORM_ACTIONS.SET_VALIDATION_ERRORS, payload: errors });
      return;
    }

    dispatch({
      type: FORM_ACTIONS.SET_STEP,
      payload: formState.currentStep + 1,
    });
  };

  const handlePrevious = () => {
    dispatch({
      type: FORM_ACTIONS.SET_STEP,
      payload: formState.currentStep - 1,
    });
  };

  const handleSubmit = async () => {
    const errors = validateStep(4);
    if (Object.keys(errors).length > 0) {
      dispatch({ type: FORM_ACTIONS.SET_VALIDATION_ERRORS, payload: errors });
      return;
    }

    dispatch({ type: FORM_ACTIONS.SET_LOADING, payload: true });

    try {
      // Simulate API submission
      await new Promise((resolve, reject) => {
        setTimeout(() => {
          Math.random() > 0.8
            ? reject(new Error("Submission failed"))
            : resolve();
        }, 2000);
      });

      dispatch({
        type: FORM_ACTIONS.SET_SUBMISSION_STATUS,
        payload: "success",
      });
      localStorage.removeItem("formDraft"); // Clear draft on successful submission
    } catch (error) {
      dispatch({ type: FORM_ACTIONS.SET_SUBMISSION_STATUS, payload: "error" });
    }
  };

  const updateField = (field, value) => {
    dispatch({
      type: FORM_ACTIONS.UPDATE_FIELD,
      payload: { field, value },
    });
  };

  const renderStep = () => {
    const { currentStep, data, validationErrors } = formState;

    switch (currentStep) {
      case 1:
        return (
          <div className="form-step">
            <h3>Personal Information</h3>
            <div className="form-group">
              <label>First Name *</label>
              <input
                type="text"
                value={data.firstName}
                onChange={(e) => updateField("firstName", e.target.value)}
                className={validationErrors.firstName ? "error" : ""}
              />
              {validationErrors.firstName && (
                <span className="error-message">
                  {validationErrors.firstName}
                </span>
              )}
            </div>

            <div className="form-group">
              <label>Last Name *</label>
              <input
                type="text"
                value={data.lastName}
                onChange={(e) => updateField("lastName", e.target.value)}
                className={validationErrors.lastName ? "error" : ""}
              />
              {validationErrors.lastName && (
                <span className="error-message">
                  {validationErrors.lastName}
                </span>
              )}
            </div>

            <div className="form-group">
              <label>Email *</label>
              <input
                type="email"
                value={data.email}
                onChange={(e) => updateField("email", e.target.value)}
                className={validationErrors.email ? "error" : ""}
              />
              {validationErrors.email && (
                <span className="error-message">{validationErrors.email}</span>
              )}
            </div>

            <div className="form-group">
              <label>Phone</label>
              <input
                type="tel"
                value={data.phone}
                onChange={(e) => updateField("phone", e.target.value)}
              />
            </div>
          </div>
        );

      case 2:
        return (
          <div className="form-step">
            <h3>Address Information</h3>
            <div className="form-group">
              <label>Street Address *</label>
              <input
                type="text"
                value={data.street}
                onChange={(e) => updateField("street", e.target.value)}
                className={validationErrors.street ? "error" : ""}
              />
              {validationErrors.street && (
                <span className="error-message">{validationErrors.street}</span>
              )}
            </div>

            <div className="form-row">
              <div className="form-group">
                <label>City *</label>
                <input
                  type="text"
                  value={data.city}
                  onChange={(e) => updateField("city", e.target.value)}
                  className={validationErrors.city ? "error" : ""}
                />
                {validationErrors.city && (
                  <span className="error-message">{validationErrors.city}</span>
                )}
              </div>

              <div className="form-group">
                <label>State *</label>
                <input
                  type="text"
                  value={data.state}
                  onChange={(e) => updateField("state", e.target.value)}
                  className={validationErrors.state ? "error" : ""}
                />
                {validationErrors.state && (
                  <span className="error-message">
                    {validationErrors.state}
                  </span>
                )}
              </div>

              <div className="form-group">
                <label>ZIP Code *</label>
                <input
                  type="text"
                  value={data.zipCode}
                  onChange={(e) => updateField("zipCode", e.target.value)}
                  className={validationErrors.zipCode ? "error" : ""}
                />
                {validationErrors.zipCode && (
                  <span className="error-message">
                    {validationErrors.zipCode}
                  </span>
                )}
              </div>
            </div>
          </div>
        );

      case 3:
        return (
          <div className="form-step">
            <h3>Preferences</h3>

            <div className="form-group">
              <label>
                <input
                  type="checkbox"
                  checked={data.newsletter}
                  onChange={(e) => updateField("newsletter", e.target.checked)}
                />
                Subscribe to newsletter
              </label>
            </div>

            <div className="form-group">
              <h4>Notification Preferences</h4>
              <label>
                <input
                  type="checkbox"
                  checked={data.notifications.email}
                  onChange={(e) =>
                    updateField("notifications.email", e.target.checked)
                  }
                />
                Email notifications
              </label>
              <label>
                <input
                  type="checkbox"
                  checked={data.notifications.sms}
                  onChange={(e) =>
                    updateField("notifications.sms", e.target.checked)
                  }
                />
                SMS notifications
              </label>
              <label>
                <input
                  type="checkbox"
                  checked={data.notifications.push}
                  onChange={(e) =>
                    updateField("notifications.push", e.target.checked)
                  }
                />
                Push notifications
              </label>
            </div>

            <div className="form-group">
              <h4>Interests *</h4>
              {["Technology", "Sports", "Music", "Travel", "Food", "Books"].map(
                (interest) => (
                  <label key={interest}>
                    <input
                      type="checkbox"
                      checked={data.interests.includes(interest)}
                      onChange={() => updateField("interests", interest)}
                    />
                    {interest}
                  </label>
                ),
              )}
              {validationErrors.interests && (
                <span className="error-message">
                  {validationErrors.interests}
                </span>
              )}
            </div>
          </div>
        );

      case 4:
        return (
          <div className="form-step">
            <h3>Review & Submit</h3>

            <div className="review-section">
              <h4>Personal Information</h4>
              <p>
                <strong>Name:</strong> {data.firstName} {data.lastName}
              </p>
              <p>
                <strong>Email:</strong> {data.email}
              </p>
              {data.phone && (
                <p>
                  <strong>Phone:</strong> {data.phone}
                </p>
              )}
            </div>

            <div className="review-section">
              <h4>Address</h4>
              <p>{data.street}</p>
              <p>
                {data.city}, {data.state} {data.zipCode}
              </p>
            </div>

            <div className="review-section">
              <h4>Preferences</h4>
              <p>
                <strong>Newsletter:</strong> {data.newsletter ? "Yes" : "No"}
              </p>
              <p>
                <strong>Interests:</strong> {data.interests.join(", ")}
              </p>
            </div>

            <div className="form-group">
              <label>
                <input
                  type="checkbox"
                  checked={data.agreedToTerms}
                  onChange={(e) =>
                    updateField("agreedToTerms", e.target.checked)
                  }
                />
                I agree to the terms and conditions *
              </label>
              {validationErrors.agreedToTerms && (
                <span className="error-message">
                  {validationErrors.agreedToTerms}
                </span>
              )}
            </div>

            <div className="form-group">
              <label>
                <input
                  type="checkbox"
                  checked={data.marketingConsent}
                  onChange={(e) =>
                    updateField("marketingConsent", e.target.checked)
                  }
                />
                I consent to receiving marketing communications
              </label>
            </div>
          </div>
        );

      default:
        return null;
    }
  };

  if (formState.submissionStatus === "success") {
    return (
      <div className="success-message">
        <h2>✅ Form Submitted Successfully!</h2>
        <p>Thank you for your submission. We'll be in touch soon.</p>
        <button onClick={() => dispatch({ type: FORM_ACTIONS.RESET_FORM })}>
          Submit Another Form
        </button>
      </div>
    );
  }

  return (
    <div className="multi-step-form">
      <div className="form-header">
        <h2>Registration Form</h2>
        <div className="progress-bar">
          <div
            className="progress"
            style={{
              width: `${(formState.currentStep / formState.totalSteps) * 100}%`,
            }}
          />
        </div>
        <p>
          Step {formState.currentStep} of {formState.totalSteps}
        </p>

        {formState.draftSaved && formState.lastSaved && (
          <div className="draft-status">
            💾 Draft saved at{" "}
            {new Date(formState.lastSaved).toLocaleTimeString()}
          </div>
        )}
      </div>

      {renderStep()}

      {formState.submissionStatus === "error" && (
        <div className="error-message">
          ❌ Submission failed. Please try again.
        </div>
      )}

      <div className="form-navigation">
        {formState.currentStep > 1 && (
          <button
            onClick={handlePrevious}
            disabled={formState.isLoading}
            className="btn-secondary"
          >
            Previous
          </button>
        )}

        {formState.currentStep < formState.totalSteps ? (
          <button
            onClick={handleNext}
            disabled={formState.isLoading}
            className="btn-primary"
          >
            Next
          </button>
        ) : (
          <button
            onClick={handleSubmit}
            disabled={formState.isLoading}
            className="btn-submit"
          >
            {formState.isLoading ? "Submitting..." : "Submit Form"}
          </button>
        )}
      </div>
    </div>
  );
};
```

<BackToTop />

### Advanced Shopping Cart Management

```javascript
import React, { useReducer, useContext, createContext } from "react";

// Cart action types
const CART_ACTIONS = {
  ADD_ITEM: "ADD_ITEM",
  REMOVE_ITEM: "REMOVE_ITEM",
  UPDATE_QUANTITY: "UPDATE_QUANTITY",
  APPLY_COUPON: "APPLY_COUPON",
  REMOVE_COUPON: "REMOVE_COUPON",
  SET_SHIPPING: "SET_SHIPPING",
  SET_TAX_RATE: "SET_TAX_RATE",
  CLEAR_CART: "CLEAR_CART",
  SET_LOADING: "SET_LOADING",
  SET_ERROR: "SET_ERROR",
  BULK_UPDATE: "BULK_UPDATE",
};

const initialCartState = {
  items: [],
  coupon: null,
  shippingMethod: null,
  taxRate: 0.08, // 8% tax
  loading: false,
  error: null,
  metadata: {
    lastUpdated: null,
    itemCount: 0,
    totalWeight: 0,
  },
};

const cartReducer = (state, action) => {
  switch (action.type) {
    case CART_ACTIONS.ADD_ITEM: {
      const { product, quantity = 1, customizations = {} } = action.payload;
      const existingItemIndex = state.items.findIndex(
        (item) =>
          item.id === product.id &&
          JSON.stringify(item.customizations) ===
            JSON.stringify(customizations),
      );

      let newItems;
      if (existingItemIndex >= 0) {
        // Update existing item
        newItems = state.items.map((item, index) =>
          index === existingItemIndex
            ? { ...item, quantity: item.quantity + quantity }
            : item,
        );
      } else {
        // Add new item
        const newItem = {
          id: product.id,
          name: product.name,
          price: product.price,
          quantity,
          customizations,
          weight: product.weight || 0,
          category: product.category,
          addedAt: new Date().toISOString(),
        };
        newItems = [...state.items, newItem];
      }

      return {
        ...state,
        items: newItems,
        metadata: {
          ...state.metadata,
          lastUpdated: new Date().toISOString(),
          itemCount: newItems.reduce((sum, item) => sum + item.quantity, 0),
          totalWeight: newItems.reduce(
            (sum, item) => sum + item.weight * item.quantity,
            0,
          ),
        },
      };
    }

    case CART_ACTIONS.REMOVE_ITEM: {
      const newItems = state.items.filter(
        (item) => item.id !== action.payload.itemId,
      );
      return {
        ...state,
        items: newItems,
        metadata: {
          ...state.metadata,
          lastUpdated: new Date().toISOString(),
          itemCount: newItems.reduce((sum, item) => sum + item.quantity, 0),
          totalWeight: newItems.reduce(
            (sum, item) => sum + item.weight * item.quantity,
            0,
          ),
        },
      };
    }

    case CART_ACTIONS.UPDATE_QUANTITY: {
      const { itemId, quantity } = action.payload;

      if (quantity <= 0) {
        // Remove item if quantity is 0 or negative
        return cartReducer(state, {
          type: CART_ACTIONS.REMOVE_ITEM,
          payload: { itemId },
        });
      }

      const newItems = state.items.map((item) =>
        item.id === itemId ? { ...item, quantity } : item,
      );

      return {
        ...state,
        items: newItems,
        metadata: {
          ...state.metadata,
          lastUpdated: new Date().toISOString(),
          itemCount: newItems.reduce((sum, item) => sum + item.quantity, 0),
          totalWeight: newItems.reduce(
            (sum, item) => sum + item.weight * item.quantity,
            0,
          ),
        },
      };
    }

    case CART_ACTIONS.APPLY_COUPON: {
      const { coupon } = action.payload;
      return {
        ...state,
        coupon: {
          code: coupon.code,
          type: coupon.type, // 'percentage' or 'fixed'
          value: coupon.value,
          minOrderAmount: coupon.minOrderAmount || 0,
          appliedAt: new Date().toISOString(),
        },
      };
    }

    case CART_ACTIONS.REMOVE_COUPON:
      return {
        ...state,
        coupon: null,
      };

    case CART_ACTIONS.SET_SHIPPING: {
      const { method } = action.payload;
      return {
        ...state,
        shippingMethod: method,
      };
    }

    case CART_ACTIONS.SET_TAX_RATE:
      return {
        ...state,
        taxRate: action.payload.rate,
      };

    case CART_ACTIONS.CLEAR_CART:
      return {
        ...initialCartState,
        taxRate: state.taxRate, // Preserve tax rate
      };

    case CART_ACTIONS.SET_LOADING:
      return {
        ...state,
        loading: action.payload,
      };

    case CART_ACTIONS.SET_ERROR:
      return {
        ...state,
        error: action.payload,
        loading: false,
      };

    case CART_ACTIONS.BULK_UPDATE: {
      const { updates } = action.payload;
      let newItems = [...state.items];

      updates.forEach((update) => {
        const itemIndex = newItems.findIndex(
          (item) => item.id === update.itemId,
        );
        if (itemIndex >= 0) {
          if (update.quantity <= 0) {
            newItems.splice(itemIndex, 1);
          } else {
            newItems[itemIndex] = {
              ...newItems[itemIndex],
              quantity: update.quantity,
            };
          }
        }
      });

      return {
        ...state,
        items: newItems,
        metadata: {
          ...state.metadata,
          lastUpdated: new Date().toISOString(),
          itemCount: newItems.reduce((sum, item) => sum + item.quantity, 0),
          totalWeight: newItems.reduce(
            (sum, item) => sum + item.weight * item.quantity,
            0,
          ),
        },
      };
    }

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
};

// Create context for cart
const CartContext = createContext();

export const CartProvider = ({ children }) => {
  const [cartState, dispatch] = useReducer(cartReducer, initialCartState);

  // Calculate derived values
  const subtotal = cartState.items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0,
  );

  const discountAmount = cartState.coupon
    ? cartState.coupon.type === "percentage"
      ? subtotal * (cartState.coupon.value / 100)
      : cartState.coupon.value
    : 0;

  const discountedSubtotal = Math.max(0, subtotal - discountAmount);

  const shippingCost = cartState.shippingMethod
    ? cartState.shippingMethod.cost
    : 0;

  const taxAmount = discountedSubtotal * cartState.taxRate;
  const total = discountedSubtotal + shippingCost + taxAmount;

  // Action creators
  const addItem = (product, quantity, customizations) => {
    dispatch({
      type: CART_ACTIONS.ADD_ITEM,
      payload: { product, quantity, customizations },
    });
  };

  const removeItem = (itemId) => {
    dispatch({
      type: CART_ACTIONS.REMOVE_ITEM,
      payload: { itemId },
    });
  };

  const updateQuantity = (itemId, quantity) => {
    dispatch({
      type: CART_ACTIONS.UPDATE_QUANTITY,
      payload: { itemId, quantity },
    });
  };

  const applyCoupon = async (couponCode) => {
    dispatch({ type: CART_ACTIONS.SET_LOADING, payload: true });

    try {
      // Simulate API call to validate coupon
      const coupon = await validateCoupon(couponCode, subtotal);
      dispatch({
        type: CART_ACTIONS.APPLY_COUPON,
        payload: { coupon },
      });
    } catch (error) {
      dispatch({
        type: CART_ACTIONS.SET_ERROR,
        payload: error.message,
      });
    }
  };

  const setShipping = (method) => {
    dispatch({
      type: CART_ACTIONS.SET_SHIPPING,
      payload: { method },
    });
  };

  const bulkUpdateQuantities = (updates) => {
    dispatch({
      type: CART_ACTIONS.BULK_UPDATE,
      payload: { updates },
    });
  };

  const clearCart = () => {
    dispatch({ type: CART_ACTIONS.CLEAR_CART });
  };

  const value = {
    ...cartState,
    subtotal,
    discountAmount,
    shippingCost,
    taxAmount,
    total,
    addItem,
    removeItem,
    updateQuantity,
    applyCoupon,
    removeCoupon: () => dispatch({ type: CART_ACTIONS.REMOVE_COUPON }),
    setShipping,
    bulkUpdateQuantities,
    clearCart,
  };

  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
};

// Helper function to simulate coupon validation
const validateCoupon = async (code, orderAmount) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const coupons = {
        SAVE10: {
          code: "SAVE10",
          type: "percentage",
          value: 10,
          minOrderAmount: 50,
        },
        FLAT20: {
          code: "FLAT20",
          type: "fixed",
          value: 20,
          minOrderAmount: 100,
        },
        WELCOME: {
          code: "WELCOME",
          type: "percentage",
          value: 15,
          minOrderAmount: 0,
        },
      };

      const coupon = coupons[code.toUpperCase()];

      if (!coupon) {
        reject(new Error("Invalid coupon code"));
      } else if (orderAmount < coupon.minOrderAmount) {
        reject(
          new Error(
            `Minimum order amount of $${coupon.minOrderAmount} required`,
          ),
        );
      } else {
        resolve(coupon);
      }
    }, 1000);
  });
};

// Hook to use cart context
export const useCart = () => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error("useCart must be used within a CartProvider");
  }
  return context;
};

// Cart component
const ShoppingCartComponent = () => {
  const {
    items,
    subtotal,
    discountAmount,
    shippingCost,
    taxAmount,
    total,
    coupon,
    shippingMethod,
    loading,
    error,
    metadata,
    updateQuantity,
    removeItem,
    applyCoupon,
    removeCoupon,
    setShipping,
    clearCart,
  } = useCart();

  const [couponCode, setCouponCode] = React.useState("");

  const handleCouponSubmit = (e) => {
    e.preventDefault();
    if (couponCode.trim()) {
      applyCoupon(couponCode.trim());
      setCouponCode("");
    }
  };

  const shippingOptions = [
    { id: "standard", name: "Standard Shipping (5-7 days)", cost: 5.99 },
    { id: "express", name: "Express Shipping (2-3 days)", cost: 12.99 },
    { id: "overnight", name: "Overnight Shipping", cost: 24.99 },
  ];

  return (
    <div className="shopping-cart">
      <div className="cart-header">
        <h2>Shopping Cart ({metadata.itemCount} items)</h2>
        {metadata.lastUpdated && (
          <small>
            Last updated: {new Date(metadata.lastUpdated).toLocaleTimeString()}
          </small>
        )}
      </div>

      {error && <div className="error-message">{error}</div>}

      {items.length === 0 ? (
        <div className="empty-cart">
          <p>Your cart is empty</p>
        </div>
      ) : (
        <>
          <div className="cart-items">
            {items.map((item) => (
              <div
                key={`${item.id}-${JSON.stringify(item.customizations)}`}
                className="cart-item"
              >
                <div className="item-info">
                  <h4>{item.name}</h4>
                  <p>${item.price.toFixed(2)} each</p>
                  {Object.keys(item.customizations).length > 0 && (
                    <div className="customizations">
                      {Object.entries(item.customizations).map(
                        ([key, value]) => (
                          <span key={key} className="customization">
                            {key}: {value}
                          </span>
                        ),
                      )}
                    </div>
                  )}
                </div>

                <div className="quantity-controls">
                  <button
                    onClick={() => updateQuantity(item.id, item.quantity - 1)}
                    disabled={loading}
                  >
                    -
                  </button>
                  <span>{item.quantity}</span>
                  <button
                    onClick={() => updateQuantity(item.id, item.quantity + 1)}
                    disabled={loading}
                  >
                    +
                  </button>
                </div>

                <div className="item-total">
                  ${(item.price * item.quantity).toFixed(2)}
                </div>

                <button
                  onClick={() => removeItem(item.id)}
                  className="remove-button"
                  disabled={loading}
                >
                  Remove
                </button>
              </div>
            ))}
          </div>

          <div className="cart-totals">
            <div className="coupon-section">
              <form onSubmit={handleCouponSubmit}>
                <input
                  type="text"
                  value={couponCode}
                  onChange={(e) => setCouponCode(e.target.value)}
                  placeholder="Enter coupon code"
                  disabled={loading}
                />
                <button type="submit" disabled={loading || !couponCode.trim()}>
                  {loading ? "Applying..." : "Apply"}
                </button>
              </form>

              {coupon && (
                <div className="applied-coupon">
                  <span>✓ Coupon "{coupon.code}" applied</span>
                  <button onClick={removeCoupon}>Remove</button>
                </div>
              )}
            </div>

            <div className="shipping-section">
              <h4>Shipping Options</h4>
              {shippingOptions.map((option) => (
                <label key={option.id}>
                  <input
                    type="radio"
                    name="shipping"
                    checked={shippingMethod?.id === option.id}
                    onChange={() => setShipping(option)}
                  />
                  {option.name} - ${option.cost.toFixed(2)}
                </label>
              ))}
            </div>

            <div className="order-summary">
              <div className="summary-line">
                <span>Subtotal:</span>
                <span>${subtotal.toFixed(2)}</span>
              </div>

              {discountAmount > 0 && (
                <div className="summary-line discount">
                  <span>Discount:</span>
                  <span>-${discountAmount.toFixed(2)}</span>
                </div>
              )}

              {shippingCost > 0 && (
                <div className="summary-line">
                  <span>Shipping:</span>
                  <span>${shippingCost.toFixed(2)}</span>
                </div>
              )}

              <div className="summary-line">
                <span>Tax:</span>
                <span>${taxAmount.toFixed(2)}</span>
              </div>

              <div className="summary-line total">
                <span>Total:</span>
                <span>${total.toFixed(2)}</span>
              </div>
            </div>

            <div className="cart-actions">
              <button onClick={clearCart} className="clear-cart">
                Clear Cart
              </button>
              <button className="checkout-button">Proceed to Checkout</button>
            </div>
          </div>
        </>
      )}
    </div>
  );
};
```

<BackToTop />

## Best Practices

- Keep Reducer Functions Pure: Ensure that your reducer functions are pure and do not contain side effects. This helps maintain predictable state transitions and makes debugging easier.
- Use Action Types: Define action types as constants to avoid typos and make your code more maintainable. This helps ensure that the action types are consistent throughout your application.
- Organize Reducer Logic: If your reducer logic becomes complex, consider organizing it into separate functions or files. This helps keep your codebase clean and maintainable.
- Use Descriptive Action Names: Use descriptive names for your actions to make it clear what each action does. This improves code readability and makes it easier to understand the state transitions.
- Avoid Deeply Nested State: While `useReducer` can handle complex state, deeply nested state can make it difficult to manage and reason about. Consider flattening the state structure or using multiple reducers for different parts of the state.
- Test Reducer Functions: Write unit tests for your reducer functions to ensure that they behave as expected. This helps catch bugs early and ensures that your state transitions are predictable.
- Use `useMemo` for Derived State: If you need to derive state from the reducer state, consider using `useMemo` to memoize the derived state. This can help optimize performance by preventing unnecessary recalculations when the state changes.
- Use `useCallback` for Dispatch Functions: If you need to pass the dispatch function to child components, consider using `useCallback` to memoize the dispatch function. This can help prevent unnecessary re-renders of child components when the dispatch function changes.
- Use `useEffect` for Side Effects: If you need to perform side effects based on state changes, use the `useEffect` hook. This allows you to handle side effects in a clean and organized way, separate from the reducer logic.
- Document Reducer Logic: Document your reducer logic to explain how state transitions occur and what each action does. This helps other developers (and your future self) understand the state management logic and makes it easier to maintain the codebase.
- Use TypeScript for Type Safety: If you're using TypeScript, define types for your state and actions to ensure type safety. This helps catch errors at compile time and improves code readability by providing clear type definitions for your state and actions.
- Avoid Overusing: While `useReducer` is powerful, it can add complexity to your codebase. Use it when necessary, but don't overuse it for simple state management tasks. For simpler state management, consider using `useState` instead.
- Use Context for Global State: If you need to share state across multiple components, consider using the Context API in combination with `useReducer`. This allows you to manage global state in a centralized way while still using the reducer pattern for state management.
- Profile Performance: If you notice performance issues in your application, use React's profiling tools to identify bottlenecks. This can help you optimize your reducer logic and improve the performance of your application.
  <BackToTop />
