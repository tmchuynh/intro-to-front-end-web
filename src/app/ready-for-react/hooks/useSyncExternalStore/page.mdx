import BackToTop from "@/components/BackToTop";

# useSyncExternalStore

## Table of Contents

## Overview

The `useSyncExternalStore` hook in React is designed to subscribe to external stores and ensure that your component re-renders when the store's state changes. This hook is particularly useful for integrating with state management libraries or custom stores that need to notify React components about updates.

### Benefits of `useSyncExternalStore`:

- Synchronization: It ensures that your component's state is always in sync with the external store, preventing inconsistencies between the UI and the underlying data.
- Performance: By subscribing to external stores, you can optimize performance by avoiding unnecessary re-renders and only updating the component when the store's state changes.
- Flexibility: It allows you to work with various types of external stores, whether they are custom implementations or third-party libraries, making it a versatile tool for managing state in React applications.

### When to Use `useSyncExternalStore`:

- When you need to integrate with external state management libraries or custom stores that provide a subscription mechanism.
- When you want to ensure that your component re-renders only when the external store's state changes, improving performance and reducing unnecessary updates.
- When you need to manage complex state interactions that involve multiple components or external data sources.

### Syntax

```javascript
import React, { useSyncExternalStore } from "react";
const useMyStore = (subscribe, getSnapshot) => {
  return useSyncExternalStore(subscribe, getSnapshot);
};
```

### Parameters

- `subscribe`: A function that registers a callback to be called when the external store's state changes. This function should return an unsubscribe function to clean up the subscription.
- `getSnapshot`: A function that retrieves the current state of the external store. This function is called to get the initial state and whenever the store updates.

### Return Value

- The current state of the external store, which can be used in your component to render the UI based on the store's data.

## Common Use Cases

- Integrating with Redux: Use `useSyncExternalStore` to subscribe to a Redux store and get the current state, ensuring that your component re-renders when the Redux state changes.
- Custom State Management: Implement your own state management solution using `useSyncExternalStore` to manage complex state interactions between multiple components or external data sources.
- Third-Party Libraries: Integrate with third-party libraries that provide a subscription mechanism, such as MobX or Zustand, to keep your component in sync with the external store's state.

## How It Works

The `useSyncExternalStore` hook works by subscribing to an external store and retrieving its current state. When the store's state changes, the provided `subscribe` function is called, triggering a re-render of the component with the updated state. The `getSnapshot` function is used to get the current state of the store, ensuring that the component always has the latest data.

## What to Avoid

- Avoid Using `useSyncExternalStore` for Local State: This hook is specifically designed for external stores. For managing local component state, use `useState` or `useReducer`.
- Avoid Overusing Subscriptions: Subscribing to too many external stores can lead to performance issues. Only subscribe to the stores that are necessary for your component's functionality.
- Avoid Blocking the Main Thread: Ensure that the `subscribe` and `getSnapshot` functions are efficient and do not block the main thread, as this can lead to performance degradation and a poor user experience.
  <BackToTop />

## Examples

### Real-Time WebSocket Chat Store

This example demonstrates using `useSyncExternalStore` with WebSocket connections for real-time chat functionality:

```javascript
import React, { useSyncExternalStore, useState, useEffect } from "react";

// WebSocket Chat Store
class ChatStore {
  constructor() {
    this.state = {
      messages: [],
      users: [],
      connectionStatus: "disconnected",
      typingUsers: [],
      unreadCount: 0,
    };
    this.listeners = new Set();
    this.socket = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
  }

  subscribe = (callback) => {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  };

  getSnapshot = () => {
    return this.state;
  };

  connect = (userId, roomId) => {
    try {
      this.socket = new WebSocket(
        `ws://localhost:8080/chat?userId=${userId}&roomId=${roomId}`,
      );

      this.socket.onopen = () => {
        this.updateState({ connectionStatus: "connected" });
        this.reconnectAttempts = 0;
        console.log("Connected to chat server");
      };

      this.socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      };

      this.socket.onclose = () => {
        this.updateState({ connectionStatus: "disconnected" });
        this.attemptReconnect(userId, roomId);
      };

      this.socket.onerror = (error) => {
        console.error("WebSocket error:", error);
        this.updateState({ connectionStatus: "error" });
      };
    } catch (error) {
      console.error("Failed to connect:", error);
      this.updateState({ connectionStatus: "error" });
    }
  };

  handleMessage = (data) => {
    switch (data.type) {
      case "message":
        this.updateState({
          messages: [...this.state.messages, data.payload],
          unreadCount: this.state.unreadCount + 1,
        });
        break;
      case "userJoined":
        this.updateState({
          users: [...this.state.users, data.payload],
          messages: [
            ...this.state.messages,
            {
              id: Date.now(),
              type: "system",
              content: `${data.payload.name} joined the chat`,
              timestamp: new Date().toISOString(),
            },
          ],
        });
        break;
      case "userLeft":
        this.updateState({
          users: this.state.users.filter((user) => user.id !== data.payload.id),
          messages: [
            ...this.state.messages,
            {
              id: Date.now(),
              type: "system",
              content: `${data.payload.name} left the chat`,
              timestamp: new Date().toISOString(),
            },
          ],
        });
        break;
      case "typing":
        this.updateTypingUsers(data.payload);
        break;
      case "usersList":
        this.updateState({ users: data.payload });
        break;
    }
  };

  updateTypingUsers = (typingData) => {
    if (typingData.isTyping) {
      this.updateState({
        typingUsers: [
          ...this.state.typingUsers.filter((u) => u.id !== typingData.userId),
          typingData,
        ],
      });

      // Remove typing indicator after 3 seconds
      setTimeout(() => {
        this.updateState({
          typingUsers: this.state.typingUsers.filter(
            (u) => u.id !== typingData.userId,
          ),
        });
      }, 3000);
    } else {
      this.updateState({
        typingUsers: this.state.typingUsers.filter(
          (u) => u.id !== typingData.userId,
        ),
      });
    }
  };

  sendMessage = (content, userId, userName) => {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      const message = {
        type: "message",
        payload: {
          id: Date.now(),
          content,
          userId,
          userName,
          timestamp: new Date().toISOString(),
        },
      };
      this.socket.send(JSON.stringify(message));
    }
  };

  sendTyping = (userId, userName, isTyping) => {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(
        JSON.stringify({
          type: "typing",
          payload: { userId, userName, isTyping },
        }),
      );
    }
  };

  clearUnreadCount = () => {
    this.updateState({ unreadCount: 0 });
  };

  attemptReconnect = (userId, roomId) => {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      this.updateState({ connectionStatus: "reconnecting" });

      setTimeout(
        () => {
          console.log(`Reconnection attempt ${this.reconnectAttempts}`);
          this.connect(userId, roomId);
        },
        Math.pow(2, this.reconnectAttempts) * 1000,
      ); // Exponential backoff
    }
  };

  updateState = (newState) => {
    this.state = { ...this.state, ...newState };
    this.listeners.forEach((callback) => callback());
  };

  disconnect = () => {
    if (this.socket) {
      this.socket.close();
      this.socket = null;
    }
    this.updateState({
      connectionStatus: "disconnected",
      messages: [],
      users: [],
      typingUsers: [],
    });
  };
}

// Create singleton instance
const chatStore = new ChatStore();

// Custom hook for using chat store
const useChatStore = () => {
  return useSyncExternalStore(chatStore.subscribe, chatStore.getSnapshot);
};

// Chat Component
const ChatRoom = ({ userId, userName, roomId }) => {
  const { messages, users, connectionStatus, typingUsers, unreadCount } =
    useChatStore();
  const [messageInput, setMessageInput] = useState("");
  const [isTyping, setIsTyping] = useState(false);

  useEffect(() => {
    chatStore.connect(userId, roomId);
    return () => chatStore.disconnect();
  }, [userId, roomId]);

  useEffect(() => {
    // Clear unread count when component is visible
    const handleFocus = () => chatStore.clearUnreadCount();
    window.addEventListener("focus", handleFocus);
    return () => window.removeEventListener("focus", handleFocus);
  }, []);

  const handleSendMessage = (e) => {
    e.preventDefault();
    if (messageInput.trim() && connectionStatus === "connected") {
      chatStore.sendMessage(messageInput, userId, userName);
      setMessageInput("");
      setIsTyping(false);
      chatStore.sendTyping(userId, userName, false);
    }
  };

  const handleInputChange = (e) => {
    setMessageInput(e.target.value);

    if (!isTyping && e.target.value.length > 0) {
      setIsTyping(true);
      chatStore.sendTyping(userId, userName, true);
    } else if (isTyping && e.target.value.length === 0) {
      setIsTyping(false);
      chatStore.sendTyping(userId, userName, false);
    }
  };

  const getConnectionStatusColor = () => {
    switch (connectionStatus) {
      case "connected":
        return "#28a745";
      case "connecting":
        return "#ffc107";
      case "reconnecting":
        return "#fd7e14";
      case "error":
        return "#dc3545";
      default:
        return "#6c757d";
    }
  };

  return (
    <div
      style={{
        maxWidth: "800px",
        margin: "0 auto",
        border: "1px solid #ddd",
        borderRadius: "8px",
        overflow: "hidden",
      }}
    >
      {/* Header */}
      <div
        style={{
          backgroundColor: "#f8f9fa",
          padding: "15px",
          borderBottom: "1px solid #ddd",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <h3 style={{ margin: 0 }}>Chat Room: {roomId}</h3>
        <div style={{ display: "flex", alignItems: "center", gap: "15px" }}>
          <div style={{ display: "flex", alignItems: "center", gap: "5px" }}>
            <div
              style={{
                width: "10px",
                height: "10px",
                backgroundColor: getConnectionStatusColor(),
                borderRadius: "50%",
              }}
            />
            <span style={{ fontSize: "14px", textTransform: "capitalize" }}>
              {connectionStatus}
            </span>
          </div>
          <div style={{ fontSize: "14px" }}>
            {users.length} user{users.length !== 1 ? "s" : ""} online
          </div>
          {unreadCount > 0 && (
            <div
              style={{
                backgroundColor: "#dc3545",
                color: "white",
                borderRadius: "12px",
                padding: "2px 8px",
                fontSize: "12px",
              }}
            >
              {unreadCount} new
            </div>
          )}
        </div>
      </div>

      <div style={{ display: "flex", height: "500px" }}>
        {/* Users sidebar */}
        <div
          style={{
            width: "200px",
            backgroundColor: "#f8f9fa",
            borderRight: "1px solid #ddd",
            padding: "15px",
            overflow: "auto",
          }}
        >
          <h4 style={{ margin: "0 0 15px 0", fontSize: "16px" }}>
            Online Users
          </h4>
          {users.map((user) => (
            <div
              key={user.id}
              style={{
                padding: "5px 0",
                display: "flex",
                alignItems: "center",
                gap: "8px",
              }}
            >
              <div
                style={{
                  width: "8px",
                  height: "8px",
                  backgroundColor: "#28a745",
                  borderRadius: "50%",
                }}
              />
              <span style={{ fontSize: "14px" }}>{user.name}</span>
            </div>
          ))}
        </div>

        {/* Messages area */}
        <div style={{ flex: 1, display: "flex", flexDirection: "column" }}>
          <div
            style={{
              flex: 1,
              padding: "15px",
              overflow: "auto",
              backgroundColor: "white",
            }}
          >
            {messages.map((message) => (
              <div
                key={message.id}
                style={{
                  marginBottom: "15px",
                  padding: message.type === "system" ? "5px 0" : "10px",
                  backgroundColor:
                    message.type === "system"
                      ? "transparent"
                      : message.userId === userId
                        ? "#e3f2fd"
                        : "#f5f5f5",
                  borderRadius: message.type === "system" ? "0" : "8px",
                  alignSelf:
                    message.userId === userId ? "flex-end" : "flex-start",
                  maxWidth: message.type === "system" ? "100%" : "70%",
                  textAlign: message.type === "system" ? "center" : "left",
                }}
              >
                {message.type === "system" ? (
                  <div
                    style={{
                      fontStyle: "italic",
                      color: "#666",
                      fontSize: "14px",
                    }}
                  >
                    {message.content}
                  </div>
                ) : (
                  <>
                    <div
                      style={{
                        fontWeight: "bold",
                        fontSize: "14px",
                        color: "#333",
                        marginBottom: "5px",
                      }}
                    >
                      {message.userName}
                    </div>
                    <div style={{ fontSize: "16px", marginBottom: "5px" }}>
                      {message.content}
                    </div>
                    <div
                      style={{
                        fontSize: "12px",
                        color: "#666",
                        textAlign: "right",
                      }}
                    >
                      {new Date(message.timestamp).toLocaleTimeString()}
                    </div>
                  </>
                )}
              </div>
            ))}

            {/* Typing indicators */}
            {typingUsers.length > 0 && (
              <div
                style={{
                  fontStyle: "italic",
                  color: "#666",
                  fontSize: "14px",
                  padding: "10px",
                  backgroundColor: "#f9f9f9",
                  borderRadius: "8px",
                }}
              >
                {typingUsers.map((user) => user.userName).join(", ")}
                {typingUsers.length === 1 ? " is" : " are"} typing...
              </div>
            )}
          </div>

          {/* Message input */}
          <form
            onSubmit={handleSendMessage}
            style={{
              padding: "15px",
              borderTop: "1px solid #ddd",
              backgroundColor: "#f8f9fa",
            }}
          >
            <div style={{ display: "flex", gap: "10px" }}>
              <input
                type="text"
                value={messageInput}
                onChange={handleInputChange}
                placeholder={
                  connectionStatus === "connected"
                    ? "Type a message..."
                    : "Connecting..."
                }
                disabled={connectionStatus !== "connected"}
                style={{
                  flex: 1,
                  padding: "10px",
                  border: "1px solid #ddd",
                  borderRadius: "4px",
                  fontSize: "16px",
                }}
              />
              <button
                type="submit"
                disabled={
                  !messageInput.trim() || connectionStatus !== "connected"
                }
                style={{
                  padding: "10px 20px",
                  backgroundColor: "#007bff",
                  color: "white",
                  border: "none",
                  borderRadius: "4px",
                  cursor:
                    connectionStatus !== "connected"
                      ? "not-allowed"
                      : "pointer",
                  opacity: connectionStatus !== "connected" ? 0.6 : 1,
                }}
              >
                Send
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
};

export default ChatRoom;
```

<BackToTop />

### Browser Storage Synchronization Store

This example shows how to sync state across browser tabs using localStorage and the storage event:

```javascript
import React, { useSyncExternalStore, useState, useEffect } from "react";

// Browser Storage Store
class BrowserStorageStore {
  constructor(key, initialValue = null) {
    this.key = key;
    this.listeners = new Set();
    this.state = this.getStoredValue() || initialValue;

    // Listen for storage changes from other tabs
    this.handleStorageChange = this.handleStorageChange.bind(this);
    if (typeof window !== "undefined") {
      window.addEventListener("storage", this.handleStorageChange);
    }
  }

  subscribe = (callback) => {
    this.listeners.add(callback);
    return () => {
      this.listeners.delete(callback);
      // Clean up storage listener when no more subscribers
      if (this.listeners.size === 0 && typeof window !== "undefined") {
        window.removeEventListener("storage", this.handleStorageChange);
      }
    };
  };

  getSnapshot = () => {
    return this.state;
  };

  getStoredValue = () => {
    if (typeof window === "undefined") return null;
    try {
      const item = localStorage.getItem(this.key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error("Error reading from localStorage:", error);
      return null;
    }
  };

  setValue = (value) => {
    try {
      // Update internal state
      this.state = value;

      // Save to localStorage
      if (typeof window !== "undefined") {
        if (value === null || value === undefined) {
          localStorage.removeItem(this.key);
        } else {
          localStorage.setItem(this.key, JSON.stringify(value));
        }
      }

      // Notify all subscribers
      this.listeners.forEach((callback) => callback());
    } catch (error) {
      console.error("Error saving to localStorage:", error);
    }
  };

  updateValue = (updater) => {
    const newValue =
      typeof updater === "function" ? updater(this.state) : updater;
    this.setValue(newValue);
  };

  handleStorageChange = (event) => {
    if (event.key === this.key) {
      // Update state from storage change (from another tab)
      const newValue = event.newValue ? JSON.parse(event.newValue) : null;
      this.state = newValue;
      this.listeners.forEach((callback) => callback());
    }
  };

  clear = () => {
    this.setValue(null);
  };
}

// Custom hook for using browser storage store
const useBrowserStorage = (key, initialValue) => {
  const [store] = useState(() => new BrowserStorageStore(key, initialValue));

  const state = useSyncExternalStore(store.subscribe, store.getSnapshot);

  return [state, store.setValue, store.updateValue, store.clear];
};

// Multi-Tab Shopping Cart Demo
const ShoppingCartDemo = () => {
  const [cart, setCart, updateCart, clearCart] = useBrowserStorage(
    "shopping-cart",
    {
      items: [],
      total: 0,
      lastModified: null,
      tabId: Math.random().toString(36).substr(2, 9),
    },
  );

  const [currentTabId] = useState(() =>
    Math.random().toString(36).substr(2, 9),
  );

  // Sample products
  const products = [
    { id: 1, name: "Laptop", price: 999.99, image: "üíª" },
    { id: 2, name: "Smartphone", price: 699.99, image: "üì±" },
    { id: 3, name: "Headphones", price: 199.99, image: "üéß" },
    { id: 4, name: "Tablet", price: 399.99, image: "üì±" },
    { id: 5, name: "Smart Watch", price: 299.99, image: "‚åö" },
    { id: 6, name: "Camera", price: 599.99, image: "üì∑" },
  ];

  const addToCart = (product) => {
    updateCart((prevCart) => {
      const existingItem = prevCart.items.find(
        (item) => item.id === product.id,
      );
      let newItems;

      if (existingItem) {
        newItems = prevCart.items.map((item) =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item,
        );
      } else {
        newItems = [...prevCart.items, { ...product, quantity: 1 }];
      }

      const newTotal = newItems.reduce(
        (sum, item) => sum + item.price * item.quantity,
        0,
      );

      return {
        items: newItems,
        total: newTotal,
        lastModified: new Date().toISOString(),
        tabId: currentTabId,
      };
    });
  };

  const removeFromCart = (productId) => {
    updateCart((prevCart) => {
      const newItems = prevCart.items.filter((item) => item.id !== productId);
      const newTotal = newItems.reduce(
        (sum, item) => sum + item.price * item.quantity,
        0,
      );

      return {
        items: newItems,
        total: newTotal,
        lastModified: new Date().toISOString(),
        tabId: currentTabId,
      };
    });
  };

  const updateQuantity = (productId, newQuantity) => {
    if (newQuantity <= 0) {
      removeFromCart(productId);
      return;
    }

    updateCart((prevCart) => {
      const newItems = prevCart.items.map((item) =>
        item.id === productId ? { ...item, quantity: newQuantity } : item,
      );

      const newTotal = newItems.reduce(
        (sum, item) => sum + item.price * item.quantity,
        0,
      );

      return {
        items: newItems,
        total: newTotal,
        lastModified: new Date().toISOString(),
        tabId: currentTabId,
      };
    });
  };

  const getTotalItems = () => {
    return cart?.items?.reduce((sum, item) => sum + item.quantity, 0) || 0;
  };

  return (
    <div style={{ maxWidth: "1200px", margin: "0 auto", padding: "20px" }}>
      <h2>Multi-Tab Shopping Cart Demo</h2>
      <p style={{ color: "#666", marginBottom: "20px" }}>
        Open this page in multiple tabs to see real-time cart synchronization!
        Current Tab ID: <code>{currentTabId}</code>
      </p>

      {cart?.lastModified && cart.tabId !== currentTabId && (
        <div
          style={{
            backgroundColor: "#d4edda",
            border: "1px solid #c3e6cb",
            borderRadius: "4px",
            padding: "12px",
            marginBottom: "20px",
          }}
        >
          üîÑ Cart updated from another tab at{" "}
          {new Date(cart.lastModified).toLocaleTimeString()}
        </div>
      )}

      <div
        style={{ display: "grid", gridTemplateColumns: "2fr 1fr", gap: "30px" }}
      >
        {/* Products Grid */}
        <div>
          <h3>Products</h3>
          <div
            style={{
              display: "grid",
              gridTemplateColumns: "repeat(auto-fill, minmax(250px, 1fr))",
              gap: "20px",
            }}
          >
            {products.map((product) => (
              <div
                key={product.id}
                style={{
                  border: "1px solid #ddd",
                  borderRadius: "8px",
                  padding: "15px",
                  backgroundColor: "white",
                  boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
                }}
              >
                <div
                  style={{
                    fontSize: "48px",
                    textAlign: "center",
                    marginBottom: "10px",
                  }}
                >
                  {product.image}
                </div>
                <h4 style={{ margin: "0 0 10px 0", textAlign: "center" }}>
                  {product.name}
                </h4>
                <p
                  style={{
                    margin: "0 0 15px 0",
                    textAlign: "center",
                    fontSize: "18px",
                    fontWeight: "bold",
                    color: "#007bff",
                  }}
                >
                  ${product.price}
                </p>
                <button
                  onClick={() => addToCart(product)}
                  style={{
                    width: "100%",
                    padding: "10px",
                    backgroundColor: "#28a745",
                    color: "white",
                    border: "none",
                    borderRadius: "4px",
                    cursor: "pointer",
                    fontSize: "16px",
                  }}
                >
                  Add to Cart
                </button>
              </div>
            ))}
          </div>
        </div>

        {/* Shopping Cart */}
        <div>
          <div style={{ position: "sticky", top: "20px" }}>
            <h3
              style={{
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
              }}
            >
              Shopping Cart
              <span
                style={{
                  backgroundColor: "#007bff",
                  color: "white",
                  borderRadius: "50%",
                  width: "24px",
                  height: "24px",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  fontSize: "14px",
                }}
              >
                {getTotalItems()}
              </span>
            </h3>

            <div
              style={{
                border: "1px solid #ddd",
                borderRadius: "8px",
                backgroundColor: "white",
                minHeight: "300px",
              }}
            >
              {!cart?.items?.length ? (
                <div
                  style={{
                    padding: "40px 20px",
                    textAlign: "center",
                    color: "#666",
                  }}
                >
                  Your cart is empty
                </div>
              ) : (
                <>
                  <div style={{ maxHeight: "300px", overflow: "auto" }}>
                    {cart.items.map((item) => (
                      <div
                        key={item.id}
                        style={{
                          padding: "15px",
                          borderBottom: "1px solid #eee",
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center",
                        }}
                      >
                        <div style={{ flex: 1 }}>
                          <div
                            style={{ fontWeight: "bold", marginBottom: "5px" }}
                          >
                            {item.name}
                          </div>
                          <div style={{ color: "#666", fontSize: "14px" }}>
                            ${item.price} each
                          </div>
                        </div>
                        <div
                          style={{
                            display: "flex",
                            alignItems: "center",
                            gap: "10px",
                          }}
                        >
                          <button
                            onClick={() =>
                              updateQuantity(item.id, item.quantity - 1)
                            }
                            style={{
                              width: "24px",
                              height: "24px",
                              border: "1px solid #ddd",
                              backgroundColor: "white",
                              cursor: "pointer",
                            }}
                          >
                            -
                          </button>
                          <span
                            style={{ minWidth: "20px", textAlign: "center" }}
                          >
                            {item.quantity}
                          </span>
                          <button
                            onClick={() =>
                              updateQuantity(item.id, item.quantity + 1)
                            }
                            style={{
                              width: "24px",
                              height: "24px",
                              border: "1px solid #ddd",
                              backgroundColor: "white",
                              cursor: "pointer",
                            }}
                          >
                            +
                          </button>
                          <button
                            onClick={() => removeFromCart(item.id)}
                            style={{
                              marginLeft: "10px",
                              padding: "4px 8px",
                              backgroundColor: "#dc3545",
                              color: "white",
                              border: "none",
                              borderRadius: "4px",
                              cursor: "pointer",
                              fontSize: "12px",
                            }}
                          >
                            Remove
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>

                  <div style={{ padding: "15px", borderTop: "2px solid #ddd" }}>
                    <div
                      style={{
                        display: "flex",
                        justifyContent: "space-between",
                        fontSize: "18px",
                        fontWeight: "bold",
                        marginBottom: "15px",
                      }}
                    >
                      <span>Total:</span>
                      <span>${cart.total?.toFixed(2)}</span>
                    </div>

                    <button
                      style={{
                        width: "100%",
                        padding: "12px",
                        backgroundColor: "#007bff",
                        color: "white",
                        border: "none",
                        borderRadius: "4px",
                        cursor: "pointer",
                        fontSize: "16px",
                        marginBottom: "10px",
                      }}
                      onClick={() =>
                        alert("Checkout functionality would go here!")
                      }
                    >
                      Checkout
                    </button>

                    <button
                      onClick={clearCart}
                      style={{
                        width: "100%",
                        padding: "8px",
                        backgroundColor: "#dc3545",
                        color: "white",
                        border: "none",
                        borderRadius: "4px",
                        cursor: "pointer",
                        fontSize: "14px",
                      }}
                    >
                      Clear Cart
                    </button>
                  </div>
                </>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ShoppingCartDemo;
```

<BackToTop />

### Real-Time Geolocation Tracking Store

This example demonstrates tracking device location with `useSyncExternalStore` for location-based applications:

```javascript
import React, { useSyncExternalStore, useState, useEffect } from "react";

// Geolocation Store
class GeolocationStore {
  constructor() {
    this.state = {
      position: null,
      error: null,
      isTracking: false,
      accuracy: null,
      speed: null,
      heading: null,
      timestamp: null,
      permissionStatus: "prompt",
    };
    this.listeners = new Set();
    this.watchId = null;
    this.options = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 1000,
    };
  }

  subscribe = (callback) => {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  };

  getSnapshot = () => {
    return this.state;
  };

  startTracking = async () => {
    if (!navigator.geolocation) {
      this.updateState({
        error: "Geolocation is not supported by this browser",
        permissionStatus: "denied",
      });
      return;
    }

    try {
      // Check permission status
      const permission = await navigator.permissions.query({
        name: "geolocation",
      });
      this.updateState({ permissionStatus: permission.state });

      this.updateState({ isTracking: true, error: null });

      this.watchId = navigator.geolocation.watchPosition(
        (position) => {
          this.updateState({
            position: {
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              altitude: position.coords.altitude,
              altitudeAccuracy: position.coords.altitudeAccuracy,
            },
            accuracy: position.coords.accuracy,
            speed: position.coords.speed,
            heading: position.coords.heading,
            timestamp: position.timestamp,
            error: null,
            permissionStatus: "granted",
          });
        },
        (error) => {
          let errorMessage;
          switch (error.code) {
            case error.PERMISSION_DENIED:
              errorMessage = "Location access denied by user";
              this.updateState({ permissionStatus: "denied" });
              break;
            case error.POSITION_UNAVAILABLE:
              errorMessage = "Location information unavailable";
              break;
            case error.TIMEOUT:
              errorMessage = "Location request timed out";
              break;
            default:
              errorMessage = "An unknown error occurred";
              break;
          }
          this.updateState({ error: errorMessage, isTracking: false });
        },
        this.options,
      );
    } catch (error) {
      this.updateState({
        error: "Failed to start location tracking",
        isTracking: false,
      });
    }
  };

  stopTracking = () => {
    if (this.watchId !== null) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
    }
    this.updateState({ isTracking: false });
  };

  getCurrentPosition = () => {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error("Geolocation not supported"));
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          this.updateState({
            position: {
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              altitude: position.coords.altitude,
              altitudeAccuracy: position.coords.altitudeAccuracy,
            },
            accuracy: position.coords.accuracy,
            speed: position.coords.speed,
            heading: position.coords.heading,
            timestamp: position.timestamp,
            error: null,
          });
          resolve(position);
        },
        reject,
        this.options,
      );
    });
  };

  updateOptions = (newOptions) => {
    this.options = { ...this.options, ...newOptions };

    // Restart tracking if currently active
    if (this.state.isTracking) {
      this.stopTracking();
      setTimeout(() => this.startTracking(), 100);
    }
  };

  updateState = (newState) => {
    this.state = { ...this.state, ...newState };
    this.listeners.forEach((callback) => callback());
  };
}

// Create singleton instance
const geolocationStore = new GeolocationStore();

// Custom hook
const useGeolocation = () => {
  return useSyncExternalStore(
    geolocationStore.subscribe,
    geolocationStore.getSnapshot,
  );
};

// Location Tracker Component
const LocationTracker = () => {
  const {
    position,
    error,
    isTracking,
    accuracy,
    speed,
    heading,
    timestamp,
    permissionStatus,
  } = useGeolocation();

  const [locationHistory, setLocationHistory] = useState([]);
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState({
    enableHighAccuracy: true,
    timeout: 10000,
    maximumAge: 1000,
  });

  // Track location history
  useEffect(() => {
    if (position && timestamp) {
      setLocationHistory((prev) => {
        const newHistory = [...prev, { ...position, timestamp }];
        // Keep only last 50 positions
        return newHistory.slice(-50);
      });
    }
  }, [position, timestamp]);

  const handleStartTracking = () => {
    geolocationStore.startTracking();
  };

  const handleStopTracking = () => {
    geolocationStore.stopTracking();
  };

  const handleGetCurrentLocation = async () => {
    try {
      await geolocationStore.getCurrentPosition();
    } catch (error) {
      console.error("Failed to get current position:", error);
    }
  };

  const handleSettingsChange = (key, value) => {
    const newSettings = { ...settings, [key]: value };
    setSettings(newSettings);
    geolocationStore.updateOptions(newSettings);
  };

  const clearHistory = () => {
    setLocationHistory([]);
  };

  const exportData = () => {
    const data = {
      currentPosition: position,
      accuracy,
      speed,
      heading,
      timestamp,
      history: locationHistory,
      exportedAt: new Date().toISOString(),
    };

    const blob = new Blob([JSON.stringify(data, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `location-data-${new Date().toISOString().split("T")[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const formatCoordinate = (coord) => {
    return coord ? coord.toFixed(6) : "N/A";
  };

  const formatDistance = (distance) => {
    if (distance < 1000) {
      return `${distance.toFixed(1)} m`;
    }
    return `${(distance / 1000).toFixed(2)} km`;
  };

  const calculateDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371e3; // Earth's radius in meters
    const œÜ1 = (lat1 * Math.PI) / 180;
    const œÜ2 = (lat2 * Math.PI) / 180;
    const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;
    const ŒîŒª = ((lon2 - lon1) * Math.PI) / 180;

    const a =
      Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
      Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
  };

  const getTotalDistance = () => {
    if (locationHistory.length < 2) return 0;

    let total = 0;
    for (let i = 1; i < locationHistory.length; i++) {
      const prev = locationHistory[i - 1];
      const curr = locationHistory[i];
      total += calculateDistance(
        prev.latitude,
        prev.longitude,
        curr.latitude,
        curr.longitude,
      );
    }
    return total;
  };

  return (
    <div style={{ maxWidth: "800px", margin: "0 auto", padding: "20px" }}>
      <h2>Real-Time Geolocation Tracker</h2>

      {/* Permission Status */}
      <div
        style={{
          padding: "10px",
          marginBottom: "20px",
          borderRadius: "4px",
          backgroundColor:
            permissionStatus === "granted"
              ? "#d4edda"
              : permissionStatus === "denied"
                ? "#f8d7da"
                : "#fff3cd",
          border: `1px solid ${
            permissionStatus === "granted"
              ? "#c3e6cb"
              : permissionStatus === "denied"
                ? "#f5c6cb"
                : "#ffeaa7"
          }`,
        }}
      >
        <strong>Permission Status:</strong> {permissionStatus}
        {permissionStatus === "denied" && (
          <div style={{ marginTop: "5px", fontSize: "14px" }}>
            Please enable location access in your browser settings to use this
            feature.
          </div>
        )}
      </div>

      {/* Controls */}
      <div
        style={{
          display: "flex",
          gap: "10px",
          marginBottom: "20px",
          flexWrap: "wrap",
        }}
      >
        <button
          onClick={isTracking ? handleStopTracking : handleStartTracking}
          disabled={permissionStatus === "denied"}
          style={{
            padding: "10px 20px",
            backgroundColor: isTracking ? "#dc3545" : "#28a745",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: permissionStatus === "denied" ? "not-allowed" : "pointer",
            opacity: permissionStatus === "denied" ? 0.6 : 1,
          }}
        >
          {isTracking ? "‚èπÔ∏è Stop Tracking" : "‚ñ∂Ô∏è Start Tracking"}
        </button>

        <button
          onClick={handleGetCurrentLocation}
          disabled={permissionStatus === "denied"}
          style={{
            padding: "10px 20px",
            backgroundColor: "#007bff",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: permissionStatus === "denied" ? "not-allowed" : "pointer",
            opacity: permissionStatus === "denied" ? 0.6 : 1,
          }}
        >
          üìç Get Current Location
        </button>

        <button
          onClick={() => setShowSettings(!showSettings)}
          style={{
            padding: "10px 20px",
            backgroundColor: "#6c757d",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          ‚öôÔ∏è Settings
        </button>

        <button
          onClick={exportData}
          disabled={!position && locationHistory.length === 0}
          style={{
            padding: "10px 20px",
            backgroundColor: "#17a2b8",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor:
              !position && locationHistory.length === 0
                ? "not-allowed"
                : "pointer",
            opacity: !position && locationHistory.length === 0 ? 0.6 : 1,
          }}
        >
          üíæ Export Data
        </button>
      </div>

      {/* Settings Panel */}
      {showSettings && (
        <div
          style={{
            backgroundColor: "#f8f9fa",
            border: "1px solid #ddd",
            borderRadius: "4px",
            padding: "15px",
            marginBottom: "20px",
          }}
        >
          <h4>Tracking Settings</h4>
          <div style={{ display: "grid", gap: "10px" }}>
            <label>
              <input
                type="checkbox"
                checked={settings.enableHighAccuracy}
                onChange={(e) =>
                  handleSettingsChange("enableHighAccuracy", e.target.checked)
                }
                style={{ marginRight: "8px" }}
              />
              Enable High Accuracy (uses GPS)
            </label>

            <label>
              Timeout (ms):
              <input
                type="number"
                value={settings.timeout}
                onChange={(e) =>
                  handleSettingsChange("timeout", parseInt(e.target.value))
                }
                min="1000"
                max="60000"
                step="1000"
                style={{ marginLeft: "8px", padding: "4px", width: "100px" }}
              />
            </label>

            <label>
              Maximum Age (ms):
              <input
                type="number"
                value={settings.maximumAge}
                onChange={(e) =>
                  handleSettingsChange("maximumAge", parseInt(e.target.value))
                }
                min="0"
                max="300000"
                step="1000"
                style={{ marginLeft: "8px", padding: "4px", width: "100px" }}
              />
            </label>
          </div>
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div
          style={{
            backgroundColor: "#f8d7da",
            border: "1px solid #f5c6cb",
            borderRadius: "4px",
            padding: "10px",
            marginBottom: "20px",
            color: "#721c24",
          }}
        >
          <strong>Error:</strong> {error}
        </div>
      )}

      {/* Current Position */}
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(300px, 1fr))",
          gap: "20px",
        }}
      >
        <div
          style={{
            backgroundColor: "white",
            border: "1px solid #ddd",
            borderRadius: "8px",
            padding: "20px",
          }}
        >
          <h3>Current Position</h3>
          {position ? (
            <div style={{ fontSize: "14px" }}>
              <div style={{ marginBottom: "10px" }}>
                <strong>Latitude:</strong> {formatCoordinate(position.latitude)}
              </div>
              <div style={{ marginBottom: "10px" }}>
                <strong>Longitude:</strong>{" "}
                {formatCoordinate(position.longitude)}
              </div>
              {position.altitude && (
                <div style={{ marginBottom: "10px" }}>
                  <strong>Altitude:</strong> {position.altitude.toFixed(1)} m
                </div>
              )}
              {accuracy && (
                <div style={{ marginBottom: "10px" }}>
                  <strong>Accuracy:</strong> ¬±{accuracy.toFixed(1)} m
                </div>
              )}
              {speed !== null && speed > 0 && (
                <div style={{ marginBottom: "10px" }}>
                  <strong>Speed:</strong> {(speed * 3.6).toFixed(1)} km/h
                </div>
              )}
              {heading !== null && (
                <div style={{ marginBottom: "10px" }}>
                  <strong>Heading:</strong> {heading.toFixed(1)}¬∞
                </div>
              )}
              {timestamp && (
                <div style={{ marginBottom: "10px" }}>
                  <strong>Last Update:</strong>{" "}
                  {new Date(timestamp).toLocaleTimeString()}
                </div>
              )}

              <div style={{ marginTop: "15px" }}>
                <a
                  href={`https://maps.google.com/?q=${position.latitude},${position.longitude}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  style={{
                    display: "inline-block",
                    padding: "8px 12px",
                    backgroundColor: "#007bff",
                    color: "white",
                    textDecoration: "none",
                    borderRadius: "4px",
                    fontSize: "14px",
                  }}
                >
                  üìç View on Google Maps
                </a>
              </div>
            </div>
          ) : (
            <p style={{ color: "#666", fontStyle: "italic" }}>
              No location data available
            </p>
          )}
        </div>

        {/* Location History */}
        <div
          style={{
            backgroundColor: "white",
            border: "1px solid #ddd",
            borderRadius: "8px",
            padding: "20px",
          }}
        >
          <div
            style={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              marginBottom: "15px",
            }}
          >
            <h3>Location History</h3>
            <button
              onClick={clearHistory}
              disabled={locationHistory.length === 0}
              style={{
                padding: "5px 10px",
                backgroundColor: "#dc3545",
                color: "white",
                border: "none",
                borderRadius: "4px",
                cursor:
                  locationHistory.length === 0 ? "not-allowed" : "pointer",
                opacity: locationHistory.length === 0 ? 0.6 : 1,
                fontSize: "12px",
              }}
            >
              Clear History
            </button>
          </div>

          {locationHistory.length > 0 ? (
            <>
              <div style={{ marginBottom: "15px", fontSize: "14px" }}>
                <div>
                  <strong>Total Points:</strong> {locationHistory.length}
                </div>
                <div>
                  <strong>Total Distance:</strong>{" "}
                  {formatDistance(getTotalDistance())}
                </div>
              </div>

              <div
                style={{
                  maxHeight: "200px",
                  overflow: "auto",
                  fontSize: "12px",
                }}
              >
                {locationHistory
                  .slice(-10)
                  .reverse()
                  .map((location, index) => (
                    <div
                      key={index}
                      style={{
                        padding: "8px 0",
                        borderBottom: "1px solid #eee",
                      }}
                    >
                      <div>
                        {formatCoordinate(location.latitude)},{" "}
                        {formatCoordinate(location.longitude)}
                      </div>
                      <div style={{ color: "#666" }}>
                        {new Date(location.timestamp).toLocaleTimeString()}
                      </div>
                    </div>
                  ))}
              </div>
            </>
          ) : (
            <p style={{ color: "#666", fontStyle: "italic" }}>
              No location history available
            </p>
          )}
        </div>
      </div>
    </div>
  );
};

export default LocationTracker;
```

<BackToTop />

## Best Practices

- Use Stable Functions: Ensure that the `subscribe` and `getSnapshot` functions are stable and do not change on every render. This helps prevent unnecessary re-renders and improves performance.
- Clean Up Subscriptions: Always return an unsubscribe function from the `subscribe` method to clean up subscriptions when the component unmounts or when the store changes. This prevents memory leaks and ensures that your component does not receive updates from stale subscriptions.
- Optimize Performance: Use memoization techniques, such as `React.memo` or `useMemo`, to optimize performance when rendering components that use `useSyncExternalStore`. This can help reduce unnecessary re-renders and improve the overall performance of your application.
- Test Your Implementation: Ensure that your implementation of `useSyncExternalStore` works correctly by writing tests that verify the subscription and state retrieval logic. This helps catch any issues early and ensures that your component behaves as expected when the external store's state changes.
- Document Your Store: If you are creating a custom store, document its API and usage clearly. This will help other developers understand how to use the store and integrate it with `useSyncExternalStore` effectively.
- Use TypeScript for Type Safety: If you are using TypeScript, define types for your store's state and the `subscribe` and `getSnapshot` functions. This provides type safety and helps catch errors during development, making your code more robust and maintainable.
- Avoid Side Effects in `getSnapshot`: Ensure that the `getSnapshot` function does not have side effects. It should only return the current state of the store without modifying any external data or triggering additional updates. This helps maintain the purity of the function and ensures predictable behavior.
- Keep the Store Simple: When implementing a custom store, keep it simple and focused on managing state. Avoid adding complex logic or side effects within the store itself. Instead, handle side effects in the components that use the store or in separate hooks. This separation of concerns makes your code easier to understand and maintain.
- Use React DevTools: Leverage React DevTools to inspect the state of your components and the external store. This can help you debug issues related to state synchronization and ensure that your components are receiving the correct data from the store.
- Monitor Performance: Use performance monitoring tools to track the performance of your components that use `useSyncExternalStore`. This can help you identify any performance bottlenecks and optimize your implementation accordingly.
- Follow React's Best Practices: Always follow React's best practices for component design and state management. This includes using functional components, avoiding unnecessary state updates, and keeping your components as stateless as possible. By adhering to these principles, you can ensure that your components are efficient, maintainable, and easy to understand.
- Stay Updated: Keep an eye on updates to React and the `useSyncExternalStore` hook. As React evolves, new features and improvements may be introduced that can enhance your implementation or provide new capabilities. Staying updated with the latest changes ensures that you can take advantage of new features and best practices in your applications.
- Use Context for Global State: If you need to share the external store's state across multiple components, consider using React's Context API in conjunction with `useSyncExternalStore`. This allows you to provide the store's state to a wider range of components without having to pass props down through multiple levels of the component tree. It also helps keep your components decoupled and easier to manage.
- Handle Errors Gracefully: Implement error handling in your `subscribe` and `getSnapshot` functions to gracefully handle any issues that may arise when interacting with the external store. This can include logging errors, displaying error messages to users, or providing fallback UI in case of failures. Proper error handling ensures that your application remains robust and user-friendly, even in the face of unexpected issues.
- Use Custom Hooks for Reusability: If you find yourself using `useSyncExternalStore` frequently across different components, consider creating a custom hook that encapsulates the logic for subscribing to the external store and retrieving its state. This promotes code reuse and makes your components cleaner and easier to read. Custom hooks can also help you manage complex state interactions and encapsulate related logic, making your codebase more organized and maintainable.
- Test with Different Store States: When writing tests for components that use `useSyncExternalStore`, ensure that you test with various states of the external store. This includes testing initial states, updates, and edge cases. By covering a wide range of scenarios, you can ensure that your components behave correctly under different conditions and that the synchronization with the external store works as expected. This thorough testing helps catch potential bugs and ensures that your implementation is robust and reliable.
- Document Your Custom Store: If you create a custom store, document its API and usage clearly. This will help other developers understand how to use the store and integrate it with `useSyncExternalStore` effectively. Clear documentation can also serve as a reference for future maintenance and updates, ensuring that your store remains easy to use and understand over time. Include examples of how to subscribe to the store, retrieve its state, and handle updates, as well as any specific behaviors or conventions that users should be aware of when working with your custom store.
  <BackToTop />
